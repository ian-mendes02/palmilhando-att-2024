"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chart.js";
exports.ids = ["vendor-chunks/chart.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chart.js/dist/chart.mjs":
/*!**********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Animations: () => (/* binding */ Animations),\n/* harmony export */   ArcElement: () => (/* binding */ ArcElement),\n/* harmony export */   BarController: () => (/* binding */ BarController),\n/* harmony export */   BarElement: () => (/* binding */ BarElement),\n/* harmony export */   BasePlatform: () => (/* binding */ BasePlatform),\n/* harmony export */   BasicPlatform: () => (/* binding */ BasicPlatform),\n/* harmony export */   BubbleController: () => (/* binding */ BubbleController),\n/* harmony export */   CategoryScale: () => (/* binding */ CategoryScale),\n/* harmony export */   Chart: () => (/* binding */ Chart),\n/* harmony export */   DatasetController: () => (/* binding */ DatasetController),\n/* harmony export */   Decimation: () => (/* binding */ plugin_decimation),\n/* harmony export */   DomPlatform: () => (/* binding */ DomPlatform),\n/* harmony export */   DoughnutController: () => (/* binding */ DoughnutController),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Filler: () => (/* binding */ index),\n/* harmony export */   Interaction: () => (/* binding */ Interaction),\n/* harmony export */   Legend: () => (/* binding */ plugin_legend),\n/* harmony export */   LineController: () => (/* binding */ LineController),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearScale: () => (/* binding */ LinearScale),\n/* harmony export */   LogarithmicScale: () => (/* binding */ LogarithmicScale),\n/* harmony export */   PieController: () => (/* binding */ PieController),\n/* harmony export */   PointElement: () => (/* binding */ PointElement),\n/* harmony export */   PolarAreaController: () => (/* binding */ PolarAreaController),\n/* harmony export */   RadarController: () => (/* binding */ RadarController),\n/* harmony export */   RadialLinearScale: () => (/* binding */ RadialLinearScale),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   ScatterController: () => (/* binding */ ScatterController),\n/* harmony export */   SubTitle: () => (/* binding */ plugin_subtitle),\n/* harmony export */   Ticks: () => (/* binding */ Ticks),\n/* harmony export */   TimeScale: () => (/* binding */ TimeScale),\n/* harmony export */   TimeSeriesScale: () => (/* binding */ TimeSeriesScale),\n/* harmony export */   Title: () => (/* binding */ plugin_title),\n/* harmony export */   Tooltip: () => (/* binding */ plugin_tooltip),\n/* harmony export */   _adapters: () => (/* binding */ adapters),\n/* harmony export */   _detectPlatform: () => (/* binding */ _detectPlatform),\n/* harmony export */   animator: () => (/* binding */ animator),\n/* harmony export */   controllers: () => (/* binding */ controllers),\n/* harmony export */   defaults: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   elements: () => (/* binding */ elements),\n/* harmony export */   layouts: () => (/* binding */ layouts),\n/* harmony export */   plugins: () => (/* binding */ plugins),\n/* harmony export */   registerables: () => (/* binding */ registerables),\n/* harmony export */   registry: () => (/* binding */ registry),\n/* harmony export */   scales: () => (/* binding */ scales)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n    _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n    _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n    _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, \"progress\");\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, \"complete\");\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n    _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n    listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n    add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n    has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n    start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n    stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), \"complete\");\n    }\n    remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = new Animator();\nconst transparent = \"transparent\";\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n    color (from, to, factor) {\n        const c0 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n        const c1 = c0.valid && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? \"res\" : \"rej\";\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\nconst numbers = [\n    \"x\",\n    \"y\",\n    \"borderWidth\",\n    \"radius\",\n    \"tension\"\n];\nconst colors = [\n    \"color\",\n    \"borderColor\",\n    \"backgroundColor\"\n];\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"animation\", {\n    delay: undefined,\n    duration: 1000,\n    easing: \"easeOutQuart\",\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined\n});\nconst animationOptions = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"animation\", {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name)=>name !== \"onProgress\" && name !== \"onComplete\" && name !== \"fn\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"animations\", {\n    colors: {\n        type: \"color\",\n        properties: colors\n    },\n    numbers: {\n        type: \"number\",\n        properties: numbers\n    }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"animations\", {\n    _fallback: \"animation\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"transitions\", {\n    active: {\n        animation: {\n            duration: 400\n        }\n    },\n    resize: {\n        animation: {\n            duration: 0\n        }\n    },\n    show: {\n        animations: {\n            colors: {\n                from: \"transparent\"\n            },\n            visible: {\n                type: \"boolean\",\n                duration: 0\n            }\n        }\n    },\n    hide: {\n        animations: {\n            colors: {\n                to: \"transparent\"\n            },\n            visible: {\n                type: \"boolean\",\n                easing: \"linear\",\n                fn: (v)=>v | 0\n            }\n        }\n    }\n});\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n            return;\n        }\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n    _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{});\n        }\n        return animations;\n    }\n    _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === \"$\") {\n                continue;\n            }\n            if (prop === \"options\") {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n    update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === \"single\";\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {\n            value += otherValue;\n        }\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data) {\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            x: key,\n            y: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min, max, minDefined, maxDefined } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart, _cachedMeta: meta } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale, vScale, index: datasetIndex } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index, [vAxis]: value } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: \"default\",\n        type: \"dataset\"\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: \"default\",\n        type: \"data\"\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === \"reset\" || mode === \"none\";\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n    constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n        this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === \"x\" ? x : axis === \"r\" ? r : y;\n        const xid = meta.xAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, \"x\"));\n        const yid = meta.yAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, \"y\"));\n        const rid = meta.rAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, \"r\"));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n    _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update(\"reset\");\n    }\n    _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n    _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            this._data = convertObjectDataToArray(data);\n        } else if (_data !== data) {\n            if (_data) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n        }\n    }\n    configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n    parse(start, count) {\n        const { _cachedMeta: meta, _data: data } = this;\n        const { iScale, _stacked } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n                y: yScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n    getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n    getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n    applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n    getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n    getMaxOverflow() {\n        return false;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? \"\" + iScale.getLabelForValue(parsed[iScale.axis]) : \"\",\n            value: vScale ? \"\" + vScale.getLabelForValue(parsed[vScale.axis]) : \"\"\n        };\n    }\n    _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || \"default\");\n        meta._clip = toClip((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n    update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n    getStyle(index, active) {\n        const mode = active ? \"active\" : \"default\";\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n    getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n    resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n    resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n    _resolveElementOptions(elementType, mode = \"default\", index) {\n        const active = mode === \"active\";\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + \"-\" + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            \"hover\",\n            elementType,\n            \"\"\n        ] : [\n            elementType,\n            \"\"\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n        const context = ()=>this.getContext(index, active);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n    _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n    includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n    updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n    updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n    _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", true);\n    }\n    _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", false);\n        }\n    }\n    _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", true);\n        }\n    }\n    _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n    _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, \"reset\");\n        }\n    }\n    updateElements(element, start, count, mode) {}\n    _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n    _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            \"_insertElements\",\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            \"_removeElements\",\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            \"_removeElements\",\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                \"_removeElements\",\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                \"_insertElements\",\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            \"_insertElements\",\n            0,\n            arguments.length\n        ]);\n    }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = \"left\";\n        end = \"right\";\n    } else {\n        reverse = properties.base < properties.y;\n        start = \"bottom\";\n        end = \"top\";\n    }\n    if (reverse) {\n        top = \"end\";\n        bottom = \"start\";\n    } else {\n        top = \"start\";\n        bottom = \"end\";\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start, end, reverse, top, bottom } = borderProps(properties);\n    if (edge === \"middle\" && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount }, ratio) {\n    properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseObjectData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const iAxisKey = iScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n            parsed.push(parseValue((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n    getMaxOverflow() {\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale, vScale } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? \"[\" + custom.start + \", \" + custom.end + \"]\" : \"\" + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: \"\" + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { index, _cachedMeta: { vScale } } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? \"active\" : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n    _getStacks(last, dataIndex) {\n        const { iScale } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const skipNull = (meta)=>{\n            const parsed = meta.controller.getParsed(dataIndex);\n            const val = parsed && parsed[meta.vScale.axis];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n    _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n    _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n    _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n    _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n        let center, size;\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === \"flex\" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\nBarController.id = \"bar\";\nBarController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"bar\",\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"base\",\n                \"width\",\n                \"height\"\n            ]\n        }\n    }\n};\nBarController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\",\n            offset: true,\n            grid: {\n                offset: true\n            }\n        },\n        _value_: {\n            type: \"linear\",\n            beginAtZero: true\n        }\n    }\n};\nclass BubbleController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: meta.label,\n            value: \"(\" + x + \", \" + y + (r ? \", \" + r : \"\") + \")\"\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n    resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== \"active\") {\n            values.radius = 0;\n        }\n        values.radius += (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n        return values;\n    }\n}\nBubbleController.id = \"bubble\";\nBubbleController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"borderWidth\",\n                \"radius\"\n            ]\n        }\n    }\n};\nBubbleController.overrides = {\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                }\n            }\n        }\n    }\n};\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        const minX = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n        const minY = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n    parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                const { key = \"value\" } = this._parsing;\n                getter = (i)=>+(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n    _getRotation() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n    }\n    _getCircumference() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n    }\n    _getRotationExtents() {\n        let min = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n        let max = -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n    update(mode) {\n        const chart = this.chart;\n        const { chartArea } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference, rotation } = this._getRotationExtents();\n        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? \"active\" : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== \"inner\") {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n    _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n    _getRingWeight(datasetIndex) {\n        return Math.max((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\nDoughnutController.id = \"doughnut\";\nDoughnutController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: false\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"circumference\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\",\n                \"startAngle\",\n                \"x\",\n                \"y\",\n                \"offset\",\n                \"borderWidth\",\n                \"spacing\"\n            ]\n        }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n};\nDoughnutController.descriptors = {\n    _scriptable: (name)=>name !== \"spacing\",\n    _indexable: (name)=>name !== \"spacing\"\n};\nDoughnutController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        },\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (tooltipItem) {\n                    let dataLabel = tooltipItem.label;\n                    const value = \": \" + tooltipItem.formattedValue;\n                    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(dataLabel)) {\n                        dataLabel = dataLabel.slice();\n                        dataLabel[0] += value;\n                    } else {\n                        dataLabel += value;\n                    }\n                    return dataLabel;\n                }\n            }\n        }\n    }\n};\nclass LineController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line, data: points = [], _dataset } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\nLineController.id = \"line\";\nLineController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: true,\n    spanGaps: false\n};\nLineController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\"\n        },\n        _value_: {\n            type: \"linear\"\n        }\n    }\n};\nclass PolarAreaController extends DatasetController {\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n    _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? \"active\" : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n    _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\nPolarAreaController.id = \"polarArea\";\nPolarAreaController.defaults = {\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: true\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"startAngle\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\"\n            ]\n        }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n};\nPolarAreaController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        },\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (context) {\n                    return context.chart.data.labels[context.dataIndex] + \": \" + context.formattedValue;\n                }\n            }\n        }\n    },\n    scales: {\n        r: {\n            type: \"radialLinear\",\n            angleLines: {\n                display: false\n            },\n            beginAtZero: true,\n            grid: {\n                circular: true\n            },\n            pointLabels: {\n                display: false\n            },\n            startAngle: 0\n        }\n    }\n};\nclass PieController extends DoughnutController {\n}\nPieController.id = \"pie\";\nPieController.defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n};\nclass RadarController extends DatasetController {\n    getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: \"\" + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== \"resize\") {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === \"reset\";\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\nRadarController.id = \"radar\";\nRadarController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: true,\n    elements: {\n        line: {\n            fill: \"start\"\n        }\n    }\n};\nRadarController.overrides = {\n    aspectRatio: 1,\n    scales: {\n        r: {\n            type: \"radialLinear\"\n        }\n    }\n};\nclass Element {\n    constructor(){\n        this.x = undefined;\n        this.y = undefined;\n        this.active = false;\n        this.options = undefined;\n        this.$animations = undefined;\n    }\n    tooltipPosition(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\nconst formatters = {\n    values (value) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(value) ? value : \"\" + value;\n    },\n    numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = \"scientific\";\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(Math.abs(delta));\n        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(tickValue, locale, options);\n    },\n    logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const remain = tickValue / Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickValue)));\n        if (remain === 1 || remain === 2 || remain === 5) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return \"\";\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\nvar Ticks = {\n    formatters\n};\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"scale\", {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n    bounds: \"ticks\",\n    grace: 0,\n    grid: {\n        display: true,\n        lineWidth: 1,\n        drawBorder: true,\n        drawOnChartArea: true,\n        drawTicks: true,\n        tickLength: 8,\n        tickWidth: (_ctx, options)=>options.lineWidth,\n        tickColor: (_ctx, options)=>options.color,\n        offset: false,\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderWidth: 1\n    },\n    title: {\n        display: false,\n        text: \"\",\n        padding: {\n            top: 4,\n            bottom: 4\n        }\n    },\n    ticks: {\n        minRotation: 0,\n        maxRotation: 50,\n        mirror: false,\n        textStrokeWidth: 0,\n        textStrokeColor: \"\",\n        padding: 3,\n        display: true,\n        autoSkip: true,\n        autoSkipPadding: 3,\n        labelOffset: 0,\n        callback: Ticks.formatters.values,\n        minor: {},\n        major: {},\n        align: \"center\",\n        crossAlign: \"near\",\n        showLabelBackdrop: false,\n        backdropColor: \"rgba(255, 255, 255, 0.75)\",\n        backdropPadding: 2\n    }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.ticks\", \"color\", \"\", \"color\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.title\", \"color\", \"\", \"color\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scale\", {\n    _fallback: false,\n    _scriptable: (name)=>!name.startsWith(\"before\") && !name.startsWith(\"after\") && name !== \"callback\" && name !== \"parser\",\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"tickBorderDash\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scales\", {\n    _fallback: \"scale\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scale.ticks\", {\n    _scriptable: (name)=>name !== \"backdropPadding\" && name !== \"callback\",\n    _indexable: (name)=>name !== \"backdropPadding\"\n});\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.A)(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n    const end = Math.min((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\nfunction getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\nconst reverseAlign = (align)=>align === \"left\" ? \"right\" : align === \"right\" ? \"left\" : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === \"top\" || edge === \"left\" ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\nfunction garbageCollect(caches, length) {\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\nfunction getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.font, fallback);\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    const lines = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        scale,\n        type: \"scale\"\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        tick,\n        index,\n        type: \"tick\"\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(align);\n    if (reverse && position !== \"right\" || !reverse && position === \"right\") {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top, left, bottom, right, chart } = scale;\n    const { chartArea, scales } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, left, right);\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === \"center\") {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === \"center\") {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, bottom, top);\n        rotation = position === \"left\" ? -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n        this.id = cfg.id;\n        this.type = cfg.type;\n        this.options = undefined;\n        this.ctx = cfg.ctx;\n        this.chart = cfg.chart;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n        this.maxWidth = undefined;\n        this.maxHeight = undefined;\n        this.paddingTop = undefined;\n        this.paddingBottom = undefined;\n        this.paddingLeft = undefined;\n        this.paddingRight = undefined;\n        this.axis = undefined;\n        this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n        this.ticks = [];\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n        this._startPixel = undefined;\n        this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n    init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n    parse(raw, index) {\n        return raw;\n    }\n    getUserBounds() {\n        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;\n        _userMin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMin, _suggestedMin),\n            max: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMax, _suggestedMax),\n            minDefined: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n            maxDefined: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n        };\n    }\n    getMinMax(canStack) {\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(min, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(max, min)),\n            max: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(max, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(min, max))\n        };\n    }\n    getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n    getTicks() {\n        return this.ticks;\n    }\n    getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n    update(maxWidth, maxHeight, margins) {\n        const { beginAtZero, grace, ticks: tickOpts } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.D)(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === \"auto\")) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n    configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks(\"beforeDataLimits\");\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks(\"afterDataLimits\");\n    }\n    beforeBuildTicks() {\n        this._callHooks(\"beforeBuildTicks\");\n    }\n    buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks(\"afterBuildTicks\");\n    }\n    beforeTickToLabelConversion() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n    generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = this.ticks.length;\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)(Math.min(Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first, last, widest, highest } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align, padding }, position } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== \"top\" && this.axis === \"x\";\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === \"start\") {\n                paddingRight = last.width;\n            } else if (align === \"end\") {\n                paddingLeft = first.width;\n            } else if (align !== \"inner\") {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === \"start\") {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === \"end\") {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n    _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterFit, [\n            this\n        ]);\n    }\n    isHorizontal() {\n        const { axis, position } = this.options;\n        return position === \"top\" || position === \"bottom\" || axis === \"x\";\n    }\n    isFullSize() {\n        return this.options.fullSize;\n    }\n    _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n        }\n        return labelSizes;\n    }\n    _computeLabelSizes(ticks, length) {\n        const { ctx, _longestTextCache: caches } = this;\n        const widths = [];\n        const heights = [];\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; ++i){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                width = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G)(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n                        width = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G)(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n    getLabelForValue(value) {\n        return value;\n    }\n    getPixelForValue(value, index) {\n        return NaN;\n    }\n    getValueForPixel(pixel) {}\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.I)(this._alignToPixels ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(this.chart, pixel, 0) : pixel);\n    }\n    getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n    getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n        const { min, max } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n    getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n    _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n    _isVisible() {\n        const display = this.options.display;\n        if (display !== \"auto\") {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid, position } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = grid.setContext(this.getContext());\n        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === \"top\") {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === \"bottom\") {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === \"left\") {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === \"right\") {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const optsAtIndex = grid.setContext(this.getContext(i));\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndex.borderDash || [];\n            const borderDashOffset = optsAtIndex.borderDashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n    _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position, ticks: optionTicks } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align, crossAlign, padding, mirror } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = \"middle\";\n        if (position === \"top\") {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"bottom\") {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"left\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === \"right\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === \"y\") {\n            if (align === \"start\") {\n                textBaseline = \"top\";\n            } else if (align === \"end\") {\n                textBaseline = \"bottom\";\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === \"inner\") {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? \"right\" : \"left\";\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? \"left\" : \"right\";\n                    } else {\n                        tickTextAlign = \"center\";\n                    }\n                }\n                if (position === \"top\") {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = y + textOffset - labelPadding.top;\n                let left = x - labelPadding.left;\n                switch(textBaseline){\n                    case \"middle\":\n                        top -= height / 2;\n                        break;\n                    case \"bottom\":\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case \"center\":\n                        left -= width / 2;\n                        break;\n                    case \"right\":\n                        left -= width;\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                rotation,\n                label,\n                font,\n                color,\n                strokeColor,\n                strokeWidth,\n                textOffset,\n                textAlign: tickTextAlign,\n                textBaseline,\n                translation: [\n                    x,\n                    y\n                ],\n                backdrop\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position, ticks } = this.options;\n        const rotation = -(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        if (rotation) {\n            return position === \"top\" ? \"left\" : \"right\";\n        }\n        let align = \"center\";\n        if (ticks.align === \"start\") {\n            align = \"left\";\n        } else if (ticks.align === \"end\") {\n            align = \"right\";\n        } else if (ticks.align === \"inner\") {\n            align = \"inner\";\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position, ticks: { crossAlign, mirror, padding } } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === \"left\") {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x = this.left;\n                }\n            }\n        } else if (position === \"right\") {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = \"right\";\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n    _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === \"left\" || position === \"right\") {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === \"top\" || position === \"bottom\") {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n    drawBackground() {\n        const { ctx, options: { backgroundColor }, left, top, width, height } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n    drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n    drawBorder() {\n        const { chart, ctx, options: { grid } } = this;\n        const borderOpts = grid.setContext(this.getContext());\n        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.borderWidth;\n        ctx.strokeStyle = borderOpts.borderColor;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, area);\n        }\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        let i, ilen;\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            const item = items[i];\n            const tickFont = item.font;\n            const label = item.label;\n            if (item.backdrop) {\n                ctx.fillStyle = item.backdrop.color;\n                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n            }\n            let y = item.textOffset;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, label, 0, y, tickFont, item);\n        }\n        if (area) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n    }\n    drawTitle() {\n        const { ctx, options: { position, title, reverse } } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(title.font);\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === \"bottom\" || position === \"center\" || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            offset += padding.bottom;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n    _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: gz + 1,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n    getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + \"AxisID\";\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n    }\n    _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n    register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + \".\" + id;\n        if (!id) {\n            throw new Error(\"class does not have id: \" + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n    get(id) {\n        return this.items[id];\n    }\n    unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n            delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n            if (this.override) {\n                delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.V)(Object.create(null), [\n        parentScope ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n        item.defaults\n    ]);\n    _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split(\".\");\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join(\".\");\n        const parts = routes[property].split(\".\");\n        const targetName = parts.pop();\n        const targetScope = parts.join(\".\");\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return \"id\" in proto && \"defaults\" in proto;\n}\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, \"datasets\", true);\n        this.elements = new TypedRegistry(Element, \"elements\");\n        this.plugins = new TypedRegistry(Object, \"plugins\");\n        this.scales = new TypedRegistry(Scale, \"scales\");\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n    add(...args) {\n        this._each(\"register\", args);\n    }\n    remove(...args) {\n        this._each(\"unregister\", args);\n    }\n    addControllers(...args) {\n        this._each(\"register\", args, this.controllers);\n    }\n    addElements(...args) {\n        this._each(\"register\", args, this.elements);\n    }\n    addPlugins(...args) {\n        this._each(\"register\", args, this.plugins);\n    }\n    addScales(...args) {\n        this._each(\"register\", args, this.scales);\n    }\n    getController(id) {\n        return this._get(id, this.controllers, \"controller\");\n    }\n    getElement(id) {\n        return this._get(id, this.elements, \"element\");\n    }\n    getPlugin(id) {\n        return this._get(id, this.plugins, \"plugin\");\n    }\n    getScale(id) {\n        return this._get(id, this.scales, \"scale\");\n    }\n    removeControllers(...args) {\n        this._each(\"unregister\", args, this.controllers);\n    }\n    removeElements(...args) {\n        this._each(\"unregister\", args, this.elements);\n    }\n    removePlugins(...args) {\n        this._each(\"unregister\", args, this.plugins);\n    }\n    removeScales(...args) {\n        this._each(\"unregister\", args, this.scales);\n    }\n    _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n    _exec(method, registry, component) {\n        const camelMethod = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.W)(method);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(component[\"before\" + camelMethod], [], component);\n        registry[method](component);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(component[\"after\" + camelMethod], [], component);\n    }\n    _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n    _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + \".\");\n        }\n        return item;\n    }\n}\nvar registry = new Registry();\nclass ScatterController extends DatasetController {\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = [] } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            const { dataset: line, _dataset } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = registry.getElement(\"line\");\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\nScatterController.id = \"scatter\";\nScatterController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    showLine: false,\n    fill: false\n};\nScatterController.overrides = {\n    interaction: {\n        mode: \"point\"\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (item) {\n                    return \"(\" + item.label + \", \" + item.formattedValue + \")\";\n                }\n            }\n        }\n    },\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    }\n};\nvar controllers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BarController: BarController,\n    BubbleController: BubbleController,\n    DoughnutController: DoughnutController,\n    LineController: LineController,\n    PolarAreaController: PolarAreaController,\n    PieController: PieController,\n    RadarController: RadarController,\n    ScatterController: ScatterController\n});\nfunction abstract() {\n    throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nclass DateAdapter {\n    constructor(options){\n        this.options = options || {};\n    }\n    init(chartOptions) {}\n    formats() {\n        return abstract();\n    }\n    parse(value, format) {\n        return abstract();\n    }\n    format(timestamp, format) {\n        return abstract();\n    }\n    add(timestamp, amount, unit) {\n        return abstract();\n    }\n    diff(a, b, unit) {\n        return abstract();\n    }\n    startOf(timestamp, unit, weekday) {\n        return abstract();\n    }\n    endOf(timestamp, unit) {\n        return abstract();\n    }\n}\nDateAdapter.override = function(members) {\n    Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n    _date: DateAdapter\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller, data, _sorted } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    if (iScale && axis === iScale.axis && axis !== \"r\" && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Y : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z;\n        if (!intersect) {\n            return lookupMethod(data, axis, value);\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === \"function\" && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index, data } = metasets[i];\n        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\nfunction getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf(\"x\") !== -1;\n    const useY = axis.indexOf(\"y\") !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle, endAngle } = element.getProps([\n            \"startAngle\",\n            \"endAngle\"\n        ], useFinalPosition);\n        const { angle } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0)(element, {\n            x: position.x,\n            y: position.y\n        });\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === \"r\" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === \"x\" ? \"inXRange\" : \"inYRange\";\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\nvar Interaction = {\n    evaluateInteractionItems,\n    modes: {\n        index (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"x\";\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n        dataset (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n        point (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n        nearest (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n        x (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            return getAxisItems(chart, position, \"x\", options.intersect, useFinalPosition);\n        },\n        y (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            return getAxisItems(chart, position, \"y\", options.intersect, useFinalPosition);\n        }\n    }\n};\nconst STATIC_POSITIONS = [\n    \"left\",\n    \"top\",\n    \"right\",\n    \"bottom\"\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos, options: { stack, stackWeight = 1 } } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack, pos, stackWeight } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth, hBoxMaxHeight } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, \"left\"), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, \"right\"));\n    const top = sortByWeight(filterByPosition(layoutBoxes, \"top\"), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, \"bottom\"));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, \"x\");\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, \"y\");\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, \"chartArea\"),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos, box } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, \"left\", \"right\"));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, \"top\", \"bottom\"));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos(\"top\");\n    chartArea.x += updatePos(\"left\");\n    updatePos(\"right\");\n    updatePos(\"bottom\");\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        \"left\",\n        \"right\"\n    ]) : marginForPositions([\n        \"top\",\n        \"bottom\"\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same, other } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x, y } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"layout\", {\n    autoPadding: true,\n    padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    }\n});\nvar layouts = {\n    addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || \"top\";\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n    removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n    configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n    update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === \"function\") {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\nclass BasePlatform {\n    acquireContext(canvas, aspectRatio) {}\n    releaseContext(context) {\n        return false;\n    }\n    addEventListener(chart, type, listener) {}\n    removeEventListener(chart, type, listener) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n    isAttached(canvas) {\n        return true;\n    }\n    updateConfig(config) {}\n}\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext(\"2d\") || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\nconst EXPANDO_KEY = \"$chartjs\";\nconst EVENT_TYPES = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n};\nconst isNullOrEmpty = (value)=>value === null || value === \"\";\nfunction initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute(\"height\");\n    const renderWidth = canvas.getAttribute(\"width\");\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || \"block\";\n    style.boxSizing = style.boxSizing || \"border-box\";\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3)(canvas, \"width\");\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === \"\") {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3)(canvas, \"height\");\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a5 ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x, y } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener(\"resize\", onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener(\"resize\", onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2)(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4)((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === \"resize\") {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4)((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart, (args)=>{\n        const event = args[0];\n        return [\n            event,\n            event.offsetX,\n            event.offsetY\n        ];\n    });\n    addListener(canvas, type, proxy);\n    return proxy;\n}\nclass DomPlatform extends BasePlatform {\n    acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext(\"2d\");\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n    releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            \"height\",\n            \"width\"\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n    addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n    removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getMaximumSize(canvas, width, height, aspectRatio) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a1)(canvas, width, height, aspectRatio);\n    }\n    isAttached(canvas) {\n        const container = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2)(canvas);\n        return !!(container && container.isConnected);\n    }\n}\nfunction _detectPlatform(canvas) {\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6)() || typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n    notify(chart, hook, args, filter) {\n        if (hook === \"beforeInit\") {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, \"install\");\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === \"afterDestroy\") {\n            this._notify(descriptors, chart, \"stop\");\n            this._notify(this._init, chart, \"uninstall\");\n        }\n        return result;\n    }\n    _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n    _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n    _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, \"stop\");\n        this._notify(diff(descriptors, previousDescriptors), chart, \"start\");\n    }\n}\nfunction allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins, localIds }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin, local }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        \"\"\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || \"x\";\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === \"_index_\") {\n        axis = indexAxis;\n    } else if (id === \"_value_\") {\n        axis = indexAxis === \"x\" ? \"y\" : \"x\";\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? \"_index_\" : \"_value_\";\n}\nfunction axisFromPosition(position) {\n    if (position === \"top\" || position === \"bottom\") {\n        return \"x\";\n    }\n    if (position === \"left\" || position === \"right\") {\n        return \"y\";\n    }\n}\nfunction determineAxis(id, scaleOptions) {\n    if (id === \"x\" || id === \"y\") {\n        return id;\n    }\n    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const firstIDs = Object.create(null);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        firstIDs[axis] = firstIDs[axis] || id;\n        scales[id] = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + \"AxisID\"] || firstIDs[axis] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(scale, [\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n    datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n    _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n    getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options, type } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a7, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n    chartOptionScopes() {\n        const { options, type } = this;\n        return [\n            options,\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {},\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n            {\n                type\n            },\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d,\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a7\n        ];\n    }\n    resolveNamedOptions(scopes, names, context, prefixes = [\n        \"\"\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9)(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n    createResolver(scopes, context, prefixes = [\n        \"\"\n    ], descriptorDefaults) {\n        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9)(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aa)(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes(\"hover\"))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).reduce((acc, key)=>acc || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(value[key]), false);\nfunction needContext(proxy, names) {\n    const { isScriptable, isIndexable } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ab)(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar version = \"3.9.1\";\nconst KNOWN_POSITIONS = [\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"chartArea\"\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === \"top\" || position === \"bottom\" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === \"x\";\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins(\"afterRender\");\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\nfunction getCanvas(item) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6)() && typeof item === \"string\") {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === \"mouseout\") {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error(\"Canvas is already in use. Chart with ID '\" + existingChart.id + \"'\" + \" must be destroyed before the canvas with ID '\" + existingChart.canvas.id + \"' can be reused.\");\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ad)();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n        this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ae)((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, \"complete\", onAnimationsComplete);\n        animator.listen(this, \"progress\", onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    _initialize() {\n        this.notifyPlugins(\"beforeInit\");\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af)(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins(\"afterInit\");\n        return this;\n    }\n    clear() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag)(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n    resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? \"resize\" : \"attach\";\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af)(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins(\"resize\", {\n            size: newSize\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n    buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === \"r\";\n                const isHorizontal = axis === \"x\";\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? \"chartArea\" : isHorizontal ? \"bottom\" : \"left\",\n                    dtype: isRadial ? \"radialLinear\" : isHorizontal ? \"category\" : \"linear\"\n                };\n            }));\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n    _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level(\"order\", \"index\"));\n    }\n    _removeUnreferencedMetasets() {\n        const { _metasets: metasets, data: { datasets } } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = \"\" + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType, dataElementType } = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n                Object.assign(ControllerClass.prototype, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n    _resetElements() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n    reset() {\n        this._resetElements();\n        this.notifyPlugins(\"reset\");\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins(\"beforeUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins(\"beforeElementsUpdate\");\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins(\"afterUpdate\", {\n            mode\n        });\n        this._layers.sort(compare2Level(\"z\", \"_idx\"));\n        const { _active, _lastEvent } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n    _updateScales() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n    _updateHiddenIndices() {\n        const { _hiddenIndices } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method, start, count } of changes){\n            const move = method === \"_removeElements\" ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n    _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + \",\" + c.splice(1).join(\",\")));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah)(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(\",\")).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n    _updateLayout(minPadding) {\n        if (this.notifyPlugins(\"beforeLayout\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.boxes, (box)=>{\n            if (noArea && box.position === \"chartArea\") {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins(\"afterLayout\");\n    }\n    _updateDatasets(mode) {\n        if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n            mode\n        });\n    }\n    _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetUpdate\", args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetUpdate\", args);\n    }\n    render() {\n        if (this.notifyPlugins(\"beforeRender\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width, height } = this._resizeBeforeDraw;\n            this._resize(width, height);\n            this._resizeBeforeDraw = null;\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins(\"beforeDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins(\"afterDraw\");\n    }\n    _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n    _drawDatasets() {\n        if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n    _drawDataset(meta) {\n        const ctx = this.ctx;\n        const clip = meta._clip;\n        const useClip = !clip.disabled;\n        const area = this.chartArea;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetDraw\", args) === false) {\n            return;\n        }\n        if (useClip) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, {\n                left: clip.left === false ? 0 : area.left - clip.left,\n                right: clip.right === false ? this.width : area.right + clip.right,\n                top: clip.top === false ? 0 : area.top - clip.top,\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n            });\n        }\n        meta.controller.draw();\n        if (useClip) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetDraw\", args);\n    }\n    isPointInArea(point) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === \"function\") {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(null, {\n            chart: this,\n            type: \"chart\"\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === \"boolean\" ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n    _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? \"show\" : \"hide\";\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n    _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins(\"beforeDestroy\");\n        const { canvas, ctx } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag)(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        this.notifyPlugins(\"destroy\");\n        delete instances[this.id];\n        this.notifyPlugins(\"afterDestroy\");\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n    bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n    bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.events, (type)=>_add(type, listener));\n    }\n    bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove(\"attach\", attached);\n            this.attached = true;\n            this.resize();\n            _add(\"resize\", listener);\n            _add(\"detach\", detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove(\"resize\", listener);\n            this._stop();\n            this._resize(0, 0);\n            _add(\"attach\", attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n    unbindEvents() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? \"set\" : \"remove\";\n        let meta, item, i, ilen;\n        if (mode === \"dataset\") {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller[\"_\" + prefix + \"DatasetHoverStyle\"]();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + \"HoverStyle\"](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"No dataset found at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n    notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n    _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n    _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins(\"beforeEvent\", args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterEvent\", args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n    _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [], options } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aj)(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nconst invalidatePlugins = ()=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(Chart.instances, (chart)=>chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n    defaults: {\n        enumerable,\n        value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d\n    },\n    instances: {\n        enumerable,\n        value: instances\n    },\n    overrides: {\n        enumerable,\n        value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U\n    },\n    registry: {\n        enumerable,\n        value: registry\n    },\n    version: {\n        enumerable,\n        value: version\n    },\n    getChart: {\n        enumerable,\n        value: getChart\n    },\n    register: {\n        enumerable,\n        value: (...items)=>{\n            registry.add(...items);\n            invalidatePlugins();\n        }\n    },\n    unregister: {\n        enumerable,\n        value: (...items)=>{\n            registry.remove(...items);\n            invalidatePlugins();\n        }\n    }\n});\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.al)(value, [\n        \"outerStart\",\n        \"outerEnd\",\n        \"innerStart\",\n        \"innerEnd\"\n    ]);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(o.innerStart, 0, innerLimit),\n        innerEnd: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(o.innerEnd, 0, innerLimit)\n    };\n}\nfunction rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n        }\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n            if (circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T === 0) {\n                endAngle += _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n            }\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n    const { x, y, startAngle, pixelMargin, fullCircles } = element;\n    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n    const innerRadius = element.innerRadius + pixelMargin;\n    let i;\n    if (inner) {\n        clipArc(ctx, element, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, innerRadius, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T, startAngle, true);\n    for(i = 0; i < fullCircles; ++i){\n        ctx.stroke();\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    for(i = 0; i < fullCircles; ++i){\n        ctx.stroke();\n    }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n    const { options } = element;\n    const { borderWidth, borderJoinStyle } = options;\n    const inner = options.borderAlign === \"inner\";\n    if (!borderWidth) {\n        return;\n    }\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || \"round\";\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || \"bevel\";\n    }\n    if (element.fullCircles) {\n        drawFullCircleBorders(ctx, element, inner);\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n}\nclass ArcElement extends Element {\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        const { angle, distance } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0)(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const rAdjust = this.options.spacing / 2;\n        const _circumference = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n        const betweenAngles = _circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle);\n        const withinRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([\n            \"x\",\n            \"y\",\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const { offset, spacing } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options, circumference } = this;\n        const offset = (options.offset || 0) / 2;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === \"inner\" ? 0.33 : 0;\n        this.fullCircles = circumference > _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        let radiusOffset = 0;\n        if (offset) {\n            radiusOffset = offset / 2;\n            const halfAngle = (this.startAngle + this.endAngle) / 2;\n            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n            if (this.circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P) {\n                radiusOffset = offset;\n            }\n        }\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n        ctx.restore();\n    }\n}\nArcElement.id = \"arc\";\nArcElement.defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true\n};\nArcElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n};\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.as;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.at;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;\n    const { start: segmentStart, end: segmentEnd } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\nfunction pathSegment(ctx, line, segment, params) {\n    const { points, options } = line;\n    const { count, start, loop, ilen } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move = true, reverse } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count, start, ilen } = pathVars(points, segment, params);\n    const { move = true, reverse } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\nfunction _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== \"monotone\" && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ap;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aq;\n    }\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ar;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments, options } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === \"function\";\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === \"monotone\") && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.am)(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.an)(this, this.options.segment));\n    }\n    first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n    last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n    interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao)(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start, end } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n    path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n    draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\nLineElement.id = \"line\";\nLineElement.defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: \"default\",\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0\n};\nLineElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nLineElement.descriptors = {\n    _scriptable: true,\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"fill\"\n};\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, \"x\", useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, \"y\", useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        return options.radius + options.hitRadius;\n    }\n}\nPointElement.id = \"point\";\nPointElement.defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n};\nPointElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x, y, base, width, height } = bar.getProps([\n        \"x\",\n        \"y\",\n        \"base\",\n        \"width\",\n        \"height\"\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aw)(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius } = bar.getProps([\n        \"enableBorderRadius\"\n    ]);\n    const value = bar.options.borderRadius;\n    const o = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount, options: { borderColor, backgroundColor } } = this;\n        const { inner, outer } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill(\"evenodd\");\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, base, horizontal } = this.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"horizontal\"\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === \"x\" ? this.width / 2 : this.height / 2;\n    }\n}\nBarElement.id = \"bar\";\nBarElement.defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nvar elements = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ArcElement: ArcElement,\n    LineElement: LineElement,\n    PointElement: PointElement,\n    BarElement: BarElement\n});\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n    const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx, y: pointAy } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, \"data\", {\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale } = meta;\n    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n    if (minDefined) {\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: \"decimation\",\n    defaults: {\n        algorithm: \"min-max\",\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data, indexAxis } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === \"y\") {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== \"linear\" && xAxis.type !== \"time\") {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, \"data\", {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case \"lttb\":\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case \"min-max\":\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start, end } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao)(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ay)(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, \"start\", Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, \"end\", Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === \"angle\") {\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(start);\n        end = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x = null, y = null } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start, end })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\nfunction _decodeFill(line, index, count) {\n    const fill = parseFillOption(line);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        \"origin\",\n        \"start\",\n        \"end\",\n        \"stack\",\n        \"shape\"\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === \"-\" || firstCh === \"+\") {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\nfunction _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === \"start\") {\n        pixel = scale.bottom;\n    } else if (fill === \"end\") {\n        pixel = scale.top;\n    } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === \"start\") {\n        value = startValue;\n    } else if (fill === \"end\") {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\nfunction parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return \"origin\";\n    }\n    return fill;\n}\nfunction _buildStackLine(source) {\n    const { scale, index, line } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\nfunction getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas(\"line\");\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first, last, point } = findPoint(line, sourcePoint, \"x\");\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x, y, radius } = this;\n        bounds = bounds || {\n            start: 0,\n            end: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x, y, radius } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\nfunction _getTarget(source) {\n    const { chart, fill, line } = source;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === \"stack\") {\n        return _buildStackLine(source);\n    }\n    if (fill === \"shape\") {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale = {}, fill } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale, fill } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { line, scale, axis } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above = color, below = color } = fillOption || {};\n    if (target && line.points.length) {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line, target, above, below, area, scale } = cfg;\n    const property = line._loop ? \"angle\" : cfg.axis;\n    ctx.save();\n    if (property === \"x\" && below !== above) {\n        clipVertical(ctx, target, area.top);\n        fill(ctx, {\n            line,\n            target,\n            color: above,\n            scale,\n            property\n        });\n        ctx.restore();\n        ctx.save();\n        clipVertical(ctx, target, area.bottom);\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: below,\n        scale,\n        property\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line, target, property, color, scale } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src, target: tgt, start, end } of segments){\n        const { style: { backgroundColor = color } = {} } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? \"evenodd\" : \"nonzero\");\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, bounds) {\n    const { top, bottom } = scale.chart.chartArea;\n    const { property, start, end } = bounds || {};\n    if (property === \"x\") {\n        ctx.beginPath();\n        ctx.rect(start, top, end - start, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\nvar index = {\n    id: \"filler\",\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === \"beforeDraw\";\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== \"beforeDatasetsDraw\") {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== \"beforeDatasetDraw\") {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: \"beforeDatasetDraw\"\n    }\n};\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n    constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n        this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options, ctx } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxWidth, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = \"left\";\n        ctx.textBaseline = \"middle\";\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxHeight, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, this);\n            this._draw();\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n    }\n    _draw() {\n        const { options: opts, columnSizes, lineWidths, ctx } = this;\n        const { align, labels: labelOpts } = opts;\n        const defaultColor = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.color;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const labelFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.font);\n        const { color: fontColor, padding } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign(\"left\");\n        ctx.textBaseline = \"middle\";\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n            ctx.fillStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, \"butt\");\n            ctx.lineDashOffset = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, \"miter\");\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor || fontColor;\n            ctx.fillStyle = legendItem.fontColor || fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);\n    }\n    drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(position));\n        ctx.textBaseline = \"middle\";\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, titleOpts.text, x, y, titleFont);\n    }\n    _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n    _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n    handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === \"mousemove\" || e.type === \"mouseout\") {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction isListened(type, opts) {\n    if ((type === \"mousemove\" || type === \"mouseout\") && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === \"click\" || type === \"mouseup\")) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: \"legend\",\n    _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: \"top\",\n        align: \"center\",\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle, pointStyle, textAlign, color } } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: 0,\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: \"center\",\n            text: \"\"\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith(\"on\"),\n        labels: {\n            _scriptable: (name)=>![\n                    \"generateLabels\",\n                    \"filter\",\n                    \"sort\"\n                ].includes(name)\n        }\n    }\n};\nclass Title extends Element {\n    constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n        this._padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(opts.padding);\n        const textSize = lineCount * (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === \"top\" || pos === \"bottom\";\n    }\n    _drawArgs(offset) {\n        const { top, left, bottom, right, options } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === \"left\") {\n                titleX = left + offset;\n                titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, bottom, top);\n                rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, top, bottom);\n                rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(opts.align),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: \"title\",\n    _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"bold\"\n        },\n        fullSize: true,\n        padding: 10,\n        position: \"top\",\n        text: \"\",\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: \"subtitle\",\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"normal\"\n        },\n        fullSize: true,\n        padding: 0,\n        position: \"top\",\n        text: \"\",\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst positioners = {\n    average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let x = 0;\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                x += pos.x;\n                y += pos.y;\n                ++count;\n            }\n        }\n        return {\n            x: x / count,\n            y: y / count\n        };\n    },\n    nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aG)(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\nfunction splitNewlines(str) {\n    if ((typeof str === \"string\" || str instanceof String) && str.indexOf(\"\\n\") > -1) {\n        return str.split(\"\\n\");\n    }\n    return str;\n}\nfunction createTooltipItem(chart, item) {\n    const { element, datasetIndex, index } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label, value } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\nfunction getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body, footer, title } = tooltip;\n    const { boxWidth, boxHeight } = options;\n    const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n    const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.titleFont);\n    const footerFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(body, (bodyItem)=>{\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.before, maxLineWidth);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.lines, maxLineWidth);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y, height } = size;\n    if (y < height / 2) {\n        return \"top\";\n    } else if (y > chart.height - height / 2) {\n        return \"bottom\";\n    }\n    return \"center\";\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x, width } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === \"left\" && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === \"right\" && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x, width } = size;\n    const { width: chartWidth, chartArea: { left, right } } = chart;\n    let xAlign = \"center\";\n    if (yAlign === \"center\") {\n        xAlign = x <= (left + right) / 2 ? \"left\" : \"right\";\n    } else if (x <= width / 2) {\n        xAlign = \"left\";\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = \"right\";\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = \"center\";\n    }\n    return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x, width } = size;\n    if (xAlign === \"right\") {\n        x -= width;\n    } else if (xAlign === \"center\") {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y, height } = size;\n    if (yAlign === \"top\") {\n        y += paddingAndSize;\n    } else if (yAlign === \"bottom\") {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize, caretPadding, cornerRadius } = options;\n    const { xAlign, yAlign } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === \"center\") {\n        if (xAlign === \"left\") {\n            x += paddingAndSize;\n        } else if (xAlign === \"right\") {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === \"left\") {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === \"right\") {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(x, 0, chart.width - size.width),\n        y: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    return align === \"center\" ? tooltip.x + tooltip.width / 2 : align === \"right\" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        tooltip,\n        tooltipItems,\n        type: \"tooltip\"\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart || config._chart;\n        this._chart = this.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n    _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks } = options;\n        const beforeTitle = callbacks.beforeTitle.apply(this, [\n            context\n        ]);\n        const title = callbacks.title.apply(this, [\n            context\n        ]);\n        const afterTitle = callbacks.afterTitle.apply(this, [\n            context\n        ]);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [\n            tooltipItems\n        ]));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks } = options;\n        const bodyItems = [];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n            pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [\n            tooltipItems\n        ]));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks } = options;\n        const beforeFooter = callbacks.beforeFooter.apply(this, [\n            tooltipItems\n        ]);\n        const footer = callbacks.footer.apply(this, [\n            tooltipItems\n        ]);\n        const afterFooter = callbacks.afterFooter.apply(this, [\n            tooltipItems\n        ]);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n    _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(scoped.labelColor.call(this, context));\n            labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n            labelTextColors.push(scoped.labelTextColor.call(this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign, yAlign } = this;\n        const { caretSize, cornerRadius } = options;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(cornerRadius);\n        const { x: ptX, y: ptY } = tooltipPoint;\n        const { width, height } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === \"center\") {\n            y2 = ptY + height / 2;\n            if (xAlign === \"left\") {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === \"left\") {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === \"right\") {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === \"top\") {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = \"middle\";\n            titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n    _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColors = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n        const colorX = getAlignedX(this, \"left\", options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.fillStyle = labelColors.backgroundColor;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.setLineDash(labelColors.borderDash || []);\n            ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n            const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(labelColors.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.beginPath();\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body } = this;\n        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = \"middle\";\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== \"right\" ? bodyAlign === \"center\" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = \"middle\";\n            footerFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign, yAlign } = this;\n        const { x, y } = pt;\n        const { width, height } = tooltipSize;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === \"top\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === \"center\" && xAlign === \"right\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === \"bottom\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === \"center\" && xAlign === \"left\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n    _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n    _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"Cannot find a dataset at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n    handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n    _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n    _positionChanged(active, e) {\n        const { caretX, caretY, options } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n    id: \"tooltip\",\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins(\"beforeTooltipDraw\", args) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins(\"afterTooltipDraw\", args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: \"average\",\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        titleColor: \"#fff\",\n        titleFont: {\n            weight: \"bold\"\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: \"left\",\n        bodyColor: \"#fff\",\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: \"left\",\n        footerColor: \"#fff\",\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: \"bold\"\n        },\n        footerAlign: \"left\",\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: \"#fff\",\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: \"rgba(0,0,0,0)\",\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: \"easeOutQuart\"\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"width\",\n                    \"height\",\n                    \"caretX\",\n                    \"caretY\"\n                ]\n            },\n            opacity: {\n                easing: \"linear\",\n                duration: 200\n            }\n        },\n        callbacks: {\n            beforeTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            title (tooltipItems) {\n                if (tooltipItems.length > 0) {\n                    const item = tooltipItems[0];\n                    const labels = item.chart.data.labels;\n                    const labelCount = labels ? labels.length : 0;\n                    if (this && this.options && this.options.mode === \"dataset\") {\n                        return item.dataset.label || \"\";\n                    } else if (item.label) {\n                        return item.label;\n                    } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                        return labels[item.dataIndex];\n                    }\n                }\n                return \"\";\n            },\n            afterTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            label (tooltipItem) {\n                if (this && this.options && this.options.mode === \"dataset\") {\n                    return tooltipItem.label + \": \" + tooltipItem.formattedValue || tooltipItem.formattedValue;\n                }\n                let label = tooltipItem.dataset.label || \"\";\n                if (label) {\n                    label += \": \";\n                }\n                const value = tooltipItem.formattedValue;\n                if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                    label += value;\n                }\n                return label;\n            },\n            labelColor (tooltipItem) {\n                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n                const options = meta.controller.getStyle(tooltipItem.dataIndex);\n                return {\n                    borderColor: options.borderColor,\n                    backgroundColor: options.backgroundColor,\n                    borderWidth: options.borderWidth,\n                    borderDash: options.borderDash,\n                    borderDashOffset: options.borderDashOffset,\n                    borderRadius: 0\n                };\n            },\n            labelTextColor () {\n                return this.options.bodyColor;\n            },\n            labelPointStyle (tooltipItem) {\n                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n                const options = meta.controller.getStyle(tooltipItem.dataIndex);\n                return {\n                    pointStyle: options.pointStyle,\n                    rotation: options.rotation\n                };\n            },\n            afterLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            afterBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            footer: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            afterFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF\n        }\n    },\n    defaultRoutes: {\n        bodyFont: \"font\",\n        footerFont: \"font\",\n        titleFont: \"font\"\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== \"filter\" && name !== \"itemSort\" && name !== \"external\",\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: \"animation\"\n        }\n    },\n    additionalOptionScopes: [\n        \"interaction\"\n    ]\n};\nvar plugins = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Decimation: plugin_decimation,\n    Filler: index,\n    Legend: plugin_legend,\n    SubTitle: plugin_subtitle,\n    Title: plugin_title,\n    Tooltip: plugin_tooltip\n});\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === \"string\") {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index, label } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this.getMinMax(true);\n        if (this.options.bounds === \"ticks\") {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        const labels = this.getLabels();\n        if (value >= 0 && value < labels.length) {\n            return labels[value];\n        }\n        return value;\n    }\n    configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== \"number\") {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\nCategoryScale.id = \"category\";\nCategoryScale.defaults = {\n    ticks: {\n        callback: CategoryScale.prototype.getLabelForValue\n    }\n};\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin, max: rmax } = dataRange;\n    const minDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n    const maxDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n    const countDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === \"ticks\") {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));\n    factor = Math.pow(10, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        ticks.push({\n            value: Math.round((niceMin + j * spacing) * factor) / factor\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {\n    const rad = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * (\"\" + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        if ((typeof raw === \"number\" || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero } = this.options;\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n            const maxSign = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = 1;\n            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n                offset = Math.abs(max * 0.05);\n            }\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit, stepSize } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n    computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\nclass LinearScale extends LinearScaleBase {\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\nLinearScale.id = \"linear\";\nLinearScale.defaults = {\n    ticks: {\n        callback: Ticks.formatters.numeric\n    }\n};\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickVal)));\n    return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n    const endExp = Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(dataRange.max));\n    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n    const ticks = [];\n    let tickVal = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(generationOptions.min, Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(dataRange.min))));\n    let exp = Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickVal));\n    let significand = Math.floor(tickVal / Math.pow(10, exp));\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    do {\n        ticks.push({\n            value: tickVal,\n            major: isMajor(tickVal)\n        });\n        ++significand;\n        if (significand === 10) {\n            significand = 1;\n            ++exp;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n    }while (exp < endExp || exp === endExp && significand < endSignificand);\n    const lastTick = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(generationOptions.max, tickVal);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(tickVal)\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        const exp = (v, m)=>Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(v)) + m);\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(exp(min, -1));\n                setMax(exp(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(exp(max, -1));\n        }\n        if (max <= 0) {\n            setMax(exp(min, +1));\n        }\n        if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n            setMin(exp(min, -1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return value === undefined ? \"0\" : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(start);\n        this._valueRange = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(this.max) - (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\nLogarithmicScale.id = \"logarithmic\";\nLogarithmicScale.defaults = {\n    ticks: {\n        callback: Ticks.formatters.logarithmic,\n        major: {\n            enabled: true\n        }\n    }\n};\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(tickOpts.backdropPadding);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [\n        label\n    ];\n    return {\n        w: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aM)(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\nfunction fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const extra = getTickBackdropHeight(opts) / 2;\n    const outerDistance = scale.drawingArea;\n    const additionalAngle = opts.pointLabels.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(pointLabelPosition.angle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H)));\n        const size = labelSizes[i];\n        const y = yForAngle(pointLabelPosition.y, size.h, angle);\n        const textAlign = getTextAlignForAngle(angle);\n        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n        items.push({\n            x: pointLabelPosition.x,\n            y,\n            textAlign,\n            left,\n            top: y,\n            right: left + size.w,\n            bottom: y + size.h\n        });\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return \"center\";\n    } else if (angle < 180) {\n        return \"left\";\n    }\n    return \"right\";\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === \"right\") {\n        x -= w;\n    } else if (align === \"center\") {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx, options: { pointLabels } } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        const plFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(optsAtIndex.font);\n        const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];\n        const { backdropColor } = optsAtIndex;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n            const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(optsAtIndex.borderRadius);\n            const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n            ctx.fillStyle = backdropColor;\n            const backdropLeft = left - padding.left;\n            const backdropTop = top - padding.top;\n            const backdropWidth = right - left + padding.width;\n            const backdropHeight = bottom - top + padding.height;\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: backdropLeft,\n                    y: backdropTop,\n                    w: backdropWidth,\n                    h: backdropHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n            }\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: \"middle\"\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color, lineWidth } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(gridLineOpts.borderDash);\n    ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        label,\n        index,\n        type: \"pointLabel\"\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    constructor(cfg){\n        super(cfg);\n        this.xCenter = undefined;\n        this.yCenter = undefined;\n        this.drawingArea = undefined;\n        this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(false);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : \"\";\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(index * angleMultiplier + (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left, top, right, bottom } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n    drawBackground() {\n        const { backgroundColor, grid: { circular } } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n    drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines, grid } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const optsAtIndex = grid.setContext(this.getContext(index - 1));\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color, lineWidth } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n    drawBorder() {}\n    drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color\n            });\n        });\n        ctx.restore();\n    }\n    drawTitle() {}\n}\nRadialLinearScale.id = \"radialLinear\";\nRadialLinearScale.defaults = {\n    display: true,\n    animate: true,\n    position: \"chartArea\",\n    angleLines: {\n        display: true,\n        lineWidth: 1,\n        borderDash: [],\n        borderDashOffset: 0.0\n    },\n    grid: {\n        circular: false\n    },\n    startAngle: 0,\n    ticks: {\n        showLabelBackdrop: true,\n        callback: Ticks.formatters.numeric\n    },\n    pointLabels: {\n        backdropColor: undefined,\n        backdropPadding: 2,\n        display: true,\n        font: {\n            size: 10\n        },\n        callback (label) {\n            return label;\n        },\n        padding: 5,\n        centerPointLabels: false\n    }\n};\nRadialLinearScale.defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n};\nRadialLinearScale.descriptors = {\n    angleLines: {\n        _fallback: \"grid\"\n    }\n};\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction sorter(a, b) {\n    return a - b;\n}\nfunction parse(scale, input) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser, round, isoWeekday } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === \"function\") {\n        value = parser(value);\n    }\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        value = typeof parser === \"string\" ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === \"week\" && ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, \"isoWeek\", isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\nfunction addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aO)(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n    const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    constructor(props){\n        super(props);\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n        this._unit = \"day\";\n        this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n    parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || \"day\";\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== \"ticks\" || options.ticks.source !== \"labels\") {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n    _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n    buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === \"ticks\" && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aN)(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === \"year\" ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n    initOffsets(timestamps) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(start, 0, limit);\n        end = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n    _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(timeOpts.stepSize, 1);\n        const weekday = minor === \"week\" ? timeOpts.isoWeekday : false;\n        const hasWeekday = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, \"isoWeek\", weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? \"day\" : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + \" and \" + max + \" are too far apart with stepSize of \" + stepSize + \" \" + minor);\n        }\n        const timestamps = options.ticks.source === \"data\" && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === \"ticks\" || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort((a, b)=>a - b).map((x)=>+x);\n    }\n    getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n    _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n        const formatter = options.ticks.callback;\n        return formatter ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(formatter, [\n            label,\n            index,\n            ticks\n        ], this) : label;\n    }\n    generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n    getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n    _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n    _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n    getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n    getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n    normalize(values) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n    }\n}\nTimeScale.id = \"time\";\nTimeScale.defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n        parser: false,\n        unit: false,\n        round: false,\n        isoWeekday: false,\n        minUnit: \"millisecond\",\n        displayFormats: {}\n    },\n    ticks: {\n        source: \"auto\",\n        major: {\n            enabled: false\n        }\n    }\n};\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(table, \"pos\", val));\n        }\n        ({ pos: prevSource, time: prevTarget } = table[lo]);\n        ({ pos: nextSource, time: nextTarget } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(table, \"time\", val));\n        }\n        ({ time: prevSource, pos: prevTarget } = table[lo]);\n        ({ time: nextSource, pos: nextTarget } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    constructor(props){\n        super(props);\n        this._table = [];\n        this._minPos = undefined;\n        this._tableRange = undefined;\n    }\n    initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n    buildLookupTable(timestamps) {\n        const { min, max } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n    getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\nTimeSeriesScale.id = \"timeseries\";\nTimeSeriesScale.defaults = TimeScale.defaults;\nvar scales = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    CategoryScale: CategoryScale,\n    LinearScale: LinearScale,\n    LogarithmicScale: LogarithmicScale,\n    RadialLinearScale: RadialLinearScale,\n    TimeScale: TimeScale,\n    TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNva0U7QUFDeGdFO0FBRTdELE1BQU1rTjtJQUNKQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUM7UUFDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdDO0lBQ25CO0lBQ0FDLFFBQVFDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUNoQyxNQUFNQyxZQUFZSCxNQUFNSSxTQUFTLENBQUNGLEtBQUs7UUFDdkMsTUFBTUcsV0FBV0wsTUFBTU0sUUFBUTtRQUMvQkgsVUFBVUksT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHO2dCQUN6QlQ7Z0JBQ0FVLFNBQVNULE1BQU1TLE9BQU87Z0JBQ3RCSjtnQkFDQUssYUFBYUMsS0FBS0MsR0FBRyxDQUFDWCxPQUFPRCxNQUFNYSxLQUFLLEVBQUVSO1lBQzVDO0lBQ0Y7SUFDQVMsV0FBVztRQUNULElBQUksSUFBSSxDQUFDdEIsUUFBUSxFQUFFO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNILFFBQVEsR0FBR25OLDBEQUFnQkEsQ0FBQzBPLElBQUksQ0FBQ0MsUUFBUTtZQUM1QyxJQUFJLENBQUNDLE9BQU87WUFDWixJQUFJLENBQUN6QixRQUFRLEdBQUc7WUFDaEIsSUFBSSxJQUFJLENBQUNHLFFBQVEsRUFBRTtnQkFDakIsSUFBSSxDQUFDbUIsUUFBUTtZQUNmO1FBQ0Y7SUFDRjtJQUNBRyxRQUFRaEIsT0FBT2lCLEtBQUtDLEdBQUcsRUFBRSxFQUFFO1FBQ3pCLElBQUlDLFlBQVk7UUFDaEIsSUFBSSxD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RCxhQUFhLElBQUksQ0FBQ3ZnRCxNQUFNLENBQUM1TyxHQUFHLEdBQUdtdkQ7UUFDL0IsT0FBT0E7SUFDVDtJQUNBbUIsbUJBQW1CMXdELEtBQUssRUFBRTtRQUN4QixPQUFPLENBQUNneEMsWUFBWSxJQUFJLENBQUNvaEIsTUFBTSxFQUFFcHlELFNBQVMsSUFBSSxDQUFDcXlELE9BQU8sSUFBSSxJQUFJLENBQUNDLFdBQVc7SUFDNUU7SUFDQWhvQyxpQkFBaUJDLEtBQUssRUFBRTtRQUN0QixNQUFNNG1DLFVBQVUsSUFBSSxDQUFDckIsUUFBUTtRQUM3QixNQUFNdGxDLFVBQVUsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ0YsU0FBUzRtQyxRQUFROTFELE1BQU0sR0FBRzgxRCxRQUFRendELEdBQUc7UUFDN0UsT0FBT3N3QyxZQUFZLElBQUksQ0FBQ29oQixNQUFNLEVBQUU1bkMsVUFBVSxJQUFJLENBQUM4bkMsV0FBVyxHQUFHLElBQUksQ0FBQ0QsT0FBTyxFQUFFO0lBQzdFO0FBQ0Y7QUFDQUYsZ0JBQWdCeHZELEVBQUUsR0FBRztBQUNyQnd2RCxnQkFBZ0IxbkUsUUFBUSxHQUFHa2xFLFVBQVVsbEUsUUFBUTtBQUU3QyxJQUFJK1osU0FBUyxXQUFXLEdBQUUzRyxPQUFPeU8sTUFBTSxDQUFDO0lBQ3hDNmxCLFdBQVc7SUFDWHExQixlQUFlQTtJQUNmc0MsYUFBYUE7SUFDYlMsa0JBQWtCQTtJQUNsQnFDLG1CQUFtQkE7SUFDbkIrQyxXQUFXQTtJQUNYd0MsaUJBQWlCQTtBQUNqQjtBQUVBLE1BQU1NLGdCQUFnQjtJQUNwQmhpQztJQUNBcmxCO0lBQ0FzSztJQUNBbFI7Q0FDRDtBQUUyckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWxtaWxoYW5kby8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0Lm1qcz9iYzEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ2hhcnQuanMgdjMuOS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjIgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgciBhcyByZXF1ZXN0QW5pbUZyYW1lLCBhIGFzIHJlc29sdmUsIGUgYXMgZWZmZWN0cywgYyBhcyBjb2xvciwgZCBhcyBkZWZhdWx0cywgaSBhcyBpc09iamVjdCwgYiBhcyBpc0FycmF5LCB2IGFzIHZhbHVlT3JEZWZhdWx0LCB1IGFzIHVubGlzdGVuQXJyYXlFdmVudHMsIGwgYXMgbGlzdGVuQXJyYXlFdmVudHMsIGYgYXMgcmVzb2x2ZU9iamVjdEtleSwgZyBhcyBpc051bWJlckZpbml0ZSwgaCBhcyBjcmVhdGVDb250ZXh0LCBqIGFzIGRlZmluZWQsIHMgYXMgc2lnbiwgayBhcyBpc051bGxPclVuZGVmLCBfIGFzIF9hcnJheVVuaXF1ZSwgdCBhcyB0b1JhZGlhbnMsIG0gYXMgdG9QZXJjZW50YWdlLCBuIGFzIHRvRGltZW5zaW9uLCBUIGFzIFRBVSwgbyBhcyBmb3JtYXROdW1iZXIsIHAgYXMgX2FuZ2xlQmV0d2VlbiwgSCBhcyBIQUxGX1BJLCBQIGFzIFBJLCBxIGFzIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCB3IGFzIF9zY2FsZVJhbmdlc0NoYW5nZWQsIHggYXMgaXNOdW1iZXIsIHkgYXMgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLCB6IGFzIGxvZzEwLCBBIGFzIF9mYWN0b3JpemUsIEIgYXMgZmluaXRlT3JEZWZhdWx0LCBDIGFzIGNhbGxiYWNrLCBEIGFzIF9hZGRHcmFjZSwgRSBhcyBfbGltaXRWYWx1ZSwgRiBhcyB0b0RlZ3JlZXMsIEcgYXMgX21lYXN1cmVUZXh0LCBJIGFzIF9pbnQxNlJhbmdlLCBKIGFzIF9hbGlnblBpeGVsLCBLIGFzIHRvUGFkZGluZywgTCBhcyBjbGlwQXJlYSwgTSBhcyByZW5kZXJUZXh0LCBOIGFzIHVuY2xpcEFyZWEsIE8gYXMgdG9Gb250LCBRIGFzIGVhY2gsIFIgYXMgX3RvTGVmdFJpZ2h0Q2VudGVyLCBTIGFzIF9hbGlnblN0YXJ0RW5kLCBVIGFzIG92ZXJyaWRlcywgViBhcyBtZXJnZSwgVyBhcyBfY2FwaXRhbGl6ZSwgWCBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBZIGFzIF9ybG9va3VwQnlLZXksIFogYXMgX2xvb2t1cEJ5S2V5LCAkIGFzIF9pc1BvaW50SW5BcmVhLCBhMCBhcyBnZXRBbmdsZUZyb21Qb2ludCwgYTEgYXMgZ2V0TWF4aW11bVNpemUsIGEyIGFzIF9nZXRQYXJlbnROb2RlLCBhMyBhcyByZWFkVXNlZFNpemUsIGE0IGFzIHRocm90dGxlZCwgYTUgYXMgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgYTYgYXMgX2lzRG9tU3VwcG9ydGVkLCBhNyBhcyBkZXNjcmlwdG9ycywgYTggYXMgaXNGdW5jdGlvbiwgYTkgYXMgX2F0dGFjaENvbnRleHQsIGFhIGFzIF9jcmVhdGVSZXNvbHZlciwgYWIgYXMgX2Rlc2NyaXB0b3JzLCBhYyBhcyBtZXJnZUlmLCBhZCBhcyB1aWQsIGFlIGFzIGRlYm91bmNlLCBhZiBhcyByZXRpbmFTY2FsZSwgYWcgYXMgY2xlYXJDYW52YXMsIGFoIGFzIHNldHNFcXVhbCwgYWkgYXMgX2VsZW1lbnRzRXF1YWwsIGFqIGFzIF9pc0NsaWNrRXZlbnQsIGFrIGFzIF9pc0JldHdlZW4sIGFsIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBhbSBhcyBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cywgYW4gYXMgX2NvbXB1dGVTZWdtZW50cywgYW8gYXMgX2JvdW5kU2VnbWVudHMsIGFwIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYXEgYXMgX2JlemllckludGVycG9sYXRpb24sIGFyIGFzIF9wb2ludEluTGluZSwgYXMgYXMgX3N0ZXBwZWRMaW5lVG8sIGF0IGFzIF9iZXppZXJDdXJ2ZVRvLCBhdSBhcyBkcmF3UG9pbnQsIGF2IGFzIGFkZFJvdW5kZWRSZWN0UGF0aCwgYXcgYXMgdG9UUkJMLCBheCBhcyB0b1RSQkxDb3JuZXJzLCBheSBhcyBfYm91bmRTZWdtZW50LCBheiBhcyBfbm9ybWFsaXplQW5nbGUsIGFBIGFzIGdldFJ0bEFkYXB0ZXIsIGFCIGFzIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgYUMgYXMgX3RleHRYLCBhRCBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYUUgYXMgZHJhd1BvaW50TGVnZW5kLCBhRiBhcyBub29wLCBhRyBhcyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIGFIIGFzIF9zZXRNaW5BbmRNYXhCeUtleSwgYUkgYXMgbmljZU51bSwgYUogYXMgYWxtb3N0V2hvbGUsIGFLIGFzIGFsbW9zdEVxdWFscywgYUwgYXMgX2RlY2ltYWxQbGFjZXMsIGFNIGFzIF9sb25nZXN0VGV4dCwgYU4gYXMgX2ZpbHRlckJldHdlZW4sIGFPIGFzIF9sb29rdXAgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzJztcbmV4cG9ydCB7IGQgYXMgZGVmYXVsdHMgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzJztcblxuY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxudmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICBjb25zdCBjMCA9IGNvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgY29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcbmNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICB0byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG4gIHRpY2soZGF0ZSkge1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgIGxldCBmYWN0b3I7XG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG4gIHdhaXQoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcbiAgICB9KTtcbiAgfVxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgZHVyYXRpb246IDEwMDAsXG4gIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gIGZuOiB1bmRlZmluZWQsXG4gIGZyb206IHVuZGVmaW5lZCxcbiAgbG9vcDogdW5kZWZpbmVkLFxuICB0bzogdW5kZWZpbmVkLFxuICB0eXBlOiB1bmRlZmluZWQsXG59KTtcbmNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbicsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX2luZGV4YWJsZTogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nLFxufSk7XG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XG4gIGNvbG9yczoge1xuICAgIHR5cGU6ICdjb2xvcicsXG4gICAgcHJvcGVydGllczogY29sb3JzXG4gIH0sXG4gIG51bWJlcnM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gIH0sXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICBfZmFsbGJhY2s6ICdhbmltYXRpb24nLFxufSk7XG5kZWZhdWx0cy5zZXQoJ3RyYW5zaXRpb25zJywge1xuICBhY3RpdmU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICB9XG4gIH0sXG4gIHJlc2l6ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDBcbiAgICB9XG4gIH0sXG4gIHNob3c6IHtcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG4gIGhpZGU6IHtcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZm46IHYgPT4gdiB8IDBcbiAgICAgIH0sXG4gICAgfVxuICB9XG59KTtcbmNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIGNvbnN0IHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0ID0gdmFsdWUudG9wO1xuICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICBiID0gdmFsdWUuYm90dG9tO1xuICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICB9IGVsc2Uge1xuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc051bWJlckZpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICB4OiBrZXksXG4gICAgICB5OiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gIH1cbn1cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gdGhpcztcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpID0+IGN1cltpQXhpc10gPT09IG51bGwgfHwgKHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpICsgc3RhcnRdID0gY3VyID0gcGFyc2VkW2ldO1xuICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgfVxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc11cbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNOdW1iZXJGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHt9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBjb25zdCBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICBsZXQgaTtcbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCkge1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBtb3ZlID0gKGFycikgPT4ge1xuICAgICAgYXJyLmxlbmd0aCArPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpIC0gY291bnRdO1xuICAgICAgfVxuICAgIH07XG4gICAgbW92ZShkYXRhKTtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLmFyZ3NdKTtcbiAgfVxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuICBfb25EYXRhU2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIDAsIDFdKTtcbiAgfVxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5EYXRhc2V0Q29udHJvbGxlci5kZWZhdWx0cyA9IHt9O1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5jbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCB7aVNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSlcbiAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtZXRhIG9mIG1ldGFzZXRzKSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTtcbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XG4gICAgfVxuICAgIGlmIChiYXNlID09PSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShhY3R1YWxCYXNlKSkge1xuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcbiAgICAgIGJhc2UgKz0gaGFsZkdyaWQ7XG4gICAgICBzaXplIC09IGhhbGZHcmlkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICBjb25zdCBzY2FsZSA9IHJ1bGVyLnNjYWxlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XG4gICAgbGV0IGNlbnRlciwgc2l6ZTtcbiAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG4gICAgICAgID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG4gICAgICBoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcbiAgICAgIGNlbnRlcixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgaWxlbiA9IHJlY3RzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuQmFyQ29udHJvbGxlci5pZCA9ICdiYXInO1xuQmFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcbiAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgZ3JvdXBlZDogdHJ1ZSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgIH1cbiAgfVxufTtcbkJhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbWV0YS5sYWJlbCxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuQnViYmxlQ29udHJvbGxlci5pZCA9ICdidWJibGUnO1xuQnViYmxlQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgIH1cbiAgfVxufTtcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge31cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgIH0sXG4gIH0sXG4gIGN1dG91dDogJzUwJScsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6ICdyJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgbGV0IGRhdGFMYWJlbCA9IHRvb2x0aXBJdGVtLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFMYWJlbCkpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgKz0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhTGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBkYXRhOiBwb2ludHMgPSBbXSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuTGluZUNvbnRyb2xsZXIuaWQgPSAnbGluZSc7XG5MaW5lQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbn07XG5MaW5lQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICB9LFxuICB9XG59O1xuXG5jbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuUG9sYXJBcmVhQ29udHJvbGxlci5pZCA9ICdwb2xhckFyZWEnO1xuUG9sYXJBcmVhQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgfSxcbiAgfSxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHN0YXJ0QW5nbGU6IDAsXG59O1xuUG9sYXJBcmVhQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jaGFydC5kYXRhLmxhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gKyAnOiAnICsgY29udGV4dC5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcbn1cblBpZUNvbnRyb2xsZXIuaWQgPSAncGllJztcblBpZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGN1dG91dDogMCxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJSdcbn07XG5cbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuUmFkYXJDb250cm9sbGVyLmlkID0gJ3JhZGFyJztcblJhZGFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBlbGVtZW50czoge1xuICAgIGxpbmU6IHtcbiAgICAgIGZpbGw6ICdzdGFydCdcbiAgICB9XG4gIH0sXG59O1xuUmFkYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG4gIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuRWxlbWVudC5kZWZhdWx0cyA9IHt9O1xuRWxlbWVudC5kZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gIH0sXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpO1xuICAgIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cbnZhciBUaWNrcyA9IHtmb3JtYXR0ZXJzfTtcblxuZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgb2Zmc2V0OiBmYWxzZSxcbiAgcmV2ZXJzZTogZmFsc2UsXG4gIGJlZ2luQXRaZXJvOiBmYWxzZSxcbiAgYm91bmRzOiAndGlja3MnLFxuICBncmFjZTogMCxcbiAgZ3JpZDoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGRyYXdCb3JkZXI6IHRydWUsXG4gICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICB0aWNrTGVuZ3RoOiA4LFxuICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG4gICAgYm9yZGVyV2lkdGg6IDFcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICB0ZXh0OiAnJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDQsXG4gICAgICBib3R0b206IDRcbiAgICB9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgbWluUm90YXRpb246IDAsXG4gICAgbWF4Um90YXRpb246IDUwLFxuICAgIG1pcnJvcjogZmFsc2UsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgcGFkZGluZzogMyxcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICBsYWJlbE9mZnNldDogMCxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgbWlub3I6IHt9LFxuICAgIG1ham9yOiB7fSxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICB9XG59KTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnYm9yZGVyQ29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gIF9mYWxsYmFjazogJ3NjYWxlJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbn0pO1xuXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG4gIG5leHQgPSBzdGFydDtcbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjtcbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9XG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUZpdCgpO1xuICAgIHRoaXMuZml0KCk7XG4gICAgdGhpcy5hZnRlckZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICBsZXQgc3RhcnRQaXhlbCwgZW5kUGl4ZWw7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLnRvcDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5ib3R0b207XG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG4gICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcbiAgfVxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gMDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnNbbmFtZV0sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbGJhY2sodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xuICAgIH1cbiAgfVxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhdGlja09wdHMuZGlzcGxheSB8fCBtaW5Sb3RhdGlvbiA+PSBtYXhSb3RhdGlvbiB8fCBudW1UaWNrcyA8PSAxIHx8ICF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7fVxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICBpc0Z1bGxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gIH1cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsU2l6ZXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCBsZW5ndGgpIHtcbiAgICBjb25zdCB7Y3R4LCBfbG9uZ2VzdFRleHRDYWNoZTogY2FjaGVzfSA9IHRoaXM7XG4gICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICBoZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbmVzdGVkTGFiZWwgPSBsYWJlbFtqXTtcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IHZhbHVlQXQgPSAoaWR4KSA9PiAoe3dpZHRoOiB3aWR0aHNbaWR4XSB8fCAwLCBoZWlnaHQ6IGhlaWdodHNbaWR4XSB8fCAwfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JEZWNpbWFsKGRlY2ltYWwpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xuICAgICAgZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSAocGl4ZWwgLSB0aGlzLl9zdGFydFBpeGVsKSAvIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZVBpeGVscyA/IDEgLSBkZWNpbWFsIDogZGVjaW1hbDtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHxcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICBjb25zdCBoID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBwYWRkaW5nIDogMDtcbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG4gICAgICA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gIH1cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG4gICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG4gIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtncmlkLCBwb3NpdGlvbn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgY29uc3QgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICByZXR1cm4gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuICAgIH07XG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG4gICAgbGV0IHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgbGV0IGJhY2tkcm9wO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG4gICAgICAgIGxldCB0b3AgPSB5ICsgdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0geCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIHRleHRBbGlnbjogdGlja1RleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICBiYWNrZHJvcCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICB9XG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgbGV0IHRleHRBbGlnbjtcbiAgICBsZXQgeDtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcbiAgfVxuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpID0+IHtcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGdyaWQuZHJhd09uQ2hhcnRBcmVhKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS54MSwgeTogaXRlbS55MX0sXG4gICAgICAgICAgICB7eDogaXRlbS54MiwgeTogaXRlbS55Mn0sXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Z3JpZH19ID0gdGhpcztcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBncmlkLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmxlZnQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlck9wdHMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5ib3JkZXJDb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGlmIChpdGVtLmJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLmJhY2tkcm9wLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaXRlbS5iYWNrZHJvcC5sZWZ0LCBpdGVtLmJhY2tkcm9wLnRvcCwgaXRlbS5iYWNrZHJvcC53aWR0aCwgaXRlbS5iYWNrZHJvcC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgbGV0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICB9XG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiB0eixcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogZ3ogKyAxLFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5jaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXhpc0lEID0gdGhpcy5heGlzICsgJ0F4aXNJRCc7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpbmRleCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XG4gIH1cbiAgX21heERpZ2l0cygpIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gZm9udFNpemU7XG4gIH1cbn1cblxuY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLml0ZW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cbiAgcmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgIGxldCBwYXJlbnRTY29wZTtcbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICBwYXJlbnRTY29wZSA9IHRoaXMucmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zW2lkXTtcbiAgfVxuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XG4gICAgfVxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuICBkZWZhdWx0cy5zZXQoc2NvcGUsIGl0ZW1EZWZhdWx0cyk7XG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcbiAgICBjb25zdCBzb3VyY2VTY29wZSA9IFtzY29wZV0uY29uY2F0KHByb3BlcnR5UGFydHMpLmpvaW4oJy4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGUgPSBwYXJ0cy5qb2luKCcuJyk7XG4gICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuXG5jbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cbiAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncyk7XG4gIH1cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgYWRkRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgZ2V0Q29udHJvbGxlcihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuY29udHJvbGxlcnMsICdjb250cm9sbGVyJyk7XG4gIH1cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cbiAgZ2V0UGx1Z2luKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gIH1cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsYmFjayhjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsYmFjayhjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gIH1cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gIH1cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbn1cbnZhciByZWdpc3RyeSA9IG5ldyBSZWdpc3RyeSgpO1xuXG5jbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSByZWdpc3RyeS5nZXRFbGVtZW50KCdsaW5lJyk7XG4gICAgfVxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IG1heCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbn1cblNjYXR0ZXJDb250cm9sbGVyLmlkID0gJ3NjYXR0ZXInO1xuU2NhdHRlckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgc2hvd0xpbmU6IGZhbHNlLFxuICBmaWxsOiBmYWxzZVxufTtcblNjYXR0ZXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBtb2RlOiAncG9pbnQnXG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuICcoJyArIGl0ZW0ubGFiZWwgKyAnLCAnICsgaXRlbS5mb3JtYXR0ZWRWYWx1ZSArICcpJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29udHJvbGxlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5CYXJDb250cm9sbGVyOiBCYXJDb250cm9sbGVyLFxuQnViYmxlQ29udHJvbGxlcjogQnViYmxlQ29udHJvbGxlcixcbkRvdWdobnV0Q29udHJvbGxlcjogRG91Z2hudXRDb250cm9sbGVyLFxuTGluZUNvbnRyb2xsZXI6IExpbmVDb250cm9sbGVyLFxuUG9sYXJBcmVhQ29udHJvbGxlcjogUG9sYXJBcmVhQ29udHJvbGxlcixcblBpZUNvbnRyb2xsZXI6IFBpZUNvbnRyb2xsZXIsXG5SYWRhckNvbnRyb2xsZXI6IFJhZGFyQ29udHJvbGxlcixcblNjYXR0ZXJDb250cm9sbGVyOiBTY2F0dGVyQ29udHJvbGxlclxufSk7XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cbmNsYXNzIERhdGVBZGFwdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cbiAgaW5pdChjaGFydE9wdGlvbnMpIHt9XG4gIGZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgcGFyc2UodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGZvcm1hdCh0aW1lc3RhbXAsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGFkZCh0aW1lc3RhbXAsIGFtb3VudCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGRpZmYoYSwgYiwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHN0YXJ0T2YodGltZXN0YW1wLCB1bml0LCB3ZWVrZGF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZW5kT2YodGltZXN0YW1wLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xuICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgbWVtYmVycyk7XG59O1xudmFyIGFkYXB0ZXJzID0ge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJcbn07XG5cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICBjb25zdCB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIV9pc1BvaW50SW5BcmVhKGVsZW1lbnQsIGNoYXJ0LmNoYXJ0QXJlYSwgMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfTtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxudmFyIEludGVyYWN0aW9uID0ge1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG4gIG1vZGVzOiB7XG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICB5KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wb3MgPT09IHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBib3gsIHBvcywgc3RhY2ssIHN0YWNrV2VpZ2h0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplLFxuICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxuICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG4gIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XG4gIH1cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJnaW47XG4gIH1cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgIGJveCA9IGxheW91dC5ib3g7XG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG4gICAgaWYgKCFib3guZnVsbFNpemUpIHtcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgYm94LnRvcCA9IHRvcDtcbiAgYm94LmxlZnQgPSBsZWZ0O1xuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGJveC5ib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGJveC53aWR0aCA9IHdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cbiAgY2hhcnRBcmVhLnggPSB4O1xuICBjaGFydEFyZWEueSA9IHk7XG59XG5kZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgYXV0b1BhZGRpbmc6IHRydWUsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfVxufSk7XG52YXIgbGF5b3V0cyA9IHtcbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge31cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICB9XG59XG5cbmNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQsIChhcmdzKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIHJldHVybiBbZXZlbnQsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICB9KTtcbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHtwbHVnaW5zLCBsb2NhbElkc30sIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywge3BsdWdpbiwgbG9jYWx9LCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBhbGxLZXlzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5Jykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICByZXR1cm4gc2NhbGVPcHRpb25zLmF4aXMgfHwgYXhpc0Zyb21Qb3NpdGlvbihzY2FsZU9wdGlvbnMucG9zaXRpb24pIHx8IGlkLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdElEcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgZmlyc3RJRHNbYXhpc10gPSBmaXJzdElEc1theGlzXSB8fCBpZDtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgZmlyc3RJRHNbYXhpc10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNjYWxlcztcbn1cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuICBpbml0T3B0aW9ucyhjb25maWcpO1xuICByZXR1cm4gY29uZmlnO1xufVxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5jbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjIHx8IGlzRnVuY3Rpb24odmFsdWVba2V5XSksIGZhbHNlKTtcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjMuOS4xXCI7XG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuY2xhc3MgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5jYW52YXMuaWQgKyAnXFwnIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG4gICAgY2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG4gICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICB9XG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuICBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICB9XG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xuICAgIGNvbnN0IHtjYW52YXMsIGN0eH0gPSB0aGlzO1xuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdkZXN0cm95Jyk7XG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgZGV0YWNoZWQ7XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICByZXBsYXksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgIH07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkIHx8IHJlcGxheSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbn1cbmNvbnN0IGludmFsaWRhdGVQbHVnaW5zID0gKCkgPT4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbmNvbnN0IGVudW1lcmFibGUgPSB0cnVlO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhcnQsIHtcbiAgZGVmYXVsdHM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBkZWZhdWx0c1xuICB9LFxuICBpbnN0YW5jZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBpbnN0YW5jZXNcbiAgfSxcbiAgb3ZlcnJpZGVzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogb3ZlcnJpZGVzXG4gIH0sXG4gIHJlZ2lzdHJ5OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogcmVnaXN0cnlcbiAgfSxcbiAgdmVyc2lvbjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHZlcnNpb25cbiAgfSxcbiAgZ2V0Q2hhcnQ6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBnZXRDaGFydFxuICB9LFxuICByZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXN9ID0gZWxlbWVudDtcbiAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMkMShhcmMsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgYW5nbGVEZWx0YSkge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cbmZ1bmN0aW9uIHJUaGV0YVRvWFkociwgdGhldGEsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZCwgY2lyY3VsYXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzcGFjaW5nKSB7XG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuICAgIGNvbnN0IG91dGVyRW5kWCA9IE1hdGguY29zKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgc3RhcnRBbmdsZSArIFRBVSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSAlIFRBVTtcbiAgICAgIGlmIChjaXJjdW1mZXJlbmNlICUgVEFVID09PSAwKSB7XG4gICAgICAgIGVuZEFuZ2xlICs9IFRBVTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCBmdWxsQ2lyY2xlc30gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gZWxlbWVudC5pbm5lclJhZGl1cyArIHBpeGVsTWFyZ2luO1xuICBsZXQgaTtcbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSArIFRBVSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpIHtcbiAgY29uc3Qge29wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGV9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG4gIGlmIChlbGVtZW50LmZ1bGxDaXJjbGVzKSB7XG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LnN0cm9rZSgpO1xufVxuY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShjaGFydFgsIGNoYXJ0WSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSB0aGlzLm9wdGlvbnMuc3BhY2luZyAvIDI7XG4gICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9IF9pc0JldHdlZW4oZGlzdGFuY2UsIGlubmVyUmFkaXVzICsgckFkanVzdCwgb3V0ZXJSYWRpdXMgKyByQWRqdXN0KTtcbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZScsXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge29mZnNldCwgc3BhY2luZ30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xuICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG4gICAgfTtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcztcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyAyO1xuICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICBjb25zdCBjaXJjdWxhciA9IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgcmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCk7XG4gICAgICBpZiAodGhpcy5jaXJjdW1mZXJlbmNlID49IFBJKSB7XG4gICAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgZW5kQW5nbGUgPSBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5BcmNFbGVtZW50LmlkID0gJ2FyYyc7XG5BcmNFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gIGJvcmRlckpvaW5TdHlsZTogdW5kZWZpbmVkLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBvZmZzZXQ6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIGFuZ2xlOiB1bmRlZmluZWQsXG4gIGNpcmN1bGFyOiB0cnVlLFxufTtcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xufTtcblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cbiAgcmV0dXJuIGxpbmVUbztcbn1cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcHJldiA9IHBvaW50O1xuICB9XG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuICByZXR1cm4gISFsb29wO1xufVxuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5MaW5lRWxlbWVudC5pZCA9ICdsaW5lJztcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gIGZpbGw6IGZhbHNlLFxuICBzcGFuR2FwczogZmFsc2UsXG4gIHN0ZXBwZWQ6IGZhbHNlLFxuICB0ZW5zaW9uOiAwLFxufTtcbkxpbmVFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuTGluZUVsZW1lbnQuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbn07XG5cbmZ1bmN0aW9uIGluUmFuZ2UkMShlbCwgcG9zLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgc2l6ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuICBkcmF3KGN0eCwgYXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cblBvaW50RWxlbWVudC5pZCA9ICdwb2ludCc7XG5Qb2ludEVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgcmFkaXVzOiAzLFxuICByb3RhdGlvbjogMFxufTtcblBvaW50RWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSBiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5CYXJFbGVtZW50LmlkID0gJ2Jhcic7XG5CYXJFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxufTtcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5MaW5lRWxlbWVudDogTGluZUVsZW1lbnQsXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcbkJhckVsZW1lbnQ6IEJhckVsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXRhLmNvbnRyb2xsZXIuc3VwcG9ydHNEZWNpbWF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuICAgIGlmICghdGFyZ2V0LnNlZ21lbnRzKSB7XG4gICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgc291cmNlOiBzZWdtZW50LFxuICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXG4gICAgICAgIGVuZDogcG9pbnRzW2VuZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpIHtcbiAgY29uc3Qge3ggPSBudWxsLCB5ID0gbnVsbH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIF9zaG91bGRBcHBseUZpbGwoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuICBsZXQgdGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsKTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cbmZ1bmN0aW9uIGRlY29kZVRhcmdldEluZGV4KGZpcnN0Q2gsIGluZGV4LCB0YXJnZXQsIGNvdW50KSB7XG4gIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XG4gICAgdGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSkge1xuICBsZXQgcGl4ZWwgPSBudWxsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHBpeGVsID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS50b3A7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5mdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcbiAgbGV0IHZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgdmFsdWUgPSBmaWxsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuXG5mdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKF9jcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG5cbmNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cbiAgcGF0aFNlZ21lbnQoY3R4LCBib3VuZHMsIG9wdHMpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgYm91bmRzID0gYm91bmRzIHx8IHtzdGFydDogMCwgZW5kOiBUQVV9O1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBib3VuZHMuZW5kLCBib3VuZHMuc3RhcnQsIHRydWUpO1xuICAgIHJldHVybiAhb3B0cy5ib3VuZHM7XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG4gIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUocGl4ZWwpKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gcGl4ZWwgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG4gIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY29uc3QgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2xpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXN9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlfSA9IGNmZztcbiAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuICBjdHguc2F2ZSgpO1xuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5fSk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC5maXJzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICBjb25zdCB7dG9wLCBib3R0b219ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcbiAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICB9XG59XG5cbnZhciBpbmRleCA9IHtcbiAgaWQ6ICdmaWxsZXInLFxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZHJhdyA9IG9wdGlvbnMuZHJhd1RpbWUgPT09ICdiZWZvcmVEcmF3JztcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG4gICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcbmNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge2NvbG9yOiBmb250Q29sb3IsIHBhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94SGVpZ2h0ICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICBjb25zdCB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSA9IHRpdGxlUGFkZGluZy50b3AgKyBoYWxmRm9udFNpemU7XG4gICAgbGV0IHk7XG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmhlaWdodCksIDApO1xuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG4gIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgbGggPSB0aGlzLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2hvdmVyZWRJdGVtO1xuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGxiYWNrKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgaWYgKCh0eXBlID09PSAnbW91c2Vtb3ZlJyB8fCB0eXBlID09PSAnbW91c2VvdXQnKSAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgaWQ6ICdsZWdlbmQnLFxuICBfZWxlbWVudDogTGVnZW5kLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gIGlkOiAndGl0bGUnLFxuICBfZWxlbWVudDogVGl0bGUsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gIGxldCB3aWR0aCA9IDA7XG4gIGxldCBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZSgoY291bnQsIGJvZHlJdGVtKSA9PiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICBjb21iaW5lZEJvZHlMZW5ndGggKz0gdG9vbHRpcC5iZWZvcmVCb2R5Lmxlbmd0aCArIHRvb2x0aXAuYWZ0ZXJCb2R5Lmxlbmd0aDtcbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyAoYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nKSA6IDA7XG4gIGVhY2goYm9keSwgKGJvZHlJdGVtKSA9PiB7XG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuICB9KTtcbiAgd2lkdGhQYWRkaW5nID0gMDtcbiAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICBpZiAoeEFsaWduID09PSAnbGVmdCcgJiYgeCArIHdpZHRoICsgY2FyZXQgPiBjaGFydC53aWR0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xuICB9XG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cbiAgcmV0dXJuIHhBbGlnbjtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuICByZXR1cm4ge1xuICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgIHlBbGlnblxuICB9O1xufVxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2Uge1xuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydCB8fCBjb25maWcuX2NoYXJ0O1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5iZWZvcmVMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhzY29wZWQuYWZ0ZXJMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goc2NvcGVkLmxhYmVsQ29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goc2NvcGVkLmxhYmVsUG9pbnRTdHlsZS5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbFRleHRDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0aGlzLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gIH1cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgxID0gcHRYO1xuICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG4gICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nO1xuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWCh0aGlzLCAnbGVmdCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICBjb25zdCBjb2xvclkgPSBwdC55ICsgeU9mZlNldDtcbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsXG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKSArIGJveFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBjb2xvclkgKyBib3hIZWlnaHQgLyAyO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoKSkgOiAobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9ycy5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3JzLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IG91dGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGggLSBib3hQYWRkaW5nKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIGJveFBhZGRpbmcgLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvcnMuYm9yZGVyUmFkaXVzKTtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYm9keUNvbG9yO1xuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7XG4gIH1cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHt4LCB5fSA9IHB0O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRvb2x0aXBTaXplO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1YID0gYW5pbXMgJiYgYW5pbXMueDtcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgaWYgKGFuaW1YIHx8IGFuaW1ZKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgdGhpcy5fYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCB0aGlzLl9zaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FyZXRYID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF93aWxsUmVuZGVyKCkge1xuICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblRvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIGJlZm9yZVRpdGxlOiBub29wLFxuICAgICAgdGl0bGUodG9vbHRpcEl0ZW1zKSB7XG4gICAgICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0sXG4gICAgICBhZnRlclRpdGxlOiBub29wLFxuICAgICAgYmVmb3JlQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUxhYmVsOiBub29wLFxuICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJzogJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgICAgbGFiZWwgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcbiAgICAgIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgICAgIH0sXG4gICAgICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWZ0ZXJMYWJlbDogbm9vcCxcbiAgICAgIGFmdGVyQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgICAgIGZvb3Rlcjogbm9vcCxcbiAgICAgIGFmdGVyRm9vdGVyOiBub29wXG4gICAgfVxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG5cbnZhciBwbHVnaW5zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuRGVjaW1hdGlvbjogcGx1Z2luX2RlY2ltYXRpb24sXG5GaWxsZXI6IGluZGV4LFxuTGVnZW5kOiBwbHVnaW5fbGVnZW5kLFxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcblRpdGxlOiBwbHVnaW5fdGl0bGUsXG5Ub29sdGlwOiBwbHVnaW5fdG9vbHRpcFxufSk7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5jbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuQ2F0ZWdvcnlTY2FsZS5pZCA9ICdjYXRlZ29yeSc7XG5DYXRlZ29yeVNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBDYXRlZ29yeVNjYWxlLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcn0pO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cbmNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICtyYXc7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IDE7XG4gICAgICBpZiAobWF4ID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG1pbiA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhtYXggKiAwLjA1KTtcbiAgICAgIH1cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG5cbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBtYXggOiAxO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG5MaW5lYXJTY2FsZS5pZCA9ICdsaW5lYXInO1xuTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcbiAgY29uc3QgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgbGV0IHRpY2tWYWwgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcbiAgbGV0IGV4cCA9IE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgZG8ge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICAgICsrc2lnbmlmaWNhbmQ7XG4gICAgaWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSAxO1xuICAgICAgKytleHA7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICByZXR1cm4gdGlja3M7XG59XG5jbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBjb25zdCBleHAgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodikpICsgbSk7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChleHAobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihleHAobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcbiAgICAgIHNldE1heChleHAobWluLCArMSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmIG1pbiA9PT0gZXhwKHRoaXMubWluLCAwKSkge1xuICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuTG9nYXJpdGhtaWNTY2FsZS5pZCA9ICdsb2dhcml0aG1pYyc7XG5Mb2dhcml0aG1pY1NjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBleHRyYSA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDI7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gb3B0cy5wb2ludExhYmVscy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gICAgY29uc3Qgc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG4gICAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gICAgaXRlbXMucHVzaCh7XG4gICAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICAgIHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICBsZWZ0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgICBib3R0b206IHkgKyBzaXplLmhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cbiAgcmV0dXJuICdyaWdodCc7XG59XG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ24sIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHNBdEluZGV4O1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzQXRJbmRleC5ib3JkZXJSYWRpdXMpO1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG4gICAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgICAgY29uc3QgYmFja2Ryb3BUb3AgPSB0b3AgLSBwYWRkaW5nLnRvcDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCkge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG4gIGlmICgoIWNpcmN1bGFyICYmICFsYWJlbENvdW50KSB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2gpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldDtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnN0cm9rZSgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMik7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcbiAgICByZXR1cm4gX25vcm1hbGl6ZUFuZ2xlKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgdG9SYWRpYW5zKHN0YXJ0QW5nbGUpKTtcbiAgfVxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZERpc3RhbmNlID0gZGlzdGFuY2UgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIEhBTEZfUEkgKyBhZGRpdGlvbmFsQW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICB9O1xuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0dyaWQoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZH0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgIH1cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4IC0gMSkpO1xuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG4gICAgICAgIGlmICghbGluZVdpZHRoIHx8ICFjb2xvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7fVxuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvZmZzZXQsIHdpZHRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpY2subGFiZWwpLndpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7fVxufVxuUmFkaWFsTGluZWFyU2NhbGUuaWQgPSAncmFkaWFsTGluZWFyJztcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICBkaXNwbGF5OiB0cnVlLFxuICBhbmltYXRlOiB0cnVlLFxuICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG4gIGFuZ2xlTGluZXM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgfSxcbiAgZ3JpZDoge1xuICAgIGNpcmN1bGFyOiBmYWxzZVxuICB9LFxuICBzdGFydEFuZ2xlOiAwLFxuICB0aWNrczoge1xuICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfSxcbiAgcG9pbnRMYWJlbHM6IHtcbiAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgZm9udDoge1xuICAgICAgc2l6ZTogMTBcbiAgICB9LFxuICAgIGNhbGxiYWNrKGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICB9XG59O1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdFJvdXRlcyA9IHtcbiAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxuICAndGlja3MuY29sb3InOiAnY29sb3InXG59O1xuUmFkaWFsTGluZWFyU2NhbGUuZGVzY3JpcHRvcnMgPSB7XG4gIGFuZ2xlTGluZXM6IHtcbiAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICB9XG59O1xuXG5jb25zdCBJTlRFUlZBTFMgPSB7XG4gIG1pbGxpc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxLCBzdGVwczogMTAwMH0sXG4gIHNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMTAwMCwgc3RlcHM6IDYwfSxcbiAgbWludXRlOiB7Y29tbW9uOiB0cnVlLCBzaXplOiA2MDAwMCwgc3RlcHM6IDYwfSxcbiAgaG91cjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMzYwMDAwMCwgc3RlcHM6IDI0fSxcbiAgZGF5OiB7Y29tbW9uOiB0cnVlLCBzaXplOiA4NjQwMDAwMCwgc3RlcHM6IDMwfSxcbiAgd2Vlazoge2NvbW1vbjogZmFsc2UsIHNpemU6IDYwNDgwMDAwMCwgc3RlcHM6IDR9LFxuICBtb250aDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMi42MjhlOSwgc3RlcHM6IDEyfSxcbiAgcXVhcnRlcjoge2NvbW1vbjogZmFsc2UsIHNpemU6IDcuODg0ZTksIHN0ZXBzOiA0fSxcbiAgeWVhcjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMy4xNTRlMTB9XG59O1xuY29uc3QgVU5JVFMgPSAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcbiAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKCFpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBwYXJzZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IGFkYXB0ZXIucGFyc2UodmFsdWUsIHBhcnNlcilcbiAgICAgIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cbiAgcmV0dXJuICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG4gIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuICAgIGNvbnN0IHVuaXQgPSBVTklUU1tpXTtcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcbiAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcykge1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICBjb25zdCB7bG8sIGhpfSA9IF9sb29rdXAodGltZXN0YW1wcywgdGltZSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgdGlja3NbdGltZXN0YW1wXSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcbiAgY29uc3QgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgbWFqb3IsIGluZGV4O1xuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIG1hcFt2YWx1ZV0gPSBpO1xuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5jbGFzcyBUaW1lU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIHRoaXMuX21ham9yVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KHNjYWxlT3B0cywgb3B0cykge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgYWRhcHRlcnMuX2RhdGUoc2NhbGVPcHRzLmFkYXB0ZXJzLmRhdGUpO1xuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAodGljayA9PiArdGljay52YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCh0aW1lT3B0cy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRpY2tzKS5zb3J0KChhLCBiKSA9PiBhIC0gYikubWFwKHggPT4gK3gpO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG4gICAgcmV0dXJuIGZvcm1hdHRlciA/IGNhbGxiYWNrKGZvcm1hdHRlciwgW2xhYmVsLCBpbmRleCwgdGlja3NdLCB0aGlzKSA6IGxhYmVsO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKHRoaXMsIGxhYmVsc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG5UaW1lU2NhbGUuaWQgPSAndGltZSc7XG5UaW1lU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGJvdW5kczogJ2RhdGEnLFxuICBhZGFwdGVyczoge30sXG4gIHRpbWU6IHtcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHVuaXQ6IGZhbHNlLFxuICAgIHJvdW5kOiBmYWxzZSxcbiAgICBpc29XZWVrZGF5OiBmYWxzZSxcbiAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICB9LFxuICB0aWNrczoge1xuICAgIHNvdXJjZTogJ2F1dG8nLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuVGltZVNlcmllc1NjYWxlLmlkID0gJ3RpbWVzZXJpZXMnO1xuVGltZVNlcmllc1NjYWxlLmRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG52YXIgc2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQ2F0ZWdvcnlTY2FsZTogQ2F0ZWdvcnlTY2FsZSxcbkxpbmVhclNjYWxlOiBMaW5lYXJTY2FsZSxcbkxvZ2FyaXRobWljU2NhbGU6IExvZ2FyaXRobWljU2NhbGUsXG5SYWRpYWxMaW5lYXJTY2FsZTogUmFkaWFsTGluZWFyU2NhbGUsXG5UaW1lU2NhbGU6IFRpbWVTY2FsZSxcblRpbWVTZXJpZXNTY2FsZTogVGltZVNlcmllc1NjYWxlXG59KTtcblxuY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuXG5leHBvcnQgeyBBbmltYXRpb24sIEFuaW1hdGlvbnMsIEFyY0VsZW1lbnQsIEJhckNvbnRyb2xsZXIsIEJhckVsZW1lbnQsIEJhc2VQbGF0Zm9ybSwgQmFzaWNQbGF0Zm9ybSwgQnViYmxlQ29udHJvbGxlciwgQ2F0ZWdvcnlTY2FsZSwgQ2hhcnQsIERhdGFzZXRDb250cm9sbGVyLCBwbHVnaW5fZGVjaW1hdGlvbiBhcyBEZWNpbWF0aW9uLCBEb21QbGF0Zm9ybSwgRG91Z2hudXRDb250cm9sbGVyLCBFbGVtZW50LCBpbmRleCBhcyBGaWxsZXIsIEludGVyYWN0aW9uLCBwbHVnaW5fbGVnZW5kIGFzIExlZ2VuZCwgTGluZUNvbnRyb2xsZXIsIExpbmVFbGVtZW50LCBMaW5lYXJTY2FsZSwgTG9nYXJpdGhtaWNTY2FsZSwgUGllQ29udHJvbGxlciwgUG9pbnRFbGVtZW50LCBQb2xhckFyZWFDb250cm9sbGVyLCBSYWRhckNvbnRyb2xsZXIsIFJhZGlhbExpbmVhclNjYWxlLCBTY2FsZSwgU2NhdHRlckNvbnRyb2xsZXIsIHBsdWdpbl9zdWJ0aXRsZSBhcyBTdWJUaXRsZSwgVGlja3MsIFRpbWVTY2FsZSwgVGltZVNlcmllc1NjYWxlLCBwbHVnaW5fdGl0bGUgYXMgVGl0bGUsIHBsdWdpbl90b29sdGlwIGFzIFRvb2x0aXAsIGFkYXB0ZXJzIGFzIF9hZGFwdGVycywgX2RldGVjdFBsYXRmb3JtLCBhbmltYXRvciwgY29udHJvbGxlcnMsIGVsZW1lbnRzLCBsYXlvdXRzLCBwbHVnaW5zLCByZWdpc3RlcmFibGVzLCByZWdpc3RyeSwgc2NhbGVzIH07XG4iXSwibmFtZXMiOlsiciIsInJlcXVlc3RBbmltRnJhbWUiLCJhIiwicmVzb2x2ZSIsImUiLCJlZmZlY3RzIiwiYyIsImNvbG9yIiwiZCIsImRlZmF1bHRzIiwiaSIsImlzT2JqZWN0IiwiYiIsImlzQXJyYXkiLCJ2IiwidmFsdWVPckRlZmF1bHQiLCJ1IiwidW5saXN0ZW5BcnJheUV2ZW50cyIsImwiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImYiLCJyZXNvbHZlT2JqZWN0S2V5IiwiZyIsImlzTnVtYmVyRmluaXRlIiwiaCIsImNyZWF0ZUNvbnRleHQiLCJqIiwiZGVmaW5lZCIsInMiLCJzaWduIiwiayIsImlzTnVsbE9yVW5kZWYiLCJfIiwiX2FycmF5VW5pcXVlIiwidCIsInRvUmFkaWFucyIsIm0iLCJ0b1BlcmNlbnRhZ2UiLCJuIiwidG9EaW1lbnNpb24iLCJUIiwiVEFVIiwibyIsImZvcm1hdE51bWJlciIsInAiLCJfYW5nbGVCZXR3ZWVuIiwiSCIsIkhBTEZfUEkiLCJQIiwiUEkiLCJxIiwiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJ3IiwiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsIngiLCJpc051bWJlciIsInkiLCJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCJ6IiwibG9nMTAiLCJBIiwiX2ZhY3Rvcml6ZSIsIkIiLCJmaW5pdGVPckRlZmF1bHQiLCJDIiwiY2FsbGJhY2siLCJEIiwiX2FkZEdyYWNlIiwiRSIsIl9saW1pdFZhbHVlIiwiRiIsInRvRGVncmVlcyIsIkciLCJfbWVhc3VyZVRleHQiLCJJIiwiX2ludDE2UmFuZ2UiLCJKIiwiX2FsaWduUGl4ZWwiLCJLIiwidG9QYWRkaW5nIiwiTCIsImNsaXBBcmVhIiwiTSIsInJlbmRlclRleHQiLCJOIiwidW5jbGlwQXJlYSIsIk8iLCJ0b0ZvbnQiLCJRIiwiZWFjaCIsIlIiLCJfdG9MZWZ0UmlnaHRDZW50ZXIiLCJTIiwiX2FsaWduU3RhcnRFbmQiLCJVIiwib3ZlcnJpZGVzIiwiViIsIm1lcmdlIiwiVyIsIl9jYXBpdGFsaXplIiwiWCIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJZIiwiX3Jsb29rdXBCeUtleSIsIloiLCJfbG9va3VwQnlLZXkiLCIkIiwiX2lzUG9pbnRJbkFyZWEiLCJhMCIsImdldEFuZ2xlRnJvbVBvaW50IiwiYTEiLCJnZXRNYXhpbXVtU2l6ZSIsImEyIiwiX2dldFBhcmVudE5vZGUiLCJhMyIsInJlYWRVc2VkU2l6ZSIsImE0IiwidGhyb3R0bGVkIiwiYTUiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwiYTYiLCJfaXNEb21TdXBwb3J0ZWQiLCJhNyIsImRlc2NyaXB0b3JzIiwiYTgiLCJpc0Z1bmN0aW9uIiwiYTkiLCJfYXR0YWNoQ29udGV4dCIsImFhIiwiX2NyZWF0ZVJlc29sdmVyIiwiYWIiLCJfZGVzY3JpcHRvcnMiLCJhYyIsIm1lcmdlSWYiLCJhZCIsInVpZCIsImFlIiwiZGVib3VuY2UiLCJhZiIsInJldGluYVNjYWxlIiwiYWciLCJjbGVhckNhbnZhcyIsImFoIiwic2V0c0VxdWFsIiwiYWkiLCJfZWxlbWVudHNFcXVhbCIsImFqIiwiX2lzQ2xpY2tFdmVudCIsImFrIiwiX2lzQmV0d2VlbiIsImFsIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJhbSIsIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwiYW4iLCJfY29tcHV0ZVNlZ21lbnRzIiwiYW8iLCJfYm91bmRTZWdtZW50cyIsImFwIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiYXEiLCJfYmV6aWVySW50ZXJwb2xhdGlvbiIsImFyIiwiX3BvaW50SW5MaW5lIiwiYXMiLCJfc3RlcHBlZExpbmVUbyIsImF0IiwiX2JlemllckN1cnZlVG8iLCJhdSIsImRyYXdQb2ludCIsImF2IiwiYWRkUm91bmRlZFJlY3RQYXRoIiwiYXciLCJ0b1RSQkwiLCJheCIsInRvVFJCTENvcm5lcnMiLCJheSIsIl9ib3VuZFNlZ21lbnQiLCJheiIsIl9ub3JtYWxpemVBbmdsZSIsImFBIiwiZ2V0UnRsQWRhcHRlciIsImFCIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwiYUMiLCJfdGV4dFgiLCJhRCIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwiYUUiLCJkcmF3UG9pbnRMZWdlbmQiLCJhRiIsIm5vb3AiLCJhRyIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsImFIIiwiX3NldE1pbkFuZE1heEJ5S2V5IiwiYUkiLCJuaWNlTnVtIiwiYUoiLCJhbG1vc3RXaG9sZSIsImFLIiwiYWxtb3N0RXF1YWxzIiwiYUwiLCJfZGVjaW1hbFBsYWNlcyIsImFNIiwiX2xvbmdlc3RUZXh0IiwiYU4iLCJfZmlsdGVyQmV0d2VlbiIsImFPIiwiX2xvb2t1cCIsIkFuaW1hdG9yIiwiY29uc3RydWN0b3IiLCJfcmVxdWVzdCIsIl9jaGFydHMiLCJNYXAiLCJfcnVubmluZyIsIl9sYXN0RGF0ZSIsInVuZGVmaW5lZCIsIl9ub3RpZnkiLCJjaGFydCIsImFuaW1zIiwiZGF0ZSIsInR5cGUiLCJjYWxsYmFja3MiLCJsaXN0ZW5lcnMiLCJudW1TdGVwcyIsImR1cmF0aW9uIiwiZm9yRWFjaCIsImZuIiwiaW5pdGlhbCIsImN1cnJlbnRTdGVwIiwiTWF0aCIsIm1pbiIsInN0YXJ0IiwiX3JlZnJlc2giLCJjYWxsIiwid2luZG93IiwiX3VwZGF0ZSIsIkRhdGUiLCJub3ciLCJyZW1haW5pbmciLCJydW5uaW5nIiwiaXRlbXMiLCJsZW5ndGgiLCJkcmF3IiwiaXRlbSIsIl9hY3RpdmUiLCJfdG90YWwiLCJ0aWNrIiwicG9wIiwiX2dldEFuaW1zIiwiY2hhcnRzIiwiZ2V0IiwiY29tcGxldGUiLCJwcm9ncmVzcyIsInNldCIsImxpc3RlbiIsImV2ZW50IiwiY2IiLCJwdXNoIiwiYWRkIiwiaGFzIiwicmVkdWNlIiwiYWNjIiwiY3VyIiwibWF4IiwiX2R1cmF0aW9uIiwic3RvcCIsImNhbmNlbCIsInJlbW92ZSIsImRlbGV0ZSIsImFuaW1hdG9yIiwidHJhbnNwYXJlbnQiLCJpbnRlcnBvbGF0b3JzIiwiYm9vbGVhbiIsImZyb20iLCJ0byIsImZhY3RvciIsImMwIiwiYzEiLCJ2YWxpZCIsIm1peCIsImhleFN0cmluZyIsIm51bWJlciIsIkFuaW1hdGlvbiIsImNmZyIsInRhcmdldCIsInByb3AiLCJjdXJyZW50VmFsdWUiLCJfZm4iLCJfZWFzaW5nIiwiZWFzaW5nIiwibGluZWFyIiwiX3N0YXJ0IiwiZmxvb3IiLCJkZWxheSIsIl9sb29wIiwibG9vcCIsIl90YXJnZXQiLCJfcHJvcCIsIl9mcm9tIiwiX3RvIiwiX3Byb21pc2VzIiwiYWN0aXZlIiwidXBkYXRlIiwiZWxhcHNlZCIsInJlbWFpbiIsIndhaXQiLCJwcm9taXNlcyIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJyZXNvbHZlZCIsIm1ldGhvZCIsIm51bWJlcnMiLCJjb2xvcnMiLCJhbmltYXRpb25PcHRpb25zIiwiT2JqZWN0Iiwia2V5cyIsImFuaW1hdGlvbiIsImRlc2NyaWJlIiwiX2ZhbGxiYWNrIiwiX2luZGV4YWJsZSIsIl9zY3JpcHRhYmxlIiwibmFtZSIsInByb3BlcnRpZXMiLCJyZXNpemUiLCJzaG93IiwiYW5pbWF0aW9ucyIsInZpc2libGUiLCJoaWRlIiwiQW5pbWF0aW9ucyIsImNvbmZpZyIsIl9jaGFydCIsIl9wcm9wZXJ0aWVzIiwiY29uZmlndXJlIiwiYW5pbWF0ZWRQcm9wcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJrZXkiLCJvcHRpb24iLCJfYW5pbWF0ZU9wdGlvbnMiLCJ2YWx1ZXMiLCJuZXdPcHRpb25zIiwib3B0aW9ucyIsInJlc29sdmVUYXJnZXRPcHRpb25zIiwiX2NyZWF0ZUFuaW1hdGlvbnMiLCIkc2hhcmVkIiwiYXdhaXRBbGwiLCIkYW5pbWF0aW9ucyIsInRoZW4iLCJwcm9wcyIsImNoYXJBdCIsInZhbHVlIiwic2l6ZSIsImFzc2lnbiIsImFuaW0iLCJhbGwiLCJzY2FsZUNsaXAiLCJzY2FsZSIsImFsbG93ZWRPdmVyZmxvdyIsIm9wdHMiLCJyZXZlcnNlIiwiZW5kIiwiZGVmYXVsdENsaXAiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ0b0NsaXAiLCJkaXNhYmxlZCIsImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwiZmlsdGVyVmlzaWJsZSIsIm1ldGFzZXRzIiwiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsImlsZW4iLCJpbmRleCIsImFwcGx5U3RhY2siLCJzdGFjayIsImRzSW5kZXgiLCJzaW5nbGVNb2RlIiwibW9kZSIsImRhdGFzZXRJbmRleCIsIm90aGVyVmFsdWUiLCJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCJkYXRhIiwiYWRhdGEiLCJBcnJheSIsImlzU3RhY2tlZCIsIm1ldGEiLCJzdGFja2VkIiwiZ2V0U3RhY2tLZXkiLCJpbmRleFNjYWxlIiwidmFsdWVTY2FsZSIsImlkIiwiZ2V0VXNlckJvdW5kcyIsIm1pbkRlZmluZWQiLCJtYXhEZWZpbmVkIiwiTnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsImdldE9yQ3JlYXRlU3RhY2siLCJzdGFja3MiLCJzdGFja0tleSIsImluZGV4VmFsdWUiLCJzdWJTdGFjayIsImdldExhc3RJbmRleEluU3RhY2siLCJ2U2NhbGUiLCJwb3NpdGl2ZSIsImdldE1hdGNoaW5nVmlzaWJsZU1ldGFzIiwidXBkYXRlU3RhY2tzIiwiY29udHJvbGxlciIsInBhcnNlZCIsIl9jYWNoZWRNZXRhIiwiX3N0YWNrcyIsImlTY2FsZSIsImlBeGlzIiwiYXhpcyIsInZBeGlzIiwiaXRlbVN0YWNrcyIsIl90b3AiLCJfYm90dG9tIiwiZ2V0Rmlyc3RTY2FsZUlkIiwic2NhbGVzIiwiZmlsdGVyIiwic2hpZnQiLCJjcmVhdGVEYXRhc2V0Q29udGV4dCIsInBhcmVudCIsImRhdGFzZXQiLCJjcmVhdGVEYXRhQ29udGV4dCIsImVsZW1lbnQiLCJkYXRhSW5kZXgiLCJyYXciLCJjbGVhclN0YWNrcyIsIl9wYXJzZWQiLCJpc0RpcmVjdFVwZGF0ZU1vZGUiLCJjbG9uZUlmTm90U2hhcmVkIiwiY2FjaGVkIiwic2hhcmVkIiwiY3JlYXRlU3RhY2siLCJjYW5TdGFjayIsImhpZGRlbiIsIl9zdGFja2VkIiwiRGF0YXNldENvbnRyb2xsZXIiLCJfY3R4IiwiY3R4IiwiX2NhY2hlZERhdGFPcHRzIiwiZ2V0TWV0YSIsIl90eXBlIiwiX3BhcnNpbmciLCJfZGF0YSIsIl9vYmplY3REYXRhIiwiX3NoYXJlZE9wdGlvbnMiLCJfZHJhd1N0YXJ0IiwiX2RyYXdDb3VudCIsImVuYWJsZU9wdGlvblNoYXJpbmciLCJzdXBwb3J0c0RlY2ltYXRpb24iLCIkY29udGV4dCIsIl9zeW5jTGlzdCIsImluaXRpYWxpemUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJ1cGRhdGVJbmRleCIsImdldERhdGFzZXQiLCJjaG9vc2VJZCIsInhpZCIsInhBeGlzSUQiLCJ5aWQiLCJ5QXhpc0lEIiwicmlkIiwickF4aXNJRCIsImluZGV4QXhpcyIsImlpZCIsImlBeGlzSUQiLCJ2aWQiLCJ2QXhpc0lEIiwiZ2V0U2NhbGVGb3JJZCIsInJTY2FsZSIsImRhdGFzZXRzIiwiZ2V0RGF0YXNldE1ldGEiLCJzY2FsZUlEIiwiX2dldE90aGVyU2NhbGUiLCJyZXNldCIsIl9kZXN0cm95IiwiX2RhdGFDaGVjayIsImlzRXh0ZW5zaWJsZSIsImRhdGFzZXRFbGVtZW50VHlwZSIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsInJlc2V0TmV3RWxlbWVudHMiLCJzdGFja0NoYW5nZWQiLCJvbGRTdGFja2VkIiwiX3Jlc3luY0VsZW1lbnRzIiwic2NvcGVLZXlzIiwiZGF0YXNldFNjb3BlS2V5cyIsInNjb3BlcyIsImdldE9wdGlvblNjb3BlcyIsImNyZWF0ZVJlc29sdmVyIiwiZ2V0Q29udGV4dCIsInBhcnNpbmciLCJwYXJzZSIsImNvdW50Iiwic29ydGVkIiwiX3NvcnRlZCIsInByZXYiLCJwYXJzZUFycmF5RGF0YSIsInBhcnNlT2JqZWN0RGF0YSIsInBhcnNlUHJpbWl0aXZlRGF0YSIsImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwibGFiZWxzIiwiZ2V0TGFiZWxzIiwic2luZ2xlU2NhbGUiLCJ4QXhpc0tleSIsInlBeGlzS2V5IiwiZ2V0UGFyc2VkIiwiZ2V0RGF0YUVsZW1lbnQiLCJ1cGRhdGVSYW5nZUZyb21QYXJzZWQiLCJyYW5nZSIsInBhcnNlZFZhbHVlIiwiTmFOIiwiZ2V0TWluTWF4Iiwib3RoZXJTY2FsZSIsIm90aGVyTWluIiwib3RoZXJNYXgiLCJfc2tpcCIsImdldEFsbFBhcnNlZFZhbHVlcyIsImdldE1heE92ZXJmbG93IiwiZ2V0TGFiZWxBbmRWYWx1ZSIsImxhYmVsIiwiZ2V0TGFiZWxGb3JWYWx1ZSIsIl9jbGlwIiwiY2xpcCIsImVsZW1lbnRzIiwiYXJlYSIsImNoYXJ0QXJlYSIsImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwiZ2V0U3R5bGUiLCJyZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zIiwicmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsImNvbnRleHQiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZGF0YUVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGUiLCJjYWNoZSIsImNhY2hlS2V5Iiwic2hhcmluZyIsImRhdGFzZXRFbGVtZW50U2NvcGVLZXlzIiwicHJlZml4ZXMiLCJuYW1lcyIsInJlc29sdmVOYW1lZE9wdGlvbnMiLCJmcmVlemUiLCJfcmVzb2x2ZUFuaW1hdGlvbnMiLCJ0cmFuc2l0aW9uIiwiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsIl9jYWNoZWFibGUiLCJnZXRTaGFyZWRPcHRpb25zIiwiaW5jbHVkZU9wdGlvbnMiLCJzaGFyZWRPcHRpb25zIiwiX2FuaW1hdGlvbnNEaXNhYmxlZCIsIl9nZXRTaGFyZWRPcHRpb25zIiwiZmlyc3RPcHRzIiwicHJldmlvdXNseVNoYXJlZE9wdGlvbnMiLCJ1cGRhdGVTaGFyZWRPcHRpb25zIiwidXBkYXRlRWxlbWVudCIsIl9zZXRTdHlsZSIsInJlbW92ZUhvdmVyU3R5bGUiLCJzZXRIb3ZlclN0eWxlIiwiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlIiwiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwiYXJnMSIsImFyZzIiLCJudW1NZXRhIiwibnVtRGF0YSIsIl9pbnNlcnRFbGVtZW50cyIsIl9yZW1vdmVFbGVtZW50cyIsIm1vdmUiLCJhcnIiLCJ1cGRhdGVFbGVtZW50cyIsInJlbW92ZWQiLCJzcGxpY2UiLCJfc3luYyIsImFyZ3MiLCJfZGF0YUNoYW5nZXMiLCJfb25EYXRhUHVzaCIsImFyZ3VtZW50cyIsIl9vbkRhdGFQb3AiLCJfb25EYXRhU2hpZnQiLCJfb25EYXRhU3BsaWNlIiwibmV3Q291bnQiLCJfb25EYXRhVW5zaGlmdCIsInByb3RvdHlwZSIsImdldEFsbFNjYWxlVmFsdWVzIiwiX2NhY2hlIiwiJGJhciIsInZpc2libGVNZXRhcyIsImNvbmNhdCIsInNvcnQiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsIl9sZW5ndGgiLCJjdXJyIiwidXBkYXRlTWluQW5kUHJldiIsImFicyIsImdldFBpeGVsRm9yVmFsdWUiLCJ0aWNrcyIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsInJ1bGVyIiwic3RhY2tDb3VudCIsInRoaWNrbmVzcyIsImJhclRoaWNrbmVzcyIsInJhdGlvIiwiY2F0ZWdvcnlQZXJjZW50YWdlIiwiYmFyUGVyY2VudGFnZSIsImNodW5rIiwicGl4ZWxzIiwiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsIm5leHQiLCJwZXJjZW50IiwicGFyc2VGbG9hdEJhciIsImVudHJ5Iiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiYmFyU3RhcnQiLCJiYXJFbmQiLCJfY3VzdG9tIiwicGFyc2VWYWx1ZSIsInBhcnNlQXJyYXlPclByaW1pdGl2ZSIsImlzRmxvYXRCYXIiLCJjdXN0b20iLCJiYXJTaWduIiwiYWN0dWFsQmFzZSIsImlzSG9yaXpvbnRhbCIsImJvcmRlclByb3BzIiwiaG9yaXpvbnRhbCIsImJhc2UiLCJzZXRCb3JkZXJTa2lwcGVkIiwiZWRnZSIsImJvcmRlclNraXBwZWQiLCJlbmFibGVCb3JkZXJSYWRpdXMiLCJwYXJzZUVkZ2UiLCJzd2FwIiwic3RhcnRFbmQiLCJvcmlnIiwidjEiLCJ2MiIsInNldEluZmxhdGVBbW91bnQiLCJpbmZsYXRlQW1vdW50IiwiQmFyQ29udHJvbGxlciIsImlBeGlzS2V5IiwidkF4aXNLZXkiLCJvYmoiLCJiYXJzIiwiZ2V0QmFzZVBpeGVsIiwiX2dldFJ1bGVyIiwidnBpeGVscyIsImhlYWQiLCJfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMiLCJpcGl4ZWxzIiwiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiY2VudGVyIiwiaGVpZ2h0Iiwid2lkdGgiLCJfZ2V0U3RhY2tzIiwibGFzdCIsImdyb3VwZWQiLCJza2lwTnVsbCIsInZhbCIsImlzTmFOIiwiaW5kZXhPZiIsIl9nZXRTdGFja0NvdW50IiwiX2dldFN0YWNrSW5kZXgiLCJfc3RhcnRQaXhlbCIsIl9lbmRQaXhlbCIsImJhc2VWYWx1ZSIsIm1pbkJhckxlbmd0aCIsImZsb2F0aW5nIiwiZ2V0RGF0YVZpc2liaWxpdHkiLCJzdGFydFBpeGVsIiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwiZW5kUGl4ZWwiLCJoYWxmR3JpZCIsImdldExpbmVXaWR0aEZvclZhbHVlIiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJzdGFja0luZGV4IiwicmVjdHMiLCJfaW5kZXhfIiwib2Zmc2V0IiwiZ3JpZCIsIl92YWx1ZV8iLCJiZWdpbkF0WmVybyIsIkJ1YmJsZUNvbnRyb2xsZXIiLCJyYWRpdXMiLCJwb2ludHMiLCJwb2ludCIsImlQaXhlbCIsInZQaXhlbCIsInNraXAiLCJwbHVnaW5zIiwidG9vbHRpcCIsInRpdGxlIiwiZ2V0UmF0aW9BbmRPZmZzZXQiLCJyb3RhdGlvbiIsImNpcmN1bWZlcmVuY2UiLCJjdXRvdXQiLCJyYXRpb1giLCJyYXRpb1kiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0WCIsImNvcyIsInN0YXJ0WSIsInNpbiIsImVuZFgiLCJlbmRZIiwiY2FsY01heCIsImFuZ2xlIiwiY2FsY01pbiIsIm1heFgiLCJtYXhZIiwibWluWCIsIm1pblkiLCJEb3VnaG51dENvbnRyb2xsZXIiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiZ2V0dGVyIiwiX2dldFJvdGF0aW9uIiwiX2dldENpcmN1bWZlcmVuY2UiLCJfZ2V0Um90YXRpb25FeHRlbnRzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImFyY3MiLCJzcGFjaW5nIiwiZ2V0TWF4Qm9yZGVyV2lkdGgiLCJnZXRNYXhPZmZzZXQiLCJtYXhTaXplIiwiY2hhcnRXZWlnaHQiLCJfZ2V0UmluZ1dlaWdodCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWF4UmFkaXVzIiwicmFkaXVzTGVuZ3RoIiwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCJ0b3RhbCIsImNhbGN1bGF0ZVRvdGFsIiwiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCJfY2lyY3VtZmVyZW5jZSIsImFuaW1hdGVSb3RhdGUiLCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiYW5pbWF0ZVNjYWxlIiwiYXJjIiwibWV0YURhdGEiLCJsb2NhbGUiLCJib3JkZXJBbGlnbiIsImJvcmRlcldpZHRoIiwiaG92ZXJCb3JkZXJXaWR0aCIsImhvdmVyT2Zmc2V0IiwicmluZ1dlaWdodE9mZnNldCIsIndlaWdodCIsImFzcGVjdFJhdGlvIiwibGVnZW5kIiwiZ2VuZXJhdGVMYWJlbHMiLCJwb2ludFN0eWxlIiwibWFwIiwic3R5bGUiLCJ0ZXh0IiwiZmlsbFN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwic3Ryb2tlU3R5bGUiLCJib3JkZXJDb2xvciIsImxpbmVXaWR0aCIsIm9uQ2xpY2siLCJsZWdlbmRJdGVtIiwidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImZvcm1hdHRlZFZhbHVlIiwic2xpY2UiLCJMaW5lQ29udHJvbGxlciIsImxpbmUiLCJfZGF0YXNldCIsImFuaW1hdGlvbnNEaXNhYmxlZCIsIl9kYXRhc2V0SW5kZXgiLCJfZGVjaW1hdGVkIiwic2hvd0xpbmUiLCJzZWdtZW50IiwiYW5pbWF0ZWQiLCJzcGFuR2FwcyIsIm1heEdhcExlbmd0aCIsImRpcmVjdFVwZGF0ZSIsInByZXZQYXJzZWQiLCJudWxsRGF0YSIsImJvcmRlciIsImZpcnN0UG9pbnQiLCJsYXN0UG9pbnQiLCJ1cGRhdGVDb250cm9sUG9pbnRzIiwiUG9sYXJBcmVhQ29udHJvbGxlciIsImJpbmQiLCJfdXBkYXRlUmFkaXVzIiwibWluU2l6ZSIsImN1dG91dFBlcmNlbnRhZ2UiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwieENlbnRlciIsInlDZW50ZXIiLCJkYXRhc2V0U3RhcnRBbmdsZSIsImdldEluZGV4QW5nbGUiLCJkZWZhdWx0QW5nbGUiLCJjb3VudFZpc2libGVFbGVtZW50cyIsIl9jb21wdXRlQW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsImFuZ2xlTGluZXMiLCJkaXNwbGF5IiwiY2lyY3VsYXIiLCJwb2ludExhYmVscyIsIlBpZUNvbnRyb2xsZXIiLCJSYWRhckNvbnRyb2xsZXIiLCJfZnVsbExvb3AiLCJwb2ludFBvc2l0aW9uIiwiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwiZmlsbCIsIkVsZW1lbnQiLCJ0b29sdGlwUG9zaXRpb24iLCJ1c2VGaW5hbFBvc2l0aW9uIiwiZ2V0UHJvcHMiLCJoYXNWYWx1ZSIsImZpbmFsIiwicmV0IiwiZGVmYXVsdFJvdXRlcyIsImZvcm1hdHRlcnMiLCJudW1lcmljIiwidGlja1ZhbHVlIiwibm90YXRpb24iLCJkZWx0YSIsIm1heFRpY2siLCJjYWxjdWxhdGVEZWx0YSIsImxvZ0RlbHRhIiwibnVtRGVjaW1hbCIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImZvcm1hdCIsImxvZ2FyaXRobWljIiwicG93IiwiVGlja3MiLCJib3VuZHMiLCJncmFjZSIsImRyYXdCb3JkZXIiLCJkcmF3T25DaGFydEFyZWEiLCJkcmF3VGlja3MiLCJ0aWNrTGVuZ3RoIiwidGlja1dpZHRoIiwidGlja0NvbG9yIiwiYm9yZGVyRGFzaCIsImJvcmRlckRhc2hPZmZzZXQiLCJwYWRkaW5nIiwibWluUm90YXRpb24iLCJtYXhSb3RhdGlvbiIsIm1pcnJvciIsInRleHRTdHJva2VXaWR0aCIsInRleHRTdHJva2VDb2xvciIsImF1dG9Ta2lwIiwiYXV0b1NraXBQYWRkaW5nIiwibGFiZWxPZmZzZXQiLCJtaW5vciIsIm1ham9yIiwiYWxpZ24iLCJjcm9zc0FsaWduIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nIiwicm91dGUiLCJzdGFydHNXaXRoIiwidGlja09wdHMiLCJ0aWNrc0xpbWl0IiwibWF4VGlja3NMaW1pdCIsImRldGVybWluZU1heFRpY2tzIiwibWFqb3JJbmRpY2VzIiwiZW5hYmxlZCIsImdldE1ham9ySW5kaWNlcyIsIm51bU1ham9ySW5kaWNlcyIsImZpcnN0IiwibmV3VGlja3MiLCJza2lwTWFqb3JzIiwiY2FsY3VsYXRlU3BhY2luZyIsImF2Z01ham9yU3BhY2luZyIsInJvdW5kIiwiX3RpY2tTaXplIiwibWF4U2NhbGUiLCJtYXhDaGFydCIsIl9tYXhMZW5ndGgiLCJldmVuTWFqb3JTcGFjaW5nIiwiZ2V0RXZlblNwYWNpbmciLCJmYWN0b3JzIiwicmVzdWx0IiwiY2VpbCIsIm1ham9yU3RhcnQiLCJtYWpvckVuZCIsImxlbiIsImRpZmYiLCJyZXZlcnNlQWxpZ24iLCJvZmZzZXRGcm9tRWRnZSIsInNhbXBsZSIsIm51bUl0ZW1zIiwiaW5jcmVtZW50IiwiZ2V0UGl4ZWxGb3JHcmlkTGluZSIsIm9mZnNldEdyaWRMaW5lcyIsInZhbGlkSW5kZXgiLCJlcHNpbG9uIiwibGluZVZhbHVlIiwiZ2FyYmFnZUNvbGxlY3QiLCJjYWNoZXMiLCJnYyIsImdjTGVuIiwiZ2V0VGlja01hcmtMZW5ndGgiLCJnZXRUaXRsZUhlaWdodCIsImZhbGxiYWNrIiwiZm9udCIsImxpbmVzIiwibGluZUhlaWdodCIsImNyZWF0ZVNjYWxlQ29udGV4dCIsImNyZWF0ZVRpY2tDb250ZXh0IiwidGl0bGVBbGlnbiIsInBvc2l0aW9uIiwidGl0bGVBcmdzIiwidGl0bGVYIiwidGl0bGVZIiwicG9zaXRpb25BeGlzSUQiLCJTY2FsZSIsIl9tYXJnaW5zIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImxhYmVsUm90YXRpb24iLCJfcmFuZ2UiLCJfZ3JpZExpbmVJdGVtcyIsIl9sYWJlbEl0ZW1zIiwiX2xhYmVsU2l6ZXMiLCJfbG9uZ2VzdFRleHRDYWNoZSIsIl9yZXZlcnNlUGl4ZWxzIiwiX3VzZXJNYXgiLCJfdXNlck1pbiIsIl9zdWdnZXN0ZWRNYXgiLCJfc3VnZ2VzdGVkTWluIiwiX3RpY2tzTGVuZ3RoIiwiX2JvcmRlclZhbHVlIiwiX2RhdGFMaW1pdHNDYWNoZWQiLCJpbml0Iiwic2V0Q29udGV4dCIsInN1Z2dlc3RlZE1pbiIsInN1Z2dlc3RlZE1heCIsIm1ldGFzIiwiZ2V0UGFkZGluZyIsImdldFRpY2tzIiwieExhYmVscyIsInlMYWJlbHMiLCJiZWZvcmVMYXlvdXQiLCJiZWZvcmVVcGRhdGUiLCJtYXJnaW5zIiwic2FtcGxlU2l6ZSIsImJlZm9yZVNldERpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwiYWZ0ZXJTZXREaW1lbnNpb25zIiwiYmVmb3JlRGF0YUxpbWl0cyIsImRldGVybWluZURhdGFMaW1pdHMiLCJhZnRlckRhdGFMaW1pdHMiLCJiZWZvcmVCdWlsZFRpY2tzIiwiYnVpbGRUaWNrcyIsImFmdGVyQnVpbGRUaWNrcyIsInNhbXBsaW5nRW5hYmxlZCIsIl9jb252ZXJ0VGlja3NUb0xhYmVscyIsImJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwic291cmNlIiwiYWZ0ZXJBdXRvU2tpcCIsImJlZm9yZUZpdCIsImZpdCIsImFmdGVyRml0IiwiYWZ0ZXJVcGRhdGUiLCJyZXZlcnNlUGl4ZWxzIiwiX2FsaWduVG9QaXhlbHMiLCJhbGlnblRvUGl4ZWxzIiwiX2NhbGxIb29rcyIsIm5vdGlmeVBsdWdpbnMiLCJiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJnZW5lcmF0ZVRpY2tMYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsIm51bVRpY2tzIiwibWF4TGFiZWxEaWFnb25hbCIsIl9pc1Zpc2libGUiLCJsYWJlbFNpemVzIiwiX2dldExhYmVsU2l6ZXMiLCJtYXhMYWJlbFdpZHRoIiwid2lkZXN0IiwibWF4TGFiZWxIZWlnaHQiLCJoaWdoZXN0Iiwic3FydCIsImFzaW4iLCJ0aXRsZU9wdHMiLCJncmlkT3B0cyIsInRpdGxlSGVpZ2h0IiwidGlja1BhZGRpbmciLCJhbmdsZVJhZGlhbnMiLCJsYWJlbEhlaWdodCIsImxhYmVsV2lkdGgiLCJfY2FsY3VsYXRlUGFkZGluZyIsIl9oYW5kbGVNYXJnaW5zIiwiaXNSb3RhdGVkIiwibGFiZWxzQmVsb3dUaWNrcyIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImlzRnVsbFNpemUiLCJmdWxsU2l6ZSIsIl9jb21wdXRlTGFiZWxTaXplcyIsIndpZHRocyIsImhlaWdodHMiLCJ3aWRlc3RMYWJlbFNpemUiLCJoaWdoZXN0TGFiZWxTaXplIiwiamxlbiIsInRpY2tGb250IiwiZm9udFN0cmluZyIsIm5lc3RlZExhYmVsIiwiX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMiLCJzdHJpbmciLCJ2YWx1ZUF0IiwiaWR4IiwiZ2V0VmFsdWVGb3JQaXhlbCIsInBpeGVsIiwiZGVjaW1hbCIsImdldERlY2ltYWxGb3JQaXhlbCIsImdldEJhc2VWYWx1ZSIsIm9wdGlvblRpY2tzIiwicm90IiwiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwidGlja3NMZW5ndGgiLCJ0bCIsImJvcmRlck9wdHMiLCJheGlzV2lkdGgiLCJheGlzSGFsZldpZHRoIiwiYWxpZ25Cb3JkZXJWYWx1ZSIsImJvcmRlclZhbHVlIiwiYWxpZ25lZExpbmVWYWx1ZSIsInR4MSIsInR5MSIsInR4MiIsInR5MiIsIngxIiwieTEiLCJ4MiIsInkyIiwibGltaXQiLCJzdGVwIiwib3B0c0F0SW5kZXgiLCJsaW5lQ29sb3IiLCJ0aWNrQm9yZGVyRGFzaCIsInRpY2tCb3JkZXJEYXNoT2Zmc2V0IiwiX2NvbXB1dGVMYWJlbEl0ZW1zIiwidGlja0FuZFBhZGRpbmciLCJoVGlja0FuZFBhZGRpbmciLCJ0ZXh0QWxpZ24iLCJsaW5lQ291bnQiLCJ0ZXh0T2Zmc2V0IiwidGV4dEJhc2VsaW5lIiwiX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQiLCJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsImhhbGZDb3VudCIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJ0aWNrVGV4dEFsaWduIiwiYmFja2Ryb3AiLCJsYWJlbFBhZGRpbmciLCJ0cmFuc2xhdGlvbiIsIl9jb21wdXRlTGFiZWxBcmVhIiwiZHJhd0JhY2tncm91bmQiLCJzYXZlIiwiZmlsbFJlY3QiLCJyZXN0b3JlIiwiZmluZEluZGV4IiwiZHJhd0dyaWQiLCJkcmF3TGluZSIsInAxIiwicDIiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwibGFzdExpbmVXaWR0aCIsImRyYXdMYWJlbHMiLCJkcmF3VGl0bGUiLCJfbGF5ZXJzIiwidHoiLCJneiIsImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCJheGlzSUQiLCJfbWF4RGlnaXRzIiwiZm9udFNpemUiLCJUeXBlZFJlZ2lzdHJ5Iiwic2NvcGUiLCJvdmVycmlkZSIsImNyZWF0ZSIsImlzRm9yVHlwZSIsImlzUHJvdG90eXBlT2YiLCJyZWdpc3RlciIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJwYXJlbnRTY29wZSIsImlzSUNoYXJ0Q29tcG9uZW50IiwiRXJyb3IiLCJyZWdpc3RlckRlZmF1bHRzIiwidW5yZWdpc3RlciIsIml0ZW1EZWZhdWx0cyIsInJvdXRlRGVmYXVsdHMiLCJyb3V0ZXMiLCJwcm9wZXJ0eSIsInByb3BlcnR5UGFydHMiLCJzcGxpdCIsInNvdXJjZU5hbWUiLCJzb3VyY2VTY29wZSIsImpvaW4iLCJwYXJ0cyIsInRhcmdldE5hbWUiLCJ0YXJnZXRTY29wZSIsIlJlZ2lzdHJ5IiwiY29udHJvbGxlcnMiLCJfdHlwZWRSZWdpc3RyaWVzIiwiX2VhY2giLCJhZGRDb250cm9sbGVycyIsImFkZFBsdWdpbnMiLCJhZGRTY2FsZXMiLCJnZXRDb250cm9sbGVyIiwiX2dldCIsImdldEVsZW1lbnQiLCJnZXRQbHVnaW4iLCJnZXRTY2FsZSIsInJlbW92ZUNvbnRyb2xsZXJzIiwicmVtb3ZlRWxlbWVudHMiLCJyZW1vdmVQbHVnaW5zIiwicmVtb3ZlU2NhbGVzIiwidHlwZWRSZWdpc3RyeSIsImFyZyIsInJlZyIsIl9nZXRSZWdpc3RyeUZvclR5cGUiLCJfZXhlYyIsIml0ZW1SZWciLCJyZWdpc3RyeSIsImNvbXBvbmVudCIsImNhbWVsTWV0aG9kIiwiU2NhdHRlckNvbnRyb2xsZXIiLCJpbnRlcmFjdGlvbiIsIl9fcHJvdG9fXyIsImFic3RyYWN0IiwiRGF0ZUFkYXB0ZXIiLCJjaGFydE9wdGlvbnMiLCJmb3JtYXRzIiwidGltZXN0YW1wIiwiYW1vdW50IiwidW5pdCIsInN0YXJ0T2YiLCJ3ZWVrZGF5IiwiZW5kT2YiLCJtZW1iZXJzIiwiYWRhcHRlcnMiLCJfZGF0ZSIsImJpbmFyeVNlYXJjaCIsIm1ldGFzZXQiLCJpbnRlcnNlY3QiLCJsb29rdXBNZXRob2QiLCJlbCIsImdldFJhbmdlIiwibG8iLCJoaSIsImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsImhhbmRsZXIiLCJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCJ1c2VYIiwidXNlWSIsInB0MSIsInB0MiIsImRlbHRhWCIsImRlbHRhWSIsImdldEludGVyc2VjdEl0ZW1zIiwiaW5jbHVkZUludmlzaWJsZSIsImlzUG9pbnRJbkFyZWEiLCJldmFsdWF0aW9uRnVuYyIsImluUmFuZ2UiLCJnZXROZWFyZXN0UmFkaWFsSXRlbXMiLCJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiZ2V0Q2VudGVyUG9pbnQiLCJwb2ludEluQXJlYSIsImRpc3RhbmNlIiwiZ2V0TmVhcmVzdEl0ZW1zIiwiZ2V0QXhpc0l0ZW1zIiwicmFuZ2VNZXRob2QiLCJpbnRlcnNlY3RzSXRlbSIsIkludGVyYWN0aW9uIiwibW9kZXMiLCJuZWFyZXN0IiwiU1RBVElDX1BPU0lUSU9OUyIsImZpbHRlckJ5UG9zaXRpb24iLCJhcnJheSIsInBvcyIsImZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyIsImJveCIsInNvcnRCeVdlaWdodCIsInYwIiwid3JhcEJveGVzIiwiYm94ZXMiLCJsYXlvdXRCb3hlcyIsInN0YWNrV2VpZ2h0IiwiYnVpbGRTdGFja3MiLCJsYXlvdXRzIiwid3JhcCIsImluY2x1ZGVzIiwiX3N0YWNrIiwicGxhY2VkIiwic2V0TGF5b3V0RGltcyIsInBhcmFtcyIsInZCb3hNYXhXaWR0aCIsImhCb3hNYXhIZWlnaHQiLCJsYXlvdXQiLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsImJ1aWxkTGF5b3V0Qm94ZXMiLCJjZW50ZXJIb3Jpem9udGFsIiwiY2VudGVyVmVydGljYWwiLCJsZWZ0QW5kVG9wIiwicmlnaHRBbmRCb3R0b20iLCJ2ZXJ0aWNhbCIsImdldENvbWJpbmVkTWF4IiwibWF4UGFkZGluZyIsInVwZGF0ZU1heFBhZGRpbmciLCJib3hQYWRkaW5nIiwidXBkYXRlRGltcyIsIm5ld1dpZHRoIiwib3V0ZXJXaWR0aCIsIm5ld0hlaWdodCIsIm91dGVySGVpZ2h0Iiwid2lkdGhDaGFuZ2VkIiwiaGVpZ2h0Q2hhbmdlZCIsInNhbWUiLCJvdGhlciIsImhhbmRsZU1heFBhZGRpbmciLCJ1cGRhdGVQb3MiLCJjaGFuZ2UiLCJnZXRNYXJnaW5zIiwibWFyZ2luRm9yUG9zaXRpb25zIiwicG9zaXRpb25zIiwibWFyZ2luIiwiZml0Qm94ZXMiLCJyZWZpdEJveGVzIiwicmVmaXQiLCJjaGFuZ2VkIiwic2V0Qm94RGltcyIsInBsYWNlQm94ZXMiLCJ1c2VyUGFkZGluZyIsImF1dG9QYWRkaW5nIiwiYWRkQm94IiwicmVtb3ZlQm94IiwibGF5b3V0SXRlbSIsIm1pblBhZGRpbmciLCJ2ZXJ0aWNhbEJveGVzIiwiaG9yaXpvbnRhbEJveGVzIiwidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCJCYXNlUGxhdGZvcm0iLCJhY3F1aXJlQ29udGV4dCIsImNhbnZhcyIsInJlbGVhc2VDb250ZXh0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldERldmljZVBpeGVsUmF0aW8iLCJpc0F0dGFjaGVkIiwidXBkYXRlQ29uZmlnIiwiQmFzaWNQbGF0Zm9ybSIsIkVYUEFORE9fS0VZIiwiRVZFTlRfVFlQRVMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm91dCIsImlzTnVsbE9yRW1wdHkiLCJpbml0Q2FudmFzIiwicmVuZGVySGVpZ2h0IiwiZ2V0QXR0cmlidXRlIiwicmVuZGVyV2lkdGgiLCJib3hTaXppbmciLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiYWRkTGlzdGVuZXIiLCJub2RlIiwicmVtb3ZlTGlzdGVuZXIiLCJmcm9tTmF0aXZlRXZlbnQiLCJuYXRpdmUiLCJub2RlTGlzdENvbnRhaW5zIiwibm9kZUxpc3QiLCJjb250YWlucyIsImNyZWF0ZUF0dGFjaE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiZW50cmllcyIsInRyaWdnZXIiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwib2JzZXJ2ZSIsImRvY3VtZW50IiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImNyZWF0ZURldGFjaE9ic2VydmVyIiwiZHJwTGlzdGVuaW5nQ2hhcnRzIiwib2xkRGV2aWNlUGl4ZWxSYXRpbyIsIm9uV2luZG93UmVzaXplIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwibGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCJ1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCJjb250YWluZXIiLCJjbGllbnRXaWR0aCIsIlJlc2l6ZU9ic2VydmVyIiwiY29udGVudFJlY3QiLCJyZWxlYXNlT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiY3JlYXRlUHJveHlBbmRMaXN0ZW4iLCJwcm94eSIsIkRvbVBsYXRmb3JtIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicHJveGllcyIsIiRwcm94aWVzIiwiaGFuZGxlcnMiLCJhdHRhY2giLCJkZXRhY2giLCJpc0Nvbm5lY3RlZCIsIl9kZXRlY3RQbGF0Zm9ybSIsIk9mZnNjcmVlbkNhbnZhcyIsIlBsdWdpblNlcnZpY2UiLCJfaW5pdCIsIm5vdGlmeSIsImhvb2siLCJfY3JlYXRlRGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwicGx1Z2luIiwiY2FuY2VsYWJsZSIsImludmFsaWRhdGUiLCJfb2xkQ2FjaGUiLCJfbm90aWZ5U3RhdGVDaGFuZ2VzIiwiYWxsUGx1Z2lucyIsImNyZWF0ZURlc2NyaXB0b3JzIiwicHJldmlvdXNEZXNjcmlwdG9ycyIsInNvbWUiLCJsb2NhbElkcyIsImxvY2FsIiwiZ2V0T3B0cyIsInBsdWdpbk9wdHMiLCJwbHVnaW5TY29wZUtleXMiLCJzY3JpcHRhYmxlIiwiaW5kZXhhYmxlIiwiYWxsS2V5cyIsImdldEluZGV4QXhpcyIsImRhdGFzZXREZWZhdWx0cyIsImRhdGFzZXRPcHRpb25zIiwiZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRCIsImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCJheGlzRnJvbVBvc2l0aW9uIiwiZGV0ZXJtaW5lQXhpcyIsInNjYWxlT3B0aW9ucyIsInRvTG93ZXJDYXNlIiwibWVyZ2VTY2FsZUNvbmZpZyIsImNoYXJ0RGVmYXVsdHMiLCJjb25maWdTY2FsZXMiLCJjaGFydEluZGV4QXhpcyIsImZpcnN0SURzIiwic2NhbGVDb25mIiwiY29uc29sZSIsImVycm9yIiwiX3Byb3h5Iiwid2FybiIsImRlZmF1bHRJZCIsImRlZmF1bHRTY2FsZU9wdGlvbnMiLCJkZWZhdWx0SUQiLCJpbml0T3B0aW9ucyIsImluaXREYXRhIiwiaW5pdENvbmZpZyIsImtleUNhY2hlIiwia2V5c0NhY2hlZCIsIlNldCIsImNhY2hlZEtleXMiLCJnZW5lcmF0ZSIsImFkZElmRm91bmQiLCJDb25maWciLCJfY29uZmlnIiwiX3Njb3BlQ2FjaGUiLCJfcmVzb2x2ZXJDYWNoZSIsInBsYXRmb3JtIiwiY2xlYXJDYWNoZSIsImNsZWFyIiwiZGF0YXNldFR5cGUiLCJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwiX2NhY2hlZFNjb3BlcyIsIm1haW5TY29wZSIsInJlc2V0Q2FjaGUiLCJrZXlMaXN0cyIsImNoYXJ0T3B0aW9uU2NvcGVzIiwicmVzb2x2ZXIiLCJzdWJQcmVmaXhlcyIsImdldFJlc29sdmVyIiwibmVlZENvbnRleHQiLCJzdWJSZXNvbHZlciIsImRlc2NyaXB0b3JEZWZhdWx0cyIsInJlc29sdmVyQ2FjaGUiLCJoYXNGdW5jdGlvbiIsImlzU2NyaXB0YWJsZSIsImlzSW5kZXhhYmxlIiwidmVyc2lvbiIsIktOT1dOX1BPU0lUSU9OUyIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29tcGFyZTJMZXZlbCIsImwxIiwibDIiLCJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsIm9uQ29tcGxldGUiLCJvbkFuaW1hdGlvblByb2dyZXNzIiwib25Qcm9ncmVzcyIsImdldENhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwiaW5zdGFuY2VzIiwiZ2V0Q2hhcnQiLCJtb3ZlTnVtZXJpY0tleXMiLCJpbnRLZXkiLCJkZXRlcm1pbmVMYXN0RXZlbnQiLCJsYXN0RXZlbnQiLCJpbkNoYXJ0QXJlYSIsImlzQ2xpY2siLCJDaGFydCIsInVzZXJDb25maWciLCJpbml0aWFsQ2FudmFzIiwiZXhpc3RpbmdDaGFydCIsIl9vcHRpb25zIiwiX2FzcGVjdFJhdGlvIiwiX21ldGFzZXRzIiwiX2xhc3RFdmVudCIsIl9saXN0ZW5lcnMiLCJfcmVzcG9uc2l2ZUxpc3RlbmVycyIsIl9zb3J0ZWRNZXRhc2V0cyIsIl9wbHVnaW5zIiwiX2hpZGRlbkluZGljZXMiLCJhdHRhY2hlZCIsIl9kb1Jlc2l6ZSIsInJlc2l6ZURlbGF5IiwiX2luaXRpYWxpemUiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwicmVzcG9uc2l2ZSIsImJpbmRFdmVudHMiLCJfcmVzaXplIiwiX3Jlc2l6ZUJlZm9yZURyYXciLCJuZXdTaXplIiwibmV3UmF0aW8iLCJvblJlc2l6ZSIsInJlbmRlciIsImVuc3VyZVNjYWxlc0hhdmVJRHMiLCJzY2FsZXNPcHRpb25zIiwiYXhpc09wdGlvbnMiLCJidWlsZE9yVXBkYXRlU2NhbGVzIiwic2NhbGVPcHRzIiwidXBkYXRlZCIsImlzUmFkaWFsIiwiZHBvc2l0aW9uIiwiZHR5cGUiLCJzY2FsZVR5cGUiLCJzY2FsZUNsYXNzIiwiaGFzVXBkYXRlZCIsIl91cGRhdGVNZXRhc2V0cyIsIl9kZXN0cm95RGF0YXNldE1ldGEiLCJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsIm9yZGVyIiwiQ29udHJvbGxlckNsYXNzIiwiX3Jlc2V0RWxlbWVudHMiLCJhbmltc0Rpc2FibGVkIiwiX3VwZGF0ZVNjYWxlcyIsIl9jaGVja0V2ZW50QmluZGluZ3MiLCJfdXBkYXRlSGlkZGVuSW5kaWNlcyIsIl9taW5QYWRkaW5nIiwiX3VwZGF0ZUxheW91dCIsIl91cGRhdGVEYXRhc2V0cyIsIl9ldmVudEhhbmRsZXIiLCJfdXBkYXRlSG92ZXJTdHlsZXMiLCJleGlzdGluZ0V2ZW50cyIsIm5ld0V2ZW50cyIsImV2ZW50cyIsInVuYmluZEV2ZW50cyIsImNoYW5nZXMiLCJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwiZGF0YXNldENvdW50IiwibWFrZVNldCIsImNoYW5nZVNldCIsIm5vQXJlYSIsIl9pZHgiLCJfdXBkYXRlRGF0YXNldCIsImxheWVycyIsIl9kcmF3RGF0YXNldHMiLCJfZHJhd0RhdGFzZXQiLCJ1c2VDbGlwIiwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsInNldERhdGFzZXRWaXNpYmlsaXR5IiwiX3VwZGF0ZVZpc2liaWxpdHkiLCJfc3RvcCIsImRlc3Ryb3kiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiYmluZFVzZXJFdmVudHMiLCJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsIl9hZGQiLCJfcmVtb3ZlIiwiZGV0YWNoZWQiLCJ1cGRhdGVIb3ZlclN0eWxlIiwicHJlZml4IiwiZ2V0QWN0aXZlRWxlbWVudHMiLCJzZXRBY3RpdmVFbGVtZW50cyIsImFjdGl2ZUVsZW1lbnRzIiwibGFzdEFjdGl2ZSIsInJlcGxheSIsImhvdmVyT3B0aW9ucyIsImhvdmVyIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJldmVudEZpbHRlciIsIl9oYW5kbGVFdmVudCIsIl9nZXRBY3RpdmVFbGVtZW50cyIsIm9uSG92ZXIiLCJpbnZhbGlkYXRlUGx1Z2lucyIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY2xpcEFyYyIsInBpeGVsTWFyZ2luIiwiYW5nbGVNYXJnaW4iLCJjbG9zZVBhdGgiLCJ0b1JhZGl1c0Nvcm5lcnMiLCJwYXJzZUJvcmRlclJhZGl1cyQxIiwiYW5nbGVEZWx0YSIsImJvcmRlclJhZGl1cyIsImhhbGZUaGlja25lc3MiLCJpbm5lckxpbWl0IiwiY29tcHV0ZU91dGVyTGltaXQiLCJvdXRlckFyY0xpbWl0Iiwib3V0ZXJTdGFydCIsIm91dGVyRW5kIiwiaW5uZXJTdGFydCIsImlubmVyRW5kIiwiclRoZXRhVG9YWSIsInRoZXRhIiwicGF0aEFyYyIsImlubmVyUiIsInNwYWNpbmdPZmZzZXQiLCJhbHBoYSIsIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCJhdk5vZ1NwYWNpbmdSYWRpdXMiLCJhZGp1c3RlZEFuZ2xlIiwiYmV0YSIsImFuZ2xlT2Zmc2V0Iiwib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwicENlbnRlciIsInA0IiwicDgiLCJvdXRlclN0YXJ0WCIsIm91dGVyU3RhcnRZIiwib3V0ZXJFbmRYIiwib3V0ZXJFbmRZIiwiZHJhd0FyYyIsImZ1bGxDaXJjbGVzIiwiZHJhd0Z1bGxDaXJjbGVCb3JkZXJzIiwiaW5uZXIiLCJib3JkZXJKb2luU3R5bGUiLCJsaW5lSm9pbiIsIkFyY0VsZW1lbnQiLCJjaGFydFgiLCJjaGFydFkiLCJyQWRqdXN0IiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJyYWRpdXNPZmZzZXQiLCJ0cmFuc2xhdGUiLCJzZXRTdHlsZSIsImxpbmVDYXAiLCJib3JkZXJDYXBTdHlsZSIsInByZXZpb3VzIiwiZ2V0TGluZU1ldGhvZCIsInN0ZXBwZWQiLCJ0ZW5zaW9uIiwiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsInBhdGhWYXJzIiwicGFyYW1zU3RhcnQiLCJwYXJhbXNFbmQiLCJzZWdtZW50U3RhcnQiLCJzZWdtZW50RW5kIiwib3V0c2lkZSIsInBhdGhTZWdtZW50IiwibGluZU1ldGhvZCIsImZhc3RQYXRoU2VnbWVudCIsImF2Z1giLCJjb3VudFgiLCJwcmV2WCIsImxhc3RZIiwicG9pbnRJbmRleCIsImRyYXdYIiwidHJ1bmNYIiwiX2dldFNlZ21lbnRNZXRob2QiLCJ1c2VGYXN0UGF0aCIsIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwic3Ryb2tlUGF0aFdpdGhDYWNoZSIsInBhdGgiLCJfcGF0aCIsIlBhdGgyRCIsInN0cm9rZVBhdGhEaXJlY3QiLCJzZWdtZW50cyIsInNlZ21lbnRNZXRob2QiLCJ1c2VQYXRoMkQiLCJMaW5lRWxlbWVudCIsIl9wb2ludHMiLCJfc2VnbWVudHMiLCJfcG9pbnRzVXBkYXRlZCIsImludGVycG9sYXRlIiwiX2ludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkIiwiY2FwQmV6aWVyUG9pbnRzIiwiaW5SYW5nZSQxIiwiaGl0UmFkaXVzIiwiUG9pbnRFbGVtZW50IiwibW91c2VYIiwibW91c2VZIiwiaW5YUmFuZ2UiLCJpbllSYW5nZSIsImhvdmVyUmFkaXVzIiwiZ2V0QmFyQm91bmRzIiwiYmFyIiwiaGFsZiIsInNraXBPckxpbWl0IiwicGFyc2VCb3JkZXJXaWR0aCIsIm1heFciLCJtYXhIIiwicGFyc2VCb3JkZXJSYWRpdXMiLCJtYXhSIiwiZW5hYmxlQm9yZGVyIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiYm91bmRpbmdSZWN0cyIsIm91dGVyIiwic2tpcFgiLCJza2lwWSIsInNraXBCb3RoIiwiaGFzUmFkaXVzIiwiYWRkTm9ybWFsUmVjdFBhdGgiLCJyZWN0IiwiaW5mbGF0ZVJlY3QiLCJyZWZSZWN0IiwiQmFyRWxlbWVudCIsImFkZFJlY3RQYXRoIiwibHR0YkRlY2ltYXRpb24iLCJzYW1wbGVzIiwiZGVjaW1hdGVkIiwiYnVja2V0V2lkdGgiLCJzYW1wbGVkSW5kZXgiLCJlbmRJbmRleCIsIm1heEFyZWFQb2ludCIsIm1heEFyZWEiLCJuZXh0QSIsImF2Z1kiLCJhdmdSYW5nZVN0YXJ0IiwiYXZnUmFuZ2VFbmQiLCJhdmdSYW5nZUxlbmd0aCIsInJhbmdlT2ZmcyIsInJhbmdlVG8iLCJwb2ludEF4IiwicG9pbnRBeSIsIm1pbk1heERlY2ltYXRpb24iLCJtaW5JbmRleCIsIm1heEluZGV4Iiwic3RhcnRJbmRleCIsInhNaW4iLCJ4TWF4IiwiZHgiLCJsYXN0SW5kZXgiLCJpbnRlcm1lZGlhdGVJbmRleDEiLCJpbnRlcm1lZGlhdGVJbmRleDIiLCJjbGVhbkRlY2ltYXRlZERhdGFzZXQiLCJkZWZpbmVQcm9wZXJ0eSIsImNsZWFuRGVjaW1hdGVkRGF0YSIsImdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkIiwicG9pbnRDb3VudCIsInBsdWdpbl9kZWNpbWF0aW9uIiwiYWxnb3JpdGhtIiwiYmVmb3JlRWxlbWVudHNVcGRhdGUiLCJ4QXhpcyIsInRocmVzaG9sZCIsImNvbmZpZ3VyYWJsZSIsInRwb2ludHMiLCJfZmluZFNlZ21lbnRFbmQiLCJfZ2V0Qm91bmRzIiwidGFyZ2V0U2VnbWVudHMiLCJ0Z3QiLCJzdWJCb3VuZHMiLCJmaWxsU291cmNlcyIsImZpbGxTb3VyY2UiLCJfZ2V0RWRnZSIsIl9wb2ludHNGcm9tU2VnbWVudHMiLCJib3VuZGFyeSIsImxpbmVQb2ludHMiLCJfY3JlYXRlQm91bmRhcnlMaW5lIiwiX3Nob3VsZEFwcGx5RmlsbCIsIl9yZXNvbHZlVGFyZ2V0Iiwic291cmNlcyIsInByb3BhZ2F0ZSIsInZpc2l0ZWQiLCJfZGVjb2RlRmlsbCIsInBhcnNlRmlsbE9wdGlvbiIsInBhcnNlRmxvYXQiLCJkZWNvZGVUYXJnZXRJbmRleCIsImZpcnN0Q2giLCJfZ2V0VGFyZ2V0UGl4ZWwiLCJfZ2V0VGFyZ2V0VmFsdWUiLCJmaWxsT3B0aW9uIiwiX2J1aWxkU3RhY2tMaW5lIiwic291cmNlUG9pbnRzIiwibGluZXNCZWxvdyIsImdldExpbmVzQmVsb3ciLCJhZGRQb2ludHNCZWxvdyIsImJlbG93IiwidW5zaGlmdCIsInNvdXJjZVBvaW50IiwicG9zdHBvbmVkIiwiZmluZFBvaW50IiwicG9pbnRWYWx1ZSIsImZpcnN0VmFsdWUiLCJsYXN0VmFsdWUiLCJzaW1wbGVBcmMiLCJfZ2V0VGFyZ2V0IiwiZ2V0TGluZUJ5SW5kZXgiLCJjb21wdXRlQm91bmRhcnkiLCJjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeSIsImNvbXB1dGVMaW5lYXJCb3VuZGFyeSIsIl9kcmF3ZmlsbCIsImxpbmVPcHRzIiwiYWJvdmUiLCJkb0ZpbGwiLCJjbGlwVmVydGljYWwiLCJjbGlwWSIsImxpbmVMb29wIiwic3JjIiwibm90U2hhcGUiLCJjbGlwQm91bmRzIiwiaW50ZXJwb2xhdGVkTGluZVRvIiwidGFyZ2V0TG9vcCIsImludGVycG9sYXRlZFBvaW50IiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIl9hcmdzIiwiJGZpbGxlciIsImJlZm9yZURyYXciLCJkcmF3VGltZSIsImJlZm9yZURhdGFzZXRzRHJhdyIsImJlZm9yZURhdGFzZXREcmF3IiwiZ2V0Qm94U2l6ZSIsImxhYmVsT3B0cyIsImJveEhlaWdodCIsImJveFdpZHRoIiwidXNlUG9pbnRTdHlsZSIsInBvaW50U3R5bGVXaWR0aCIsIml0ZW1IZWlnaHQiLCJpdGVtc0VxdWFsIiwiTGVnZW5kIiwiX2FkZGVkIiwibGVnZW5kSGl0Qm94ZXMiLCJfaG92ZXJlZEl0ZW0iLCJkb3VnaG51dE1vZGUiLCJsZWdlbmRJdGVtcyIsImNvbHVtblNpemVzIiwibGluZVdpZHRocyIsImJ1aWxkTGFiZWxzIiwibGFiZWxGb250IiwiX2NvbXB1dGVUaXRsZUhlaWdodCIsIl9maXRSb3dzIiwiX2ZpdENvbHMiLCJoaXRib3hlcyIsInRvdGFsSGVpZ2h0Iiwicm93IiwiaXRlbVdpZHRoIiwibWVhc3VyZVRleHQiLCJoZWlnaHRMaW1pdCIsInRvdGFsV2lkdGgiLCJjdXJyZW50Q29sV2lkdGgiLCJjdXJyZW50Q29sSGVpZ2h0IiwiY29sIiwiYWRqdXN0SGl0Qm94ZXMiLCJydGwiLCJydGxIZWxwZXIiLCJoaXRib3giLCJsZWZ0Rm9yTHRyIiwiX2RyYXciLCJkZWZhdWx0Q29sb3IiLCJmb250Q29sb3IiLCJoYWxmRm9udFNpemUiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwibGluZURhc2giLCJkcmF3T3B0aW9ucyIsIlNRUlQyIiwieFBsdXMiLCJ5Qm94VG9wIiwieEJveExlZnQiLCJmaWxsVGV4dCIsInN0cmlrZXRocm91Z2giLCJ0ZXh0RGlyZWN0aW9uIiwidGV4dFdpZHRoIiwic2V0V2lkdGgiLCJyZWFsWCIsInRpdGxlRm9udCIsInRpdGxlUGFkZGluZyIsInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaGFuZGxlRXZlbnQiLCJpc0xpc3RlbmVkIiwiaG92ZXJlZEl0ZW0iLCJzYW1lSXRlbSIsIm9uTGVhdmUiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJhZnRlckV2ZW50IiwiY2kiLCJUaXRsZSIsIl9wYWRkaW5nIiwidGV4dFNpemUiLCJfZHJhd0FyZ3MiLCJmb250T3B0cyIsImNyZWF0ZVRpdGxlIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIldlYWtNYXAiLCJwbHVnaW5fc3VidGl0bGUiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsImFwcGx5Iiwic3BsaXROZXdsaW5lcyIsInN0ciIsIlN0cmluZyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiZ2V0VG9vbHRpcFNpemUiLCJib2R5IiwiZm9vdGVyIiwiYm9keUZvbnQiLCJmb290ZXJGb250IiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJib2R5TGluZUl0ZW1Db3VudCIsImNvbWJpbmVkQm9keUxlbmd0aCIsImJvZHlJdGVtIiwiYmVmb3JlIiwiYWZ0ZXIiLCJiZWZvcmVCb2R5IiwiYWZ0ZXJCb2R5IiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJib2R5TGluZUhlaWdodCIsImRpc3BsYXlDb2xvcnMiLCJib2R5U3BhY2luZyIsImZvb3Rlck1hcmdpblRvcCIsImZvb3RlclNwYWNpbmciLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJkZXRlcm1pbmVZQWxpZ24iLCJkb2VzTm90Rml0V2l0aEFsaWduIiwieEFsaWduIiwiY2FyZXQiLCJjYXJldFNpemUiLCJjYXJldFBhZGRpbmciLCJkZXRlcm1pbmVYQWxpZ24iLCJ5QWxpZ24iLCJjaGFydFdpZHRoIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwiYWxpZ25YIiwiYWxpZ25ZIiwicGFkZGluZ0FuZFNpemUiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJhbGlnbm1lbnQiLCJjb3JuZXJSYWRpdXMiLCJnZXRBbGlnbmVkWCIsImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwiY3JlYXRlVG9vbHRpcENvbnRleHQiLCJ0b29sdGlwSXRlbXMiLCJvdmVycmlkZUNhbGxiYWNrcyIsIlRvb2x0aXAiLCJvcGFjaXR5IiwiX2V2ZW50UG9zaXRpb24iLCJfc2l6ZSIsIl9jYWNoZWRBbmltYXRpb25zIiwiX3Rvb2x0aXBJdGVtcyIsImRhdGFQb2ludHMiLCJjYXJldFgiLCJjYXJldFkiLCJsYWJlbENvbG9ycyIsImxhYmVsUG9pbnRTdHlsZXMiLCJsYWJlbFRleHRDb2xvcnMiLCJnZXRUaXRsZSIsImJlZm9yZVRpdGxlIiwiYWZ0ZXJUaXRsZSIsImdldEJlZm9yZUJvZHkiLCJnZXRCb2R5IiwiYm9keUl0ZW1zIiwic2NvcGVkIiwiYmVmb3JlTGFiZWwiLCJhZnRlckxhYmVsIiwiZ2V0QWZ0ZXJCb2R5IiwiZ2V0Rm9vdGVyIiwiYmVmb3JlRm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJfY3JlYXRlSXRlbXMiLCJpdGVtU29ydCIsImxhYmVsQ29sb3IiLCJsYWJlbFBvaW50U3R5bGUiLCJsYWJlbFRleHRDb2xvciIsInBvc2l0aW9uQW5kU2l6ZSIsImJhY2tncm91bmRQb2ludCIsImV4dGVybmFsIiwiZHJhd0NhcmV0IiwidG9vbHRpcFBvaW50IiwiY2FyZXRQb3NpdGlvbiIsImdldENhcmV0UG9zaXRpb24iLCJ4MyIsInkzIiwicHRYIiwicHRZIiwicHQiLCJ0aXRsZUNvbG9yIiwiX2RyYXdDb2xvckJveCIsImNvbG9yWCIsInJ0bENvbG9yWCIsInlPZmZTZXQiLCJjb2xvclkiLCJtdWx0aUtleUJhY2tncm91bmQiLCJvdXRlclgiLCJpbm5lclgiLCJzdHJva2VSZWN0IiwiZHJhd0JvZHkiLCJib2R5QWxpZ24iLCJ4TGluZVBhZGRpbmciLCJmaWxsTGluZU9mVGV4dCIsImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwidGV4dENvbG9yIiwiYm9keUNvbG9yIiwiZHJhd0Zvb3RlciIsImZvb3RlckFsaWduIiwiZm9vdGVyQ29sb3IiLCJ0b29sdGlwU2l6ZSIsInF1YWRyYXRpY0N1cnZlVG8iLCJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwiYW5pbVgiLCJhbmltWSIsIl93aWxsUmVuZGVyIiwiaGFzVG9vbHRpcENvbnRlbnQiLCJnbG9iYWxBbHBoYSIsInBvc2l0aW9uQ2hhbmdlZCIsIl9wb3NpdGlvbkNoYW5nZWQiLCJfaWdub3JlUmVwbGF5RXZlbnRzIiwicGx1Z2luX3Rvb2x0aXAiLCJhZnRlckluaXQiLCJhZnRlckRyYXciLCJsYWJlbENvdW50IiwiRGVjaW1hdGlvbiIsIkZpbGxlciIsIlN1YlRpdGxlIiwiYWRkSWZTdHJpbmciLCJhZGRlZExhYmVscyIsImZpbmRPckFkZExhYmVsIiwibGFzdEluZGV4T2YiLCJDYXRlZ29yeVNjYWxlIiwiX3N0YXJ0VmFsdWUiLCJfdmFsdWVSYW5nZSIsIl9hZGRlZExhYmVscyIsImFkZGVkIiwiaXNGaW5pdGUiLCJnZW5lcmF0ZVRpY2tzJDEiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwicHJlY2lzaW9uIiwibWF4VGlja3MiLCJtYXhEaWdpdHMiLCJpbmNsdWRlQm91bmRzIiwibWF4U3BhY2VzIiwicm1pbiIsInJtYXgiLCJjb3VudERlZmluZWQiLCJtaW5TcGFjaW5nIiwibmljZU1pbiIsIm5pY2VNYXgiLCJudW1TcGFjZXMiLCJkZWNpbWFsUGxhY2VzIiwicmVsYXRpdmVMYWJlbFNpemUiLCJyYWQiLCJMaW5lYXJTY2FsZUJhc2UiLCJfZW5kVmFsdWUiLCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwic2V0TWluIiwic2V0TWF4IiwibWluU2lnbiIsIm1heFNpZ24iLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsImdldFRpY2tMaW1pdCIsInN0ZXBTaXplIiwiY29tcHV0ZVRpY2tMaW1pdCIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiTGluZWFyU2NhbGUiLCJpc01ham9yIiwidGlja1ZhbCIsImdlbmVyYXRlVGlja3MiLCJlbmRFeHAiLCJlbmRTaWduaWZpY2FuZCIsImV4cCIsInNpZ25pZmljYW5kIiwibGFzdFRpY2siLCJMb2dhcml0aG1pY1NjYWxlIiwiX3plcm8iLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwibGltaXRzIiwidmFsdWVDb3VudCIsIl9wb2ludExhYmVscyIsInBvaW50TGFiZWxPcHRzIiwiYWRkaXRpb25hbEFuZ2xlIiwiY2VudGVyUG9pbnRMYWJlbHMiLCJnZXRQb2ludExhYmVsQ29udGV4dCIsImdldFBvaW50UG9zaXRpb24iLCJkcmF3aW5nQXJlYSIsInBsRm9udCIsImhMaW1pdHMiLCJ2TGltaXRzIiwidXBkYXRlTGltaXRzIiwic2V0Q2VudGVyUG9pbnQiLCJfcG9pbnRMYWJlbEl0ZW1zIiwiYnVpbGRQb2ludExhYmVsSXRlbXMiLCJleHRyYSIsIm91dGVyRGlzdGFuY2UiLCJwb2ludExhYmVsUG9zaXRpb24iLCJ5Rm9yQW5nbGUiLCJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsImxlZnRGb3JUZXh0QWxpZ24iLCJkcmF3UG9pbnRMYWJlbHMiLCJiYWNrZHJvcExlZnQiLCJiYWNrZHJvcFRvcCIsImJhY2tkcm9wV2lkdGgiLCJiYWNrZHJvcEhlaWdodCIsInBhdGhSYWRpdXNMaW5lIiwiZHJhd1JhZGl1c0xpbmUiLCJncmlkTGluZU9wdHMiLCJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsIlJhZGlhbExpbmVhclNjYWxlIiwibGVmdE1vdmVtZW50IiwicmlnaHRNb3ZlbWVudCIsInRvcE1vdmVtZW50IiwiYm90dG9tTW92ZW1lbnQiLCJhbmdsZU11bHRpcGxpZXIiLCJzY2FsaW5nRmFjdG9yIiwiZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIiLCJzY2FsZWREaXN0YW5jZSIsInBvaW50TGFiZWwiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJnZXRCYXNlUG9zaXRpb24iLCJnZXRQb2ludExhYmVsUG9zaXRpb24iLCJyb3RhdGUiLCJhbmltYXRlIiwiSU5URVJWQUxTIiwibWlsbGlzZWNvbmQiLCJjb21tb24iLCJzdGVwcyIsInNlY29uZCIsIm1pbnV0ZSIsImhvdXIiLCJkYXkiLCJ3ZWVrIiwibW9udGgiLCJxdWFydGVyIiwieWVhciIsIlVOSVRTIiwic29ydGVyIiwiaW5wdXQiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJpc29XZWVrZGF5IiwiX3BhcnNlT3B0cyIsImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCJtaW5Vbml0IiwiY2FwYWNpdHkiLCJpbnRlcnZhbCIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwiYWRkVGljayIsInRpbWUiLCJ0aW1lc3RhbXBzIiwic2V0TWFqb3JUaWNrcyIsIm1ham9yVW5pdCIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJUaW1lU2NhbGUiLCJfdW5pdCIsIl9tYWpvclVuaXQiLCJfb2Zmc2V0cyIsIl9ub3JtYWxpemVkIiwiZGlzcGxheUZvcm1hdHMiLCJub3JtYWxpemVkIiwiX2FwcGx5Qm91bmRzIiwiX2dldExhYmVsQm91bmRzIiwiZ2V0TGFiZWxUaW1lc3RhbXBzIiwidGltZU9wdHMiLCJfZ2VuZXJhdGUiLCJfZ2V0TGFiZWxDYXBhY2l0eSIsImluaXRPZmZzZXRzIiwib2Zmc2V0QWZ0ZXJBdXRvc2tpcCIsImdldERlY2ltYWxGb3JWYWx1ZSIsImhhc1dlZWtkYXkiLCJnZXREYXRhVGltZXN0YW1wcyIsInRvb2x0aXBGb3JtYXQiLCJkYXRldGltZSIsIl90aWNrRm9ybWF0RnVuY3Rpb24iLCJtaW5vckZvcm1hdCIsIm1ham9yRm9ybWF0IiwiZm9ybWF0dGVyIiwib2Zmc2V0cyIsIl9nZXRMYWJlbFNpemUiLCJ0aWNrc09wdHMiLCJ0aWNrTGFiZWxXaWR0aCIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ0aWNrRm9udFNpemUiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCIsIm5vcm1hbGl6ZSIsInRhYmxlIiwicHJldlNvdXJjZSIsIm5leHRTb3VyY2UiLCJwcmV2VGFyZ2V0IiwibmV4dFRhcmdldCIsInNwYW4iLCJUaW1lU2VyaWVzU2NhbGUiLCJfdGFibGUiLCJfbWluUG9zIiwiX3RhYmxlUmFuZ2UiLCJfZ2V0VGltZXN0YW1wc0ZvclRhYmxlIiwiYnVpbGRMb29rdXBUYWJsZSIsInJlZ2lzdGVyYWJsZXMiLCJfYWRhcHRlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chart.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.segment.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ _isPointInArea),\n/* harmony export */   A: () => (/* binding */ _factorize),\n/* harmony export */   B: () => (/* binding */ finiteOrDefault),\n/* harmony export */   C: () => (/* binding */ callback),\n/* harmony export */   D: () => (/* binding */ _addGrace),\n/* harmony export */   E: () => (/* binding */ _limitValue),\n/* harmony export */   F: () => (/* binding */ toDegrees),\n/* harmony export */   G: () => (/* binding */ _measureText),\n/* harmony export */   H: () => (/* binding */ HALF_PI),\n/* harmony export */   I: () => (/* binding */ _int16Range),\n/* harmony export */   J: () => (/* binding */ _alignPixel),\n/* harmony export */   K: () => (/* binding */ toPadding),\n/* harmony export */   L: () => (/* binding */ clipArea),\n/* harmony export */   M: () => (/* binding */ renderText),\n/* harmony export */   N: () => (/* binding */ unclipArea),\n/* harmony export */   O: () => (/* binding */ toFont),\n/* harmony export */   P: () => (/* binding */ PI),\n/* harmony export */   Q: () => (/* binding */ each),\n/* harmony export */   R: () => (/* binding */ _toLeftRightCenter),\n/* harmony export */   S: () => (/* binding */ _alignStartEnd),\n/* harmony export */   T: () => (/* binding */ TAU),\n/* harmony export */   U: () => (/* binding */ overrides),\n/* harmony export */   V: () => (/* binding */ merge),\n/* harmony export */   W: () => (/* binding */ _capitalize),\n/* harmony export */   X: () => (/* binding */ getRelativePosition),\n/* harmony export */   Y: () => (/* binding */ _rlookupByKey),\n/* harmony export */   Z: () => (/* binding */ _lookupByKey),\n/* harmony export */   _: () => (/* binding */ _arrayUnique),\n/* harmony export */   a: () => (/* binding */ resolve),\n/* harmony export */   a$: () => (/* binding */ toLineHeight),\n/* harmony export */   a0: () => (/* binding */ getAngleFromPoint),\n/* harmony export */   a1: () => (/* binding */ getMaximumSize),\n/* harmony export */   a2: () => (/* binding */ _getParentNode),\n/* harmony export */   a3: () => (/* binding */ readUsedSize),\n/* harmony export */   a4: () => (/* binding */ throttled),\n/* harmony export */   a5: () => (/* binding */ supportsEventListenerOptions),\n/* harmony export */   a6: () => (/* binding */ _isDomSupported),\n/* harmony export */   a7: () => (/* binding */ descriptors),\n/* harmony export */   a8: () => (/* binding */ isFunction),\n/* harmony export */   a9: () => (/* binding */ _attachContext),\n/* harmony export */   aA: () => (/* binding */ getRtlAdapter),\n/* harmony export */   aB: () => (/* binding */ overrideTextDirection),\n/* harmony export */   aC: () => (/* binding */ _textX),\n/* harmony export */   aD: () => (/* binding */ restoreTextDirection),\n/* harmony export */   aE: () => (/* binding */ drawPointLegend),\n/* harmony export */   aF: () => (/* binding */ noop),\n/* harmony export */   aG: () => (/* binding */ distanceBetweenPoints),\n/* harmony export */   aH: () => (/* binding */ _setMinAndMaxByKey),\n/* harmony export */   aI: () => (/* binding */ niceNum),\n/* harmony export */   aJ: () => (/* binding */ almostWhole),\n/* harmony export */   aK: () => (/* binding */ almostEquals),\n/* harmony export */   aL: () => (/* binding */ _decimalPlaces),\n/* harmony export */   aM: () => (/* binding */ _longestText),\n/* harmony export */   aN: () => (/* binding */ _filterBetween),\n/* harmony export */   aO: () => (/* binding */ _lookup),\n/* harmony export */   aP: () => (/* binding */ isPatternOrGradient),\n/* harmony export */   aQ: () => (/* binding */ getHoverColor),\n/* harmony export */   aR: () => (/* binding */ clone$1),\n/* harmony export */   aS: () => (/* binding */ _merger),\n/* harmony export */   aT: () => (/* binding */ _mergerIf),\n/* harmony export */   aU: () => (/* binding */ _deprecated),\n/* harmony export */   aV: () => (/* binding */ _splitKey),\n/* harmony export */   aW: () => (/* binding */ toFontString),\n/* harmony export */   aX: () => (/* binding */ splineCurve),\n/* harmony export */   aY: () => (/* binding */ splineCurveMonotone),\n/* harmony export */   aZ: () => (/* binding */ getStyle),\n/* harmony export */   a_: () => (/* binding */ fontString),\n/* harmony export */   aa: () => (/* binding */ _createResolver),\n/* harmony export */   ab: () => (/* binding */ _descriptors),\n/* harmony export */   ac: () => (/* binding */ mergeIf),\n/* harmony export */   ad: () => (/* binding */ uid),\n/* harmony export */   ae: () => (/* binding */ debounce),\n/* harmony export */   af: () => (/* binding */ retinaScale),\n/* harmony export */   ag: () => (/* binding */ clearCanvas),\n/* harmony export */   ah: () => (/* binding */ setsEqual),\n/* harmony export */   ai: () => (/* binding */ _elementsEqual),\n/* harmony export */   aj: () => (/* binding */ _isClickEvent),\n/* harmony export */   ak: () => (/* binding */ _isBetween),\n/* harmony export */   al: () => (/* binding */ _readValueToProps),\n/* harmony export */   am: () => (/* binding */ _updateBezierControlPoints),\n/* harmony export */   an: () => (/* binding */ _computeSegments),\n/* harmony export */   ao: () => (/* binding */ _boundSegments),\n/* harmony export */   ap: () => (/* binding */ _steppedInterpolation),\n/* harmony export */   aq: () => (/* binding */ _bezierInterpolation),\n/* harmony export */   ar: () => (/* binding */ _pointInLine),\n/* harmony export */   as: () => (/* binding */ _steppedLineTo),\n/* harmony export */   at: () => (/* binding */ _bezierCurveTo),\n/* harmony export */   au: () => (/* binding */ drawPoint),\n/* harmony export */   av: () => (/* binding */ addRoundedRectPath),\n/* harmony export */   aw: () => (/* binding */ toTRBL),\n/* harmony export */   ax: () => (/* binding */ toTRBLCorners),\n/* harmony export */   ay: () => (/* binding */ _boundSegment),\n/* harmony export */   az: () => (/* binding */ _normalizeAngle),\n/* harmony export */   b: () => (/* binding */ isArray),\n/* harmony export */   b0: () => (/* binding */ PITAU),\n/* harmony export */   b1: () => (/* binding */ INFINITY),\n/* harmony export */   b2: () => (/* binding */ RAD_PER_DEG),\n/* harmony export */   b3: () => (/* binding */ QUARTER_PI),\n/* harmony export */   b4: () => (/* binding */ TWO_THIRDS_PI),\n/* harmony export */   b5: () => (/* binding */ _angleDiff),\n/* harmony export */   c: () => (/* binding */ color),\n/* harmony export */   d: () => (/* binding */ defaults),\n/* harmony export */   e: () => (/* binding */ effects),\n/* harmony export */   f: () => (/* binding */ resolveObjectKey),\n/* harmony export */   g: () => (/* binding */ isNumberFinite),\n/* harmony export */   h: () => (/* binding */ createContext),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   j: () => (/* binding */ defined),\n/* harmony export */   k: () => (/* binding */ isNullOrUndef),\n/* harmony export */   l: () => (/* binding */ listenArrayEvents),\n/* harmony export */   m: () => (/* binding */ toPercentage),\n/* harmony export */   n: () => (/* binding */ toDimension),\n/* harmony export */   o: () => (/* binding */ formatNumber),\n/* harmony export */   p: () => (/* binding */ _angleBetween),\n/* harmony export */   q: () => (/* binding */ _getStartAndCountOfVisiblePoints),\n/* harmony export */   r: () => (/* binding */ requestAnimFrame),\n/* harmony export */   s: () => (/* binding */ sign),\n/* harmony export */   t: () => (/* binding */ toRadians),\n/* harmony export */   u: () => (/* binding */ unlistenArrayEvents),\n/* harmony export */   v: () => (/* binding */ valueOrDefault),\n/* harmony export */   w: () => (/* binding */ _scaleRangesChanged),\n/* harmony export */   x: () => (/* binding */ isNumber),\n/* harmony export */   y: () => (/* binding */ _parseObjectDataRadialScale),\n/* harmony export */   z: () => (/* binding */ log10)\n/* harmony export */ });\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ function noop() {}\nconst uid = function() {\n    let id = 0;\n    return function() {\n        return id++;\n    };\n}();\nfunction isNullOrUndef(value) {\n    return value === null || typeof value === \"undefined\";\n}\nfunction isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === \"[object\" && type.slice(-6) === \"Array]\") {\n        return true;\n    }\n    return false;\n}\nfunction isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst isNumberFinite = (value)=>(typeof value === \"number\" || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n    return typeof value === \"undefined\" ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 : value / dimension;\nconst toDimension = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 * dimension : +value;\nfunction callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === \"function\") {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\nfunction _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction clone$1(source) {\n    if (isArray(source)) {\n        return source.map(clone$1);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone$1(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone$1(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    for(let i = 0; i < ilen; ++i){\n        source = sources[i];\n        if (!isObject(source)) {\n            continue;\n        }\n        const keys = Object.keys(source);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, source, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\nfunction _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone$1(sval);\n    }\n}\nfunction _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\nconst keyResolvers = {\n    \"\": (v)=>v,\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === \"\") {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction _splitKey(key) {\n    const parts = key.split(\".\");\n    const keys = [];\n    let tmp = \"\";\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith(\"\\\\\")) {\n            tmp = tmp.slice(0, -1) + \".\";\n        } else {\n            keys.push(tmp);\n            tmp = \"\";\n        }\n    }\n    return keys;\n}\nfunction _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== \"undefined\";\nconst isFunction = (value)=>typeof value === \"function\";\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\nfunction _isClickEvent(e) {\n    return e.type === \"mouseup\" || e.type === \"click\" || e.type === \"contextmenu\";\n}\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU;\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\nfunction _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\nconst _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>table[index][key] <= value : (index)=>table[index][key] < value);\nconst _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"splice\",\n    \"unshift\"\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, \"_chartjs\", {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = \"_onData\" + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === \"function\") {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n    const set = new Set();\n    let i, ilen;\n    for(i = 0, ilen = items.length; i < ilen; ++i){\n        set.add(items[i]);\n    }\n    if (set.size === ilen) {\n        return items;\n    }\n    return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + \" \" + pixelSize + \"px \" + fontFamily;\n}\nconst requestAnimFrame = function() {\n    if (true) {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\nfunction throttled(fn, thisArg, updateFn) {\n    const updateArgs = updateFn || ((args)=>Array.prototype.slice.call(args));\n    let ticking = false;\n    let args = [];\n    return function(...rest) {\n        args = updateArgs(rest);\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, args);\n            });\n        }\n    };\n}\nfunction debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\nconst _toLeftRightCenter = (align)=>align === \"start\" ? \"left\" : align === \"end\" ? \"right\" : \"center\";\nconst _alignStartEnd = (align, start, end)=>align === \"start\" ? start : align === \"end\" ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl)=>{\n    const check = rtl ? \"left\" : \"right\";\n    return align === check ? right : align === \"center\" ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale, _parsed } = meta;\n        const axis = iScale.axis;\n        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n        if (minDefined) {\n            start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\nfunction _scaleRangesChanged(meta) {\n    const { xScale, yScale, _scaleRanges } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */ function round(v) {\n    return v + 0.5 | 0;\n}\nconst lim = (v, l, h)=>Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n    return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n    return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n    return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n    return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15\n};\nconst hex = [\n    ...\"0123456789ABCDEF\"\n];\nconst h1 = (b)=>hex[b & 0xF];\nconst h2 = (b)=>hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = (b)=>(b & 0xF0) >> 4 === (b & 0xF);\nconst isShort = (v)=>eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n    var len = str.length;\n    var ret;\n    if (str[0] === \"#\") {\n        if (len === 4 || len === 5) {\n            ret = {\n                r: 255 & map$1[str[1]] * 17,\n                g: 255 & map$1[str[2]] * 17,\n                b: 255 & map$1[str[3]] * 17,\n                a: len === 5 ? map$1[str[4]] * 17 : 255\n            };\n        } else if (len === 7 || len === 9) {\n            ret = {\n                r: map$1[str[1]] << 4 | map$1[str[2]],\n                g: map$1[str[3]] << 4 | map$1[str[4]],\n                b: map$1[str[5]] << 4 | map$1[str[6]],\n                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255\n            };\n        }\n    }\n    return ret;\n}\nconst alpha = (a, f)=>a < 255 ? f(a) : \"\";\nfunction hexString(v) {\n    var f = isShort(v) ? h1 : h2;\n    return v ? \"#\" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n    const a = s * Math.min(l, 1 - l);\n    const f = (n, k = (n + h / 30) % 12)=>l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return [\n        f(0),\n        f(8),\n        f(4)\n    ];\n}\nfunction hsv2rgbn(h, s, v) {\n    const f = (n, k = (n + h / 60) % 6)=>v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n    return [\n        f(5),\n        f(3),\n        f(1)\n    ];\n}\nfunction hwb2rgbn(h, w, b) {\n    const rgb = hsl2rgbn(h, 1, 0.5);\n    let i;\n    if (w + b > 1) {\n        i = 1 / (w + b);\n        w *= i;\n        b *= i;\n    }\n    for(i = 0; i < 3; i++){\n        rgb[i] *= 1 - w - b;\n        rgb[i] += w;\n    }\n    return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n    if (r === max) {\n        return (g - b) / d + (g < b ? 6 : 0);\n    }\n    if (g === max) {\n        return (b - r) / d + 2;\n    }\n    return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n    const range = 255;\n    const r = v.r / range;\n    const g = v.g / range;\n    const b = v.b / range;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    let h, s, d;\n    if (max !== min) {\n        d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        h = hueValue(r, g, b, d, max);\n        h = h * 60 + 0.5;\n    }\n    return [\n        h | 0,\n        s || 0,\n        l\n    ];\n}\nfunction calln(f, a, b, c) {\n    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n    return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n    return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n    return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n    return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n    const m = HUE_RE.exec(str);\n    let a = 255;\n    let v;\n    if (!m) {\n        return;\n    }\n    if (m[5] !== v) {\n        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n    }\n    const h = hue(+m[2]);\n    const p1 = +m[3] / 100;\n    const p2 = +m[4] / 100;\n    if (m[1] === \"hwb\") {\n        v = hwb2rgb(h, p1, p2);\n    } else if (m[1] === \"hsv\") {\n        v = hsv2rgb(h, p1, p2);\n    } else {\n        v = hsl2rgb(h, p1, p2);\n    }\n    return {\n        r: v[0],\n        g: v[1],\n        b: v[2],\n        a: a\n    };\n}\nfunction rotate(v, deg) {\n    var h = rgb2hsl(v);\n    h[0] = hue(h[0] + deg);\n    h = hsl2rgb(h);\n    v.r = h[0];\n    v.g = h[1];\n    v.b = h[2];\n}\nfunction hslString(v) {\n    if (!v) {\n        return;\n    }\n    const a = rgb2hsl(v);\n    const h = a[0];\n    const s = n2p(a[1]);\n    const l = n2p(a[2]);\n    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map = {\n    x: \"dark\",\n    Z: \"light\",\n    Y: \"re\",\n    X: \"blu\",\n    W: \"gr\",\n    V: \"medium\",\n    U: \"slate\",\n    A: \"ee\",\n    T: \"ol\",\n    S: \"or\",\n    B: \"ra\",\n    C: \"lateg\",\n    D: \"ights\",\n    R: \"in\",\n    Q: \"turquois\",\n    E: \"hi\",\n    P: \"ro\",\n    O: \"al\",\n    N: \"le\",\n    M: \"de\",\n    L: \"yello\",\n    F: \"en\",\n    K: \"ch\",\n    G: \"arks\",\n    H: \"ea\",\n    I: \"ightg\",\n    J: \"wh\"\n};\nconst names$1 = {\n    OiceXe: \"f0f8ff\",\n    antiquewEte: \"faebd7\",\n    aqua: \"ffff\",\n    aquamarRe: \"7fffd4\",\n    azuY: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"0\",\n    blanKedOmond: \"ffebcd\",\n    Xe: \"ff\",\n    XeviTet: \"8a2be2\",\n    bPwn: \"a52a2a\",\n    burlywood: \"deb887\",\n    caMtXe: \"5f9ea0\",\n    KartYuse: \"7fff00\",\n    KocTate: \"d2691e\",\n    cSO: \"ff7f50\",\n    cSnflowerXe: \"6495ed\",\n    cSnsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"ffff\",\n    xXe: \"8b\",\n    xcyan: \"8b8b\",\n    xgTMnPd: \"b8860b\",\n    xWay: \"a9a9a9\",\n    xgYF: \"6400\",\n    xgYy: \"a9a9a9\",\n    xkhaki: \"bdb76b\",\n    xmagFta: \"8b008b\",\n    xTivegYF: \"556b2f\",\n    xSange: \"ff8c00\",\n    xScEd: \"9932cc\",\n    xYd: \"8b0000\",\n    xsOmon: \"e9967a\",\n    xsHgYF: \"8fbc8f\",\n    xUXe: \"483d8b\",\n    xUWay: \"2f4f4f\",\n    xUgYy: \"2f4f4f\",\n    xQe: \"ced1\",\n    xviTet: \"9400d3\",\n    dAppRk: \"ff1493\",\n    dApskyXe: \"bfff\",\n    dimWay: \"696969\",\n    dimgYy: \"696969\",\n    dodgerXe: \"1e90ff\",\n    fiYbrick: \"b22222\",\n    flSOwEte: \"fffaf0\",\n    foYstWAn: \"228b22\",\n    fuKsia: \"ff00ff\",\n    gaRsbSo: \"dcdcdc\",\n    ghostwEte: \"f8f8ff\",\n    gTd: \"ffd700\",\n    gTMnPd: \"daa520\",\n    Way: \"808080\",\n    gYF: \"8000\",\n    gYFLw: \"adff2f\",\n    gYy: \"808080\",\n    honeyMw: \"f0fff0\",\n    hotpRk: \"ff69b4\",\n    RdianYd: \"cd5c5c\",\n    Rdigo: \"4b0082\",\n    ivSy: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavFMr: \"e6e6fa\",\n    lavFMrXsh: \"fff0f5\",\n    lawngYF: \"7cfc00\",\n    NmoncEffon: \"fffacd\",\n    ZXe: \"add8e6\",\n    ZcSO: \"f08080\",\n    Zcyan: \"e0ffff\",\n    ZgTMnPdLw: \"fafad2\",\n    ZWay: \"d3d3d3\",\n    ZgYF: \"90ee90\",\n    ZgYy: \"d3d3d3\",\n    ZpRk: \"ffb6c1\",\n    ZsOmon: \"ffa07a\",\n    ZsHgYF: \"20b2aa\",\n    ZskyXe: \"87cefa\",\n    ZUWay: \"778899\",\n    ZUgYy: \"778899\",\n    ZstAlXe: \"b0c4de\",\n    ZLw: \"ffffe0\",\n    lime: \"ff00\",\n    limegYF: \"32cd32\",\n    lRF: \"faf0e6\",\n    magFta: \"ff00ff\",\n    maPon: \"800000\",\n    VaquamarRe: \"66cdaa\",\n    VXe: \"cd\",\n    VScEd: \"ba55d3\",\n    VpurpN: \"9370db\",\n    VsHgYF: \"3cb371\",\n    VUXe: \"7b68ee\",\n    VsprRggYF: \"fa9a\",\n    VQe: \"48d1cc\",\n    VviTetYd: \"c71585\",\n    midnightXe: \"191970\",\n    mRtcYam: \"f5fffa\",\n    mistyPse: \"ffe4e1\",\n    moccasR: \"ffe4b5\",\n    navajowEte: \"ffdead\",\n    navy: \"80\",\n    Tdlace: \"fdf5e6\",\n    Tive: \"808000\",\n    TivedBb: \"6b8e23\",\n    Sange: \"ffa500\",\n    SangeYd: \"ff4500\",\n    ScEd: \"da70d6\",\n    pOegTMnPd: \"eee8aa\",\n    pOegYF: \"98fb98\",\n    pOeQe: \"afeeee\",\n    pOeviTetYd: \"db7093\",\n    papayawEp: \"ffefd5\",\n    pHKpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pRk: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powMrXe: \"b0e0e6\",\n    purpN: \"800080\",\n    YbeccapurpN: \"663399\",\n    Yd: \"ff0000\",\n    Psybrown: \"bc8f8f\",\n    PyOXe: \"4169e1\",\n    saddNbPwn: \"8b4513\",\n    sOmon: \"fa8072\",\n    sandybPwn: \"f4a460\",\n    sHgYF: \"2e8b57\",\n    sHshell: \"fff5ee\",\n    siFna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyXe: \"87ceeb\",\n    UXe: \"6a5acd\",\n    UWay: \"708090\",\n    UgYy: \"708090\",\n    snow: \"fffafa\",\n    sprRggYF: \"ff7f\",\n    stAlXe: \"4682b4\",\n    tan: \"d2b48c\",\n    teO: \"8080\",\n    tEstN: \"d8bfd8\",\n    tomato: \"ff6347\",\n    Qe: \"40e0d0\",\n    viTet: \"ee82ee\",\n    JHt: \"f5deb3\",\n    wEte: \"ffffff\",\n    wEtesmoke: \"f5f5f5\",\n    Lw: \"ffff00\",\n    LwgYF: \"9acd32\"\n};\nfunction unpack() {\n    const unpacked = {};\n    const keys = Object.keys(names$1);\n    const tkeys = Object.keys(map);\n    let i, j, k, ok, nk;\n    for(i = 0; i < keys.length; i++){\n        ok = nk = keys[i];\n        for(j = 0; j < tkeys.length; j++){\n            k = tkeys[j];\n            nk = nk.replace(k, map[k]);\n        }\n        k = parseInt(names$1[ok], 16);\n        unpacked[nk] = [\n            k >> 16 & 0xFF,\n            k >> 8 & 0xFF,\n            k & 0xFF\n        ];\n    }\n    return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n    if (!names) {\n        names = unpack();\n        names.transparent = [\n            0,\n            0,\n            0,\n            0\n        ];\n    }\n    const a = names[str.toLowerCase()];\n    return a && {\n        r: a[0],\n        g: a[1],\n        b: a[2],\n        a: a.length === 4 ? a[3] : 255\n    };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n    const m = RGB_RE.exec(str);\n    let a = 255;\n    let r, g, b;\n    if (!m) {\n        return;\n    }\n    if (m[7] !== r) {\n        const v = +m[7];\n        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n    }\n    r = +m[1];\n    g = +m[3];\n    b = +m[5];\n    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n    return {\n        r: r,\n        g: g,\n        b: b,\n        a: a\n    };\n}\nfunction rgbString(v) {\n    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);\n}\nconst to = (v)=>v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = (v)=>v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n    const r = from(b2n(rgb1.r));\n    const g = from(b2n(rgb1.g));\n    const b = from(b2n(rgb1.b));\n    return {\n        r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n        g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n        b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n        a: rgb1.a + t * (rgb2.a - rgb1.a)\n    };\n}\nfunction modHSL(v, i, ratio) {\n    if (v) {\n        let tmp = rgb2hsl(v);\n        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n        tmp = hsl2rgb(tmp);\n        v.r = tmp[0];\n        v.g = tmp[1];\n        v.b = tmp[2];\n    }\n}\nfunction clone(v, proto) {\n    return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n    var v = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    };\n    if (Array.isArray(input)) {\n        if (input.length >= 3) {\n            v = {\n                r: input[0],\n                g: input[1],\n                b: input[2],\n                a: 255\n            };\n            if (input.length > 3) {\n                v.a = n2b(input[3]);\n            }\n        }\n    } else {\n        v = clone(input, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        });\n        v.a = n2b(v.a);\n    }\n    return v;\n}\nfunction functionParse(str) {\n    if (str.charAt(0) === \"r\") {\n        return rgbParse(str);\n    }\n    return hueParse(str);\n}\nclass Color {\n    constructor(input){\n        if (input instanceof Color) {\n            return input;\n        }\n        const type = typeof input;\n        let v;\n        if (type === \"object\") {\n            v = fromObject(input);\n        } else if (type === \"string\") {\n            v = hexParse(input) || nameParse(input) || functionParse(input);\n        }\n        this._rgb = v;\n        this._valid = !!v;\n    }\n    get valid() {\n        return this._valid;\n    }\n    get rgb() {\n        var v = clone(this._rgb);\n        if (v) {\n            v.a = b2n(v.a);\n        }\n        return v;\n    }\n    set rgb(obj) {\n        this._rgb = fromObject(obj);\n    }\n    rgbString() {\n        return this._valid ? rgbString(this._rgb) : undefined;\n    }\n    hexString() {\n        return this._valid ? hexString(this._rgb) : undefined;\n    }\n    hslString() {\n        return this._valid ? hslString(this._rgb) : undefined;\n    }\n    mix(color, weight) {\n        if (color) {\n            const c1 = this.rgb;\n            const c2 = color.rgb;\n            let w2;\n            const p = weight === w2 ? 0.5 : weight;\n            const w = 2 * p - 1;\n            const a = c1.a - c2.a;\n            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            w2 = 1 - w1;\n            c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n            c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n            c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n            c1.a = p * c1.a + (1 - p) * c2.a;\n            this.rgb = c1;\n        }\n        return this;\n    }\n    interpolate(color, t) {\n        if (color) {\n            this._rgb = interpolate(this._rgb, color._rgb, t);\n        }\n        return this;\n    }\n    clone() {\n        return new Color(this.rgb);\n    }\n    alpha(a) {\n        this._rgb.a = n2b(a);\n        return this;\n    }\n    clearer(ratio) {\n        const rgb = this._rgb;\n        rgb.a *= 1 - ratio;\n        return this;\n    }\n    greyscale() {\n        const rgb = this._rgb;\n        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n        rgb.r = rgb.g = rgb.b = val;\n        return this;\n    }\n    opaquer(ratio) {\n        const rgb = this._rgb;\n        rgb.a *= 1 + ratio;\n        return this;\n    }\n    negate() {\n        const v = this._rgb;\n        v.r = 255 - v.r;\n        v.g = 255 - v.g;\n        v.b = 255 - v.b;\n        return this;\n    }\n    lighten(ratio) {\n        modHSL(this._rgb, 2, ratio);\n        return this;\n    }\n    darken(ratio) {\n        modHSL(this._rgb, 2, -ratio);\n        return this;\n    }\n    saturate(ratio) {\n        modHSL(this._rgb, 1, ratio);\n        return this;\n    }\n    desaturate(ratio) {\n        modHSL(this._rgb, 1, -ratio);\n        return this;\n    }\n    rotate(deg) {\n        rotate(this._rgb, deg);\n        return this;\n    }\n}\nfunction index_esm(input) {\n    return new Color(input);\n}\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === \"object\") {\n        const type = value.toString();\n        return type === \"[object CanvasPattern]\" || type === \"[object CanvasGradient]\";\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split(\".\");\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === \"string\") {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, \"\"), scope);\n}\nclass Defaults {\n    constructor(_descriptors){\n        this.animation = undefined;\n        this.backgroundColor = \"rgba(0,0,0,0.1)\";\n        this.borderColor = \"rgba(0,0,0,0.1)\";\n        this.color = \"#666\";\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            \"mousemove\",\n            \"mouseout\",\n            \"click\",\n            \"touchstart\",\n            \"touchmove\"\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: \"normal\",\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = \"x\";\n        this.interaction = {\n            mode: \"nearest\",\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n    }\n    set(scope, values) {\n        return set(this, scope, values);\n    }\n    get(scope) {\n        return getScope$1(this, scope);\n    }\n    describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n    route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = \"_\" + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n}\nvar defaults = new Defaults({\n    _scriptable: (name)=>!name.startsWith(\"on\"),\n    _indexable: (name)=>name !== \"events\",\n    hover: {\n        _fallback: \"interaction\"\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n});\nfunction toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + \" \" : \"\") + (font.weight ? font.weight + \" \" : \"\") + font.size + \"px \" + font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n    ctx = ctx || canvas.getContext(\"2d\");\n    ctx.save();\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === \"object\") {\n        type = style.toString();\n        if (type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\") {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case \"triangle\":\n            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case \"rectRounded\":\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case \"rect\":\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        case \"rectRot\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            ctx.closePath();\n            break;\n        case \"crossRot\":\n            rad += QUARTER_PI;\n        case \"cross\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"star\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            rad += QUARTER_PI;\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"line\":\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case \"dash\":\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\nfunction _isPointInArea(point, area, margin) {\n    margin = margin || 0.5;\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === \"middle\") {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === \"after\" !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== \"\";\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += font.lineHeight;\n    }\n    ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction addRoundedRectPath(ctx, rect) {\n    const { x, y, w, h, radius } = rect;\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    ctx.lineTo(x + w, y + radius.topRight);\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n    const matches = (\"\" + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === \"normal\") {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case \"px\":\n            return value;\n        case \"%\":\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\nfunction toTRBL(value) {\n    return _readValueToProps(value, {\n        top: \"y\",\n        right: \"x\",\n        bottom: \"y\",\n        left: \"x\"\n    });\n}\nfunction toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        \"topLeft\",\n        \"topRight\",\n        \"bottomLeft\",\n        \"bottomRight\"\n    ]);\n}\nfunction toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\nfunction toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === \"string\") {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !(\"\" + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = \"\";\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: \"\"\n    };\n    font.string = toFontString(font);\n    return font;\n}\nfunction resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === \"function\") {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n    const { min, max } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\nfunction _createResolver(scopes, prefixes = [\n    \"\"\n], rootScopes = scopes, fallback, getTarget = ()=>scopes[0]) {\n    if (!defined(fallback)) {\n        fallback = _resolve(\"_fallback\", scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: \"Object\",\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: rootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, rootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        deleteProperty (target, prop) {\n            delete target[prop];\n            delete target._keys;\n            delete scopes[0][prop];\n            return true;\n        },\n        get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value;\n            delete target._keys;\n            return true;\n        }\n    });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        deleteProperty (target, prop) {\n            delete target[prop];\n            delete proxy[prop];\n            return true;\n        },\n        get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        set (target, prop, value) {\n            proxy[prop] = value;\n            delete target[prop];\n            return true;\n        }\n    });\n}\nfunction _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== \"adapters\" && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\n        return target[prop];\n    }\n    const value = resolve();\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    let value = _proxy[prop];\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n    const { _proxy, _context, _subProxy, _stack } = target;\n    if (_stack.has(prop)) {\n        throw new Error(\"Recursion detected: \" + Array.from(_stack).join(\"->\") + \"->\" + prop);\n    }\n    _stack.add(prop);\n    value = value(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    if (defined(_context.index) && isIndexable(prop)) {\n        value = value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === \"string\" ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n                return fallback;\n            }\n        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (defined(fallback) && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        \"\"\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        return value;\n    }\n    return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (defined(value)) {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (defined(value)) {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith(\"_\"))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale } = meta;\n    const { key = \"r\" } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === \"x\" ? \"y\" : \"x\";\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01;\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = \"x\") {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\nfunction splineCurveMonotone(points, indexAxis = \"x\") {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === \"monotone\") {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\nfunction _isDomSupported() {\n    return  false && 0;\n}\nfunction _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === \"[object ShadowRoot]\") {\n        parent = parent.host;\n    }\n    return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === \"string\") {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf(\"%\") !== -1) {\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? \"-\" + suffix : \"\";\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + \"-\" + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX, offsetY } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\nfunction getRelativePosition(evt, chart) {\n    if (\"native\" in evt) {\n        return evt;\n    }\n    const { canvas, currentDevicePixelRatio } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === \"border-box\";\n    const paddings = getPositionedStyle(style, \"padding\");\n    const borders = getPositionedStyle(style, \"border\", \"width\");\n    const { x, y, box } = getCanvasPosition(evt, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width, height } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, \"border\", \"width\");\n            const containerPadding = getPositionedStyle(containerStyle, \"padding\");\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, \"clientWidth\");\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, \"clientHeight\");\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, \"margin\");\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, \"clientWidth\") || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, \"clientHeight\") || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width, height } = containerSize;\n    if (style.boxSizing === \"content-box\") {\n        const borders = getPositionedStyle(style, \"border\", \"width\");\n        const paddings = getPositionedStyle(style, \"padding\");\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        height = round1(width / 2);\n    }\n    return {\n        width,\n        height\n    };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = deviceHeight / pixelRatio;\n    chart.width = deviceWidth / pixelRatio;\n    const canvas = chart.canvas;\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\nconst supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        window.addEventListener(\"test\", null, options);\n        window.removeEventListener(\"test\", null, options);\n    } catch (e) {}\n    return passiveSupported;\n}();\nfunction readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\nfunction _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === \"middle\" ? t < 0.5 ? p1.y : p2.y : mode === \"after\" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === \"center\") {\n                return align;\n            }\n            return align === \"right\" ? \"left\" : \"right\";\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === \"ltr\" || direction === \"rtl\") {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue(\"direction\"),\n            style.getPropertyPriority(\"direction\")\n        ];\n        style.setProperty(\"direction\", direction, \"important\");\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty(\"direction\", original[0], original[1]);\n    }\n}\nfunction propertyFn(property) {\n    if (property === \"angle\") {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start, end, count, loop, style }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property, start: startBound, end: endBound } = bounds;\n    const { between, normalize } = propertyFn(property);\n    const count = points.length;\n    let { start, end, loop } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\nfunction _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property, start: startBound, end: endBound } = bounds;\n    const count = points.length;\n    const { compare, between, normalize } = propertyFn(property);\n    const { start, end, loop, style } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\nfunction _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\nfunction solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: \"segment\",\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaHVua3MvaGVscGVycy5zZWdtZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxTQUFTQSxRQUFRO0FBQ2pCLE1BQU1DLE1BQU87SUFDWCxJQUFJQyxLQUFLO0lBQ1QsT0FBTztRQUNMLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNDLGNBQWNDLEtBQUs7SUFDMUIsT0FBT0EsVUFBVSxRQUFRLE9BQU9BLFVBQVU7QUFDNUM7QUFDQSxTQUFTQyxRQUFRRCxLQUFLO0lBQ3BCLElBQUlFLE1BQU1ELE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxDQUFDRCxRQUFRO1FBQ3pDLE9BQU87SUFDVDtJQUNBLE1BQU1HLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNQO0lBQzVDLElBQUlHLEtBQUtLLEtBQUssQ0FBQyxHQUFHLE9BQU8sYUFBYUwsS0FBS0ssS0FBSyxDQUFDLENBQUMsT0FBTyxVQUFVO1FBQ2pFLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFNBQVNULEtBQUs7SUFDckIsT0FBT0EsVUFBVSxRQUFRSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxXQUFXO0FBQ3JFO0FBQ0EsTUFBTVUsaUJBQWlCLENBQUNWLFFBQVUsQ0FBQyxPQUFPQSxVQUFVLFlBQVlBLGlCQUFpQlcsTUFBSyxLQUFNQyxTQUFTLENBQUNaO0FBQ3RHLFNBQVNhLGdCQUFnQmIsS0FBSyxFQUFFYyxZQUFZO0lBQzFDLE9BQU9KLGVBQWVWLFNBQVNBLFFBQVFjO0FBQ3pDO0FBQ0EsU0FBU0MsZUFBZWYsS0FBSyxF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Q1BDLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsS0FBSztJQUNMQyxRQUFRO0lBQ1JDLEtBQUs7SUFDTEMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLEtBQUs7SUFDTEMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsWUFBWTtJQUNaQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEMsS0FBSztJQUNMQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsS0FBSztJQUNMQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsWUFBWTtJQUNaQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxLQUFLO0lBQ0xDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLGFBQWE7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Q3hCLE9BQU87UUFDTGlnQixpQkFBaUJqZ0IsUUFBUWlnQixlQUFlO1FBQ3hDc2IsZ0JBQWdCdjdCLFFBQVF1N0IsY0FBYztRQUN0Q0MsWUFBWXg3QixRQUFRdzdCLFVBQVU7UUFDOUJDLGtCQUFrQno3QixRQUFReTdCLGdCQUFnQjtRQUMxQ0MsaUJBQWlCMTdCLFFBQVEwN0IsZUFBZTtRQUN4Q3BWLGFBQWF0bUIsUUFBUXNtQixXQUFXO1FBQ2hDcEcsYUFBYWxnQixRQUFRa2dCLFdBQVc7SUFDbEM7QUFDRjtBQUNBLFNBQVNvYixhQUFhemEsS0FBSyxFQUFFa2EsU0FBUztJQUNwQyxPQUFPQSxhQUFhN0QsS0FBS0MsU0FBUyxDQUFDdFcsV0FBV3FXLEtBQUtDLFNBQVMsQ0FBQzREO0FBQy9EO0FBRXE0RSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhbG1pbGhhbmRvLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanM/OWFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgdWlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkKys7XG4gIH07XG59KCkpO1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5jb25zdCBpc051bWJlckZpbml0ZSA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG5mdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5jb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogdmFsdWUgLyBkaW1lbnNpb247XG5jb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5mdW5jdGlvbiBjYWxsYmFjayhmbiwgYXJncywgdGhpc0FyZykge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVhY2gobG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG4gIGxldCBpLCBsZW4sIGtleXM7XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTAsIGExKSB7XG4gIGxldCBpLCBpbGVuLCB2MCwgdjE7XG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lJDEoc291cmNlKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSQxKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUkMShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUlmKHRhcmdldCwgc291cmNlKSB7XG4gIHJldHVybiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5mdW5jdGlvbiBfbWVyZ2VySWYoa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGUsIHZhbHVlLCBwcmV2aW91cywgY3VycmVudCkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcblx0XHRcdCdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gICcnOiB2ID0+IHYsXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcbmZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpIHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleSkge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuZnVuY3Rpb24gX3NwbGl0S2V5KGtleSkge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBuaWNlTnVtKHJhbmdlKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cbmZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHgsIHksIGVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbmZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5mdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlLCBzdGFydCwgZW5kLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkO1xuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlLCBsYXN0KSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgbGFzdFxuICAgID8gaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPD0gdmFsdWVcbiAgICA6IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuY29uc3QgX3Jsb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcbiAgfVxuICBpZiAoc2V0LnNpemUgPT09IGlsZW4pIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcbmZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtaW4pLmxvLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbmZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0LCBzLCBwKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6IHQgPT4gdCxcbiAgZWFzZUluUXVhZDogdCA9PiB0ICogdCxcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxuICBlYXNlSW5PdXRRdWFkOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuICBlYXNlSW5DdWJpYzogdCA9PiB0ICogdCAqIHQsXG4gIGVhc2VPdXRDdWJpYzogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVhcnQ6IHQgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gIGVhc2VJblF1aW50OiB0ID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgZWFzZUluU2luZTogdCA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcbiAgZWFzZU91dFNpbmU6IHQgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICBlYXNlSW5FeHBvOiB0ID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICBlYXNlT3V0RXhwbzogdCA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogdCA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gIGVhc2VJbk91dENpcmM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG4gIGVhc2VJbkVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG4gIGVhc2VJbkJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuICBlYXNlT3V0QmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayh0KSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcbiAgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59O1xuXG4vKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjIgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgcmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gIHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG4gIGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG4gIGxldCBpO1xuICBpZiAodyArIGIgPiAxKSB7XG4gICAgaSA9IDEgLyAodyArIGIpO1xuICAgIHcgKj0gaTtcbiAgICBiICo9IGk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJnYltpXSAqPSAxIC0gdyAtIGI7XG4gICAgcmdiW2ldICs9IHc7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xuICBpZiAociA9PT0gbWF4KSB7XG4gICAgcmV0dXJuICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMCk7XG4gIH1cbiAgaWYgKGcgPT09IG1heCkge1xuICAgIHJldHVybiAoYiAtIHIpIC8gZCArIDI7XG4gIH1cbiAgcmV0dXJuIChyIC0gZykgLyBkICsgNDtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuICBjb25zdCByYW5nZSA9IDI1NTtcbiAgY29uc3QgciA9IHYuciAvIHJhbmdlO1xuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG4gIGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBsZXQgaCwgcywgZDtcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XG4gICAgaCA9IGggKiA2MCArIDAuNTtcbiAgfVxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYSlcbiAgICAgID8gZihhWzBdLCBhWzFdLCBhWzJdKVxuICAgICAgOiBmKGEsIGIsIGMpXG4gICkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgcmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuICByZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG4gIHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuICByZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHY7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs1XSAhPT0gdikge1xuICAgIGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG4gIH1cbiAgY29uc3QgaCA9IGh1ZSgrbVsyXSk7XG4gIGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG4gIGlmIChtWzFdID09PSAnaHdiJykge1xuICAgIHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcbiAgICB2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2Uge1xuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiB2WzBdLFxuICAgIGc6IHZbMV0sXG4gICAgYjogdlsyXSxcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG4gIHZhciBoID0gcmdiMmhzbCh2KTtcbiAgaFswXSA9IGh1ZShoWzBdICsgZGVnKTtcbiAgaCA9IGhzbDJyZ2IoaCk7XG4gIHYuciA9IGhbMF07XG4gIHYuZyA9IGhbMV07XG4gIHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuICBpZiAoIXYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XG4gIGNvbnN0IGggPSBhWzBdO1xuICBjb25zdCBzID0gbjJwKGFbMV0pO1xuICBjb25zdCBsID0gbjJwKGFbMl0pO1xuICByZXR1cm4gdi5hIDwgMjU1XG4gICAgPyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgciwgZywgYjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzddICE9PSByKSB7XG4gICAgY29uc3QgdiA9ICttWzddO1xuICAgIGEgPSBtWzhdID8gcDJiKHYpIDogbGltKHYgKiAyNTUsIDAsIDI1NSk7XG4gIH1cbiAgciA9ICttWzFdO1xuICBnID0gK21bM107XG4gIGIgPSArbVs1XTtcbiAgciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogbGltKHIsIDAsIDI1NSkpO1xuICBnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBsaW0oZywgMCwgMjU1KSk7XG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuICByZXR1cm4gdiAmJiAoXG4gICAgdi5hIDwgMjU1XG4gICAgICA/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcbiAgKTtcbn1cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBpbmRleF9lc20odmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmRleF9lc20odmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgfVxuICBzZXQoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQodGhpcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICB9XG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBvdmVycmlkZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChvdmVycmlkZXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NvcGVPYmplY3QsIHtcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG52YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cbmZ1bmN0aW9uIF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2xvbmdlc3RUZXh0KGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHgsIHkpIHtcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCB3KSB7XG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXMsIHdpZHRoO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgZGVmYXVsdDpcbiAgICBpZiAodykge1xuICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgIGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdCc6XG4gICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdyZWN0Um90JzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjcm9zc1JvdCc6XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ2Nyb3NzJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXInOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2xpbmUnOlxuICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rhc2gnOlxuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgIGJyZWFrO1xuICB9XG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEocG9pbnQsIGFyZWEsIG1hcmdpbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41O1xuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0KGN0eCwgdGV4dCwgeCwgeSwgZm9udCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaSwgbGluZTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG4gICAgeSArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cykge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAtSEFMRl9QSSwgUEksIHRydWUpO1xuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICBjYXNlICdweCc6XG4gICAgcmV0dXJuIHZhbHVlO1xuICBjYXNlICclJzpcbiAgICB2YWx1ZSAvPSAxMDA7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyA9IHYgPT4gK3YgfHwgMDtcbmZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBwcm9wcykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdG9UUkJMKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5mdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5mdW5jdGlvbiB0b1BhZGRpbmcodmFsdWUpIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKTtcbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHRvRm9udChvcHRpb25zLCBmYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSAnJztcbiAgfVxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4LCBncmFjZSwgYmVnaW5BdFplcm8pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbJyddLCByb290U2NvcGVzID0gc2NvcGVzLCBmYWxsYmFjaywgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdKSB7XG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3Blczogcm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgcm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfYXR0YWNoQ29udGV4dChwcm94eSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICBjb25zdCBjYWNoZSA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfZGVzY3JpcHRvcnMocHJveHksIGRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX0pIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5jb25zdCByZWFkS2V5ID0gKHByZWZpeCwgbmFtZSkgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5mdW5jdGlvbiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgcmVzb2x2ZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIHZhbHVlID0gdmFsdWUoX2NvbnRleHQsIF9zdWJQcm94eSB8fCByZWNlaXZlcik7XG4gIF9zdGFjay5kZWxldGUocHJvcCk7XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgaXNJbmRleGFibGUpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gdmFsdWVbX2NvbnRleHQuaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRmFsbGJhY2soZmFsbGJhY2ssIHByb3AsIHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2ssIHZhbHVlKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pIHtcbiAgd2hpbGUgKGtleSkge1xuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXNvbHZlKGtleSwgc2NvcGVzKSB7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc2NvcGVba2V5XTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKGsgPT4gIWsuc3RhcnRzV2l0aCgnXycpKSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuZnVuY3Rpb24gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHtrZXkgPSAncid9ID0gdGhpcy5fcGFyc2luZztcbiAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgcGFyc2VkW2ldID0ge1xuICAgICAgcjogaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwga2V5KSwgaW5kZXgpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgY29uc3QgZmEgPSB0ICogczAxO1xuICBjb25zdCBmYiA9IHQgKiBzMTI7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSyA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KSA9PiAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihlLCBjYW52YXMpIHtcbiAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2dCwgY2hhcnQpIHtcbiAgaWYgKCduYXRpdmUnIGluIGV2dCkge1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5jb25zdCByb3VuZDEgPSB2ID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgY2hhcnQuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgY2hhcnQud2lkdGggPSBkZXZpY2VXaWR0aCAvIHBpeGVsUmF0aW87XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbmV4cG9ydCB7IF9pc1BvaW50SW5BcmVhIGFzICQsIF9mYWN0b3JpemUgYXMgQSwgZmluaXRlT3JEZWZhdWx0IGFzIEIsIGNhbGxiYWNrIGFzIEMsIF9hZGRHcmFjZSBhcyBELCBfbGltaXRWYWx1ZSBhcyBFLCB0b0RlZ3JlZXMgYXMgRiwgX21lYXN1cmVUZXh0IGFzIEcsIEhBTEZfUEkgYXMgSCwgX2ludDE2UmFuZ2UgYXMgSSwgX2FsaWduUGl4ZWwgYXMgSiwgdG9QYWRkaW5nIGFzIEssIGNsaXBBcmVhIGFzIEwsIHJlbmRlclRleHQgYXMgTSwgdW5jbGlwQXJlYSBhcyBOLCB0b0ZvbnQgYXMgTywgUEkgYXMgUCwgZWFjaCBhcyBRLCBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgUiwgX2FsaWduU3RhcnRFbmQgYXMgUywgVEFVIGFzIFQsIG92ZXJyaWRlcyBhcyBVLCBtZXJnZSBhcyBWLCBfY2FwaXRhbGl6ZSBhcyBXLCBnZXRSZWxhdGl2ZVBvc2l0aW9uIGFzIFgsIF9ybG9va3VwQnlLZXkgYXMgWSwgX2xvb2t1cEJ5S2V5IGFzIFosIF9hcnJheVVuaXF1ZSBhcyBfLCByZXNvbHZlIGFzIGEsIHRvTGluZUhlaWdodCBhcyBhJCwgZ2V0QW5nbGVGcm9tUG9pbnQgYXMgYTAsIGdldE1heGltdW1TaXplIGFzIGExLCBfZ2V0UGFyZW50Tm9kZSBhcyBhMiwgcmVhZFVzZWRTaXplIGFzIGEzLCB0aHJvdHRsZWQgYXMgYTQsIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgYXMgYTUsIF9pc0RvbVN1cHBvcnRlZCBhcyBhNiwgZGVzY3JpcHRvcnMgYXMgYTcsIGlzRnVuY3Rpb24gYXMgYTgsIF9hdHRhY2hDb250ZXh0IGFzIGE5LCBnZXRSdGxBZGFwdGVyIGFzIGFBLCBvdmVycmlkZVRleHREaXJlY3Rpb24gYXMgYUIsIF90ZXh0WCBhcyBhQywgcmVzdG9yZVRleHREaXJlY3Rpb24gYXMgYUQsIGRyYXdQb2ludExlZ2VuZCBhcyBhRSwgbm9vcCBhcyBhRiwgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIGFzIGFHLCBfc2V0TWluQW5kTWF4QnlLZXkgYXMgYUgsIG5pY2VOdW0gYXMgYUksIGFsbW9zdFdob2xlIGFzIGFKLCBhbG1vc3RFcXVhbHMgYXMgYUssIF9kZWNpbWFsUGxhY2VzIGFzIGFMLCBfbG9uZ2VzdFRleHQgYXMgYU0sIF9maWx0ZXJCZXR3ZWVuIGFzIGFOLCBfbG9va3VwIGFzIGFPLCBpc1BhdHRlcm5PckdyYWRpZW50IGFzIGFQLCBnZXRIb3ZlckNvbG9yIGFzIGFRLCBjbG9uZSQxIGFzIGFSLCBfbWVyZ2VyIGFzIGFTLCBfbWVyZ2VySWYgYXMgYVQsIF9kZXByZWNhdGVkIGFzIGFVLCBfc3BsaXRLZXkgYXMgYVYsIHRvRm9udFN0cmluZyBhcyBhVywgc3BsaW5lQ3VydmUgYXMgYVgsIHNwbGluZUN1cnZlTW9ub3RvbmUgYXMgYVksIGdldFN0eWxlIGFzIGFaLCBmb250U3RyaW5nIGFzIGFfLCBfY3JlYXRlUmVzb2x2ZXIgYXMgYWEsIF9kZXNjcmlwdG9ycyBhcyBhYiwgbWVyZ2VJZiBhcyBhYywgdWlkIGFzIGFkLCBkZWJvdW5jZSBhcyBhZSwgcmV0aW5hU2NhbGUgYXMgYWYsIGNsZWFyQ2FudmFzIGFzIGFnLCBzZXRzRXF1YWwgYXMgYWgsIF9lbGVtZW50c0VxdWFsIGFzIGFpLCBfaXNDbGlja0V2ZW50IGFzIGFqLCBfaXNCZXR3ZWVuIGFzIGFrLCBfcmVhZFZhbHVlVG9Qcm9wcyBhcyBhbCwgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMgYXMgYW0sIF9jb21wdXRlU2VnbWVudHMgYXMgYW4sIF9ib3VuZFNlZ21lbnRzIGFzIGFvLCBfc3RlcHBlZEludGVycG9sYXRpb24gYXMgYXAsIF9iZXppZXJJbnRlcnBvbGF0aW9uIGFzIGFxLCBfcG9pbnRJbkxpbmUgYXMgYXIsIF9zdGVwcGVkTGluZVRvIGFzIGFzLCBfYmV6aWVyQ3VydmVUbyBhcyBhdCwgZHJhd1BvaW50IGFzIGF1LCBhZGRSb3VuZGVkUmVjdFBhdGggYXMgYXYsIHRvVFJCTCBhcyBhdywgdG9UUkJMQ29ybmVycyBhcyBheCwgX2JvdW5kU2VnbWVudCBhcyBheSwgX25vcm1hbGl6ZUFuZ2xlIGFzIGF6LCBpc0FycmF5IGFzIGIsIFBJVEFVIGFzIGIwLCBJTkZJTklUWSBhcyBiMSwgUkFEX1BFUl9ERUcgYXMgYjIsIFFVQVJURVJfUEkgYXMgYjMsIFRXT19USElSRFNfUEkgYXMgYjQsIF9hbmdsZURpZmYgYXMgYjUsIGNvbG9yIGFzIGMsIGRlZmF1bHRzIGFzIGQsIGVmZmVjdHMgYXMgZSwgcmVzb2x2ZU9iamVjdEtleSBhcyBmLCBpc051bWJlckZpbml0ZSBhcyBnLCBjcmVhdGVDb250ZXh0IGFzIGgsIGlzT2JqZWN0IGFzIGksIGRlZmluZWQgYXMgaiwgaXNOdWxsT3JVbmRlZiBhcyBrLCBsaXN0ZW5BcnJheUV2ZW50cyBhcyBsLCB0b1BlcmNlbnRhZ2UgYXMgbSwgdG9EaW1lbnNpb24gYXMgbiwgZm9ybWF0TnVtYmVyIGFzIG8sIF9hbmdsZUJldHdlZW4gYXMgcCwgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMgYXMgcSwgcmVxdWVzdEFuaW1GcmFtZSBhcyByLCBzaWduIGFzIHMsIHRvUmFkaWFucyBhcyB0LCB1bmxpc3RlbkFycmF5RXZlbnRzIGFzIHUsIHZhbHVlT3JEZWZhdWx0IGFzIHYsIF9zY2FsZVJhbmdlc0NoYW5nZWQgYXMgdywgaXNOdW1iZXIgYXMgeCwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIGFzIHksIGxvZzEwIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJub29wIiwidWlkIiwiaWQiLCJpc051bGxPclVuZGVmIiwidmFsdWUiLCJpc0FycmF5IiwiQXJyYXkiLCJ0eXBlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJpc09iamVjdCIsImlzTnVtYmVyRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaW5pdGVPckRlZmF1bHQiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZU9yRGVmYXVsdCIsInRvUGVyY2VudGFnZSIsImRpbWVuc2lvbiIsImVuZHNXaXRoIiwicGFyc2VGbG9hdCIsInRvRGltZW5zaW9uIiwiY2FsbGJhY2siLCJmbiIsImFyZ3MiLCJ0aGlzQXJnIiwiYXBwbHkiLCJlYWNoIiwibG9vcGFibGUiLCJyZXZlcnNlIiwiaSIsImxlbiIsImtleXMiLCJsZW5ndGgiLCJfZWxlbWVudHNFcXVhbCIsImEwIiwiYTEiLCJpbGVuIiwidjAiLCJ2MSIsImRhdGFzZXRJbmRleCIsImluZGV4IiwiY2xvbmUkMSIsInNvdXJjZSIsIm1hcCIsInRhcmdldCIsImNyZWF0ZSIsImtsZW4iLCJrIiwiaXNWYWxpZEtleSIsImtleSIsImluZGV4T2YiLCJfbWVyZ2VyIiwib3B0aW9ucyIsInR2YWwiLCJzdmFsIiwibWVyZ2UiLCJzb3VyY2VzIiwibWVyZ2VyIiwibWVyZ2VJZiIsIl9tZXJnZXJJZiIsImhhc093blByb3BlcnR5IiwiX2RlcHJlY2F0ZWQiLCJzY29wZSIsInByZXZpb3VzIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwia2V5UmVzb2x2ZXJzIiwidiIsIngiLCJvIiwieSIsInJlc29sdmVPYmplY3RLZXkiLCJvYmoiLCJyZXNvbHZlciIsIl9nZXRLZXlSZXNvbHZlciIsIl9zcGxpdEtleSIsInBhcnRzIiwic3BsaXQiLCJ0bXAiLCJwYXJ0IiwicHVzaCIsIl9jYXBpdGFsaXplIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJkZWZpbmVkIiwiaXNGdW5jdGlvbiIsInNldHNFcXVhbCIsImEiLCJiIiwic2l6ZSIsIml0ZW0iLCJoYXMiLCJfaXNDbGlja0V2ZW50IiwiZSIsIlBJIiwiTWF0aCIsIlRBVSIsIlBJVEFVIiwiSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsIlJBRF9QRVJfREVHIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwibG9nMTAiLCJzaWduIiwibmljZU51bSIsInJhbmdlIiwicm91bmRlZFJhbmdlIiwicm91bmQiLCJhbG1vc3RFcXVhbHMiLCJuaWNlUmFuZ2UiLCJwb3ciLCJmbG9vciIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwiX2ZhY3Rvcml6ZSIsInJlc3VsdCIsInNxcnQiLCJzb3J0IiwicG9wIiwiaXNOdW1iZXIiLCJuIiwiaXNOYU4iLCJlcHNpbG9uIiwiYWJzIiwiYWxtb3N0V2hvbGUiLCJyb3VuZGVkIiwiX3NldE1pbkFuZE1heEJ5S2V5IiwiYXJyYXkiLCJwcm9wZXJ0eSIsIm1pbiIsIm1heCIsInRvUmFkaWFucyIsImRlZ3JlZXMiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiX2RlY2ltYWxQbGFjZXMiLCJwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0YW5jZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsIl9hbmdsZURpZmYiLCJfbm9ybWFsaXplQW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwic3RhcnQiLCJlbmQiLCJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCJzIiwiYW5nbGVUb1N0YXJ0IiwiYW5nbGVUb0VuZCIsInN0YXJ0VG9BbmdsZSIsImVuZFRvQW5nbGUiLCJfbGltaXRWYWx1ZSIsIl9pbnQxNlJhbmdlIiwiX2lzQmV0d2VlbiIsIl9sb29rdXAiLCJ0YWJsZSIsImNtcCIsImhpIiwibG8iLCJtaWQiLCJfbG9va3VwQnlLZXkiLCJsYXN0IiwiX3Jsb29rdXBCeUtleSIsIl9maWx0ZXJCZXR3ZWVuIiwidmFsdWVzIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImxpc3RlbmVyIiwiX2NoYXJ0anMiLCJsaXN0ZW5lcnMiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJmb3JFYWNoIiwibWV0aG9kIiwiYmFzZSIsInJlcyIsIm9iamVjdCIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJzdHViIiwic3BsaWNlIiwiX2FycmF5VW5pcXVlIiwiaXRlbXMiLCJzZXQiLCJTZXQiLCJhZGQiLCJmcm9tIiwiZm9udFN0cmluZyIsInBpeGVsU2l6ZSIsImZvbnRTdHlsZSIsImZvbnRGYW1pbHkiLCJyZXF1ZXN0QW5pbUZyYW1lIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGhyb3R0bGVkIiwidXBkYXRlRm4iLCJ1cGRhdGVBcmdzIiwidGlja2luZyIsInJlc3QiLCJkZWJvdW5jZSIsImRlbGF5IiwidGltZW91dCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJfdG9MZWZ0UmlnaHRDZW50ZXIiLCJhbGlnbiIsIl9hbGlnblN0YXJ0RW5kIiwiX3RleHRYIiwibGVmdCIsInJpZ2h0IiwicnRsIiwiY2hlY2siLCJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsIm1ldGEiLCJwb2ludHMiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJwb2ludENvdW50IiwiY291bnQiLCJfc29ydGVkIiwiaVNjYWxlIiwiX3BhcnNlZCIsImF4aXMiLCJtaW5EZWZpbmVkIiwibWF4RGVmaW5lZCIsImdldFVzZXJCb3VuZHMiLCJnZXRQaXhlbEZvclZhbHVlIiwiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsInhTY2FsZSIsInlTY2FsZSIsIl9zY2FsZVJhbmdlcyIsIm5ld1JhbmdlcyIsInhtaW4iLCJ4bWF4IiwieW1pbiIsInltYXgiLCJjaGFuZ2VkIiwiYXNzaWduIiwiYXRFZGdlIiwidCIsImVsYXN0aWNJbiIsInNpbiIsImVsYXN0aWNPdXQiLCJlZmZlY3RzIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJjb3MiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsIm0iLCJkIiwiZWFzZUluT3V0Qm91bmNlIiwibGltIiwibCIsImgiLCJwMmIiLCJuMmIiLCJiMm4iLCJuMnAiLCJtYXAkMSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImMiLCJmIiwiaGV4IiwiaDEiLCJoMiIsImVxIiwiaXNTaG9ydCIsInIiLCJnIiwiaGV4UGFyc2UiLCJyZXQiLCJhbHBoYSIsImhleFN0cmluZyIsIkhVRV9SRSIsImhzbDJyZ2JuIiwiaHN2MnJnYm4iLCJod2IycmdibiIsInciLCJyZ2IiLCJodWVWYWx1ZSIsInJnYjJoc2wiLCJjYWxsbiIsImhzbDJyZ2IiLCJod2IycmdiIiwiaHN2MnJnYiIsImh1ZSIsImh1ZVBhcnNlIiwiZXhlYyIsInAxIiwicDIiLCJyb3RhdGUiLCJkZWciLCJoc2xTdHJpbmciLCJaIiwiWSIsIlgiLCJXIiwiViIsIlUiLCJUIiwiUyIsIlIiLCJRIiwiUCIsIk8iLCJOIiwiTSIsIkwiLCJLIiwiRyIsIkgiLCJJIiwiSiIsIm5hbWVzJDEiLCJPaWNlWGUiLCJhbnRpcXVld0V0ZSIsImFxdWEiLCJhcXVhbWFyUmUiLCJhenVZIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5LZWRPbW9uZCIsIlhlIiwiWGV2aVRldCIsImJQd24iLCJidXJseXdvb2QiLCJjYU10WGUiLCJLYXJ0WXVzZSIsIktvY1RhdGUiLCJjU08iLCJjU25mbG93ZXJYZSIsImNTbnNpbGsiLCJjcmltc29uIiwiY3lhbiIsInhYZSIsInhjeWFuIiwieGdUTW5QZCIsInhXYXkiLCJ4Z1lGIiwieGdZeSIsInhraGFraSIsInhtYWdGdGEiLCJ4VGl2ZWdZRiIsInhTYW5nZSIsInhTY0VkIiwieFlkIiwieHNPbW9uIiwieHNIZ1lGIiwieFVYZSIsInhVV2F5IiwieFVnWXkiLCJ4UWUiLCJ4dmlUZXQiLCJkQXBwUmsiLCJkQXBza3lYZSIsImRpbVdheSIsImRpbWdZeSIsImRvZGdlclhlIiwiZmlZYnJpY2siLCJmbFNPd0V0ZSIsImZvWXN0V0FuIiwiZnVLc2lhIiwiZ2FSc2JTbyIsImdob3N0d0V0ZSIsImdUZCIsImdUTW5QZCIsIldheSIsImdZRiIsImdZRkx3IiwiZ1l5IiwiaG9uZXlNdyIsImhvdHBSayIsIlJkaWFuWWQiLCJSZGlnbyIsIml2U3kiLCJraGFraSIsImxhdkZNciIsImxhdkZNclhzaCIsImxhd25nWUYiLCJObW9uY0VmZm9uIiwiWlhlIiwiWmNTTyIsIlpjeWFuIiwiWmdUTW5QZEx3IiwiWldheSIsIlpnWUYiLCJaZ1l5IiwiWnBSayIsIlpzT21vbiIsIlpzSGdZRiIsIlpza3lYZSIsIlpVV2F5IiwiWlVnWXkiLCJac3RBbFhlIiwiWkx3IiwibGltZSIsImxpbWVnWUYiLCJsUkYiLCJtYWdGdGEiLCJtYVBvbiIsIlZhcXVhbWFyUmUiLCJWWGUiLCJWU2NFZCIsIlZwdXJwTiIsIlZzSGdZRiIsIlZVWGUiLCJWc3ByUmdnWUYiLCJWUWUiLCJWdmlUZXRZZCIsIm1pZG5pZ2h0WGUiLCJtUnRjWWFtIiwibWlzdHlQc2UiLCJtb2NjYXNSIiwibmF2YWpvd0V0ZSIsIm5hdnkiLCJUZGxhY2UiLCJUaXZlIiwiVGl2ZWRCYiIsIlNhbmdlIiwiU2FuZ2VZZCIsIlNjRWQiLCJwT2VnVE1uUGQiLCJwT2VnWUYiLCJwT2VRZSIsInBPZXZpVGV0WWQiLCJwYXBheWF3RXAiLCJwSEtwdWZmIiwicGVydSIsInBSayIsInBsdW0iLCJwb3dNclhlIiwicHVycE4iLCJZYmVjY2FwdXJwTiIsIllkIiwiUHN5YnJvd24iLCJQeU9YZSIsInNhZGROYlB3biIsInNPbW9uIiwic2FuZHliUHduIiwic0hnWUYiLCJzSHNoZWxsIiwic2lGbmEiLCJzaWx2ZXIiLCJza3lYZSIsIlVYZSIsIlVXYXkiLCJVZ1l5Iiwic25vdyIsInNwclJnZ1lGIiwic3RBbFhlIiwidGFuIiwidGVPIiwidEVzdE4iLCJ0b21hdG8iLCJRZSIsInZpVGV0IiwiSkh0Iiwid0V0ZSIsIndFdGVzbW9rZSIsIkx3IiwiTHdnWUYiLCJ1bnBhY2siLCJ1bnBhY2tlZCIsInRrZXlzIiwiaiIsIm9rIiwibmsiLCJyZXBsYWNlIiwicGFyc2VJbnQiLCJuYW1lcyIsIm5hbWVQYXJzZSIsInRyYW5zcGFyZW50IiwidG9Mb3dlckNhc2UiLCJSR0JfUkUiLCJyZ2JQYXJzZSIsInJnYlN0cmluZyIsInRvIiwiaW50ZXJwb2xhdGUiLCJyZ2IxIiwicmdiMiIsIm1vZEhTTCIsInJhdGlvIiwiY2xvbmUiLCJwcm90byIsImZyb21PYmplY3QiLCJpbnB1dCIsImZ1bmN0aW9uUGFyc2UiLCJDb2xvciIsImNvbnN0cnVjdG9yIiwiX3JnYiIsIl92YWxpZCIsInZhbGlkIiwibWl4IiwiY29sb3IiLCJ3ZWlnaHQiLCJjMSIsImMyIiwidzIiLCJ3MSIsImNsZWFyZXIiLCJncmV5c2NhbGUiLCJ2YWwiLCJvcGFxdWVyIiwibmVnYXRlIiwibGlnaHRlbiIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsImluZGV4X2VzbSIsImlzUGF0dGVybk9yR3JhZGllbnQiLCJnZXRIb3ZlckNvbG9yIiwib3ZlcnJpZGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRTY29wZSQxIiwibm9kZSIsInJvb3QiLCJEZWZhdWx0cyIsIl9kZXNjcmlwdG9ycyIsImFuaW1hdGlvbiIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiZGF0YXNldHMiLCJkZXZpY2VQaXhlbFJhdGlvIiwiY29udGV4dCIsImNoYXJ0IiwicGxhdGZvcm0iLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiZWxlbWVudHMiLCJldmVudHMiLCJmb250IiwiZmFtaWx5Iiwic3R5bGUiLCJsaW5lSGVpZ2h0IiwiaG92ZXIiLCJob3ZlckJhY2tncm91bmRDb2xvciIsImN0eCIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckNvbG9yIiwiaW5kZXhBeGlzIiwiaW50ZXJhY3Rpb24iLCJtb2RlIiwiaW50ZXJzZWN0IiwiaW5jbHVkZUludmlzaWJsZSIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJvbkhvdmVyIiwib25DbGljayIsInBhcnNpbmciLCJwbHVnaW5zIiwicmVzcG9uc2l2ZSIsInNjYWxlIiwic2NhbGVzIiwic2hvd0xpbmUiLCJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsImRlc2NyaWJlIiwiZ2V0Iiwib3ZlcnJpZGUiLCJyb3V0ZSIsIm5hbWUiLCJ0YXJnZXRTY29wZSIsInRhcmdldE5hbWUiLCJzY29wZU9iamVjdCIsInRhcmdldFNjb3BlT2JqZWN0IiwicHJpdmF0ZU5hbWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJsb2NhbCIsImRlZmF1bHRzIiwiX3NjcmlwdGFibGUiLCJzdGFydHNXaXRoIiwiX2luZGV4YWJsZSIsIl9mYWxsYmFjayIsInRvRm9udFN0cmluZyIsIl9tZWFzdXJlVGV4dCIsImRhdGEiLCJnYyIsImxvbmdlc3QiLCJzdHJpbmciLCJ0ZXh0V2lkdGgiLCJtZWFzdXJlVGV4dCIsIndpZHRoIiwiX2xvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImNhY2hlIiwiZ2FyYmFnZUNvbGxlY3QiLCJzYXZlIiwiamxlbiIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJyZXN0b3JlIiwiZ2NMZW4iLCJfYWxpZ25QaXhlbCIsInBpeGVsIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJoYWxmV2lkdGgiLCJjbGVhckNhbnZhcyIsImNhbnZhcyIsImdldENvbnRleHQiLCJyZXNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsImhlaWdodCIsImRyYXdQb2ludCIsImRyYXdQb2ludExlZ2VuZCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyUmFkaXVzIiwicG9pbnRTdHlsZSIsInJvdGF0aW9uIiwicmFkaXVzIiwicmFkIiwidHJhbnNsYXRlIiwiZHJhd0ltYWdlIiwiYmVnaW5QYXRoIiwiZWxsaXBzZSIsImFyYyIsImNsb3NlUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsIlNRUlQxXzIiLCJyZWN0IiwiZmlsbCIsImJvcmRlcldpZHRoIiwic3Ryb2tlIiwiX2lzUG9pbnRJbkFyZWEiLCJwb2ludCIsImFyZWEiLCJtYXJnaW4iLCJ0b3AiLCJib3R0b20iLCJjbGlwQXJlYSIsImNsaXAiLCJ1bmNsaXBBcmVhIiwiX3N0ZXBwZWRMaW5lVG8iLCJmbGlwIiwibWlkcG9pbnQiLCJfYmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJjcDF4IiwiY3AyeCIsImNwMXkiLCJjcDJ5IiwicmVuZGVyVGV4dCIsInRleHQiLCJvcHRzIiwibGluZXMiLCJzdHJva2VXaWR0aCIsInN0cm9rZUNvbG9yIiwibGluZSIsInNldFJlbmRlck9wdHMiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZVRleHQiLCJtYXhXaWR0aCIsImZpbGxUZXh0IiwiZGVjb3JhdGVUZXh0IiwidHJhbnNsYXRpb24iLCJmaWxsU3R5bGUiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJzdHJpa2V0aHJvdWdoIiwidW5kZXJsaW5lIiwibWV0cmljcyIsImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsInlEZWNvcmF0aW9uIiwiZGVjb3JhdGlvbldpZHRoIiwiYWRkUm91bmRlZFJlY3RQYXRoIiwidG9wTGVmdCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsInRvcFJpZ2h0IiwiTElORV9IRUlHSFQiLCJSZWdFeHAiLCJGT05UX1NUWUxFIiwidG9MaW5lSGVpZ2h0IiwibWF0Y2hlcyIsIm1hdGNoIiwibnVtYmVyT3JaZXJvIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJwcm9wcyIsIm9ialByb3BzIiwicmVhZCIsInByb3AiLCJ0b1RSQkwiLCJ0b1RSQkxDb3JuZXJzIiwidG9QYWRkaW5nIiwidG9Gb250IiwiZmFsbGJhY2siLCJyZXNvbHZlIiwiaW5wdXRzIiwiaW5mbyIsImNhY2hlYWJsZSIsIl9hZGRHcmFjZSIsIm1pbm1heCIsImdyYWNlIiwiYmVnaW5BdFplcm8iLCJjaGFuZ2UiLCJrZWVwWmVybyIsImNyZWF0ZUNvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiX2NyZWF0ZVJlc29sdmVyIiwic2NvcGVzIiwicHJlZml4ZXMiLCJyb290U2NvcGVzIiwiZ2V0VGFyZ2V0IiwiX3Jlc29sdmUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9jYWNoZWFibGUiLCJfc2NvcGVzIiwiX3Jvb3RTY29wZXMiLCJfZ2V0VGFyZ2V0IiwiUHJveHkiLCJkZWxldGVQcm9wZXJ0eSIsIl9rZXlzIiwiX2NhY2hlZCIsIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImdldFByb3RvdHlwZU9mIiwiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCJpbmNsdWRlcyIsIm93bktleXMiLCJzdG9yYWdlIiwiX3N0b3JhZ2UiLCJfYXR0YWNoQ29udGV4dCIsInByb3h5Iiwic3ViUHJveHkiLCJkZXNjcmlwdG9yRGVmYXVsdHMiLCJfcHJveHkiLCJfY29udGV4dCIsIl9zdWJQcm94eSIsIl9zdGFjayIsInNldENvbnRleHQiLCJyZWNlaXZlciIsIl9yZXNvbHZlV2l0aENvbnRleHQiLCJhbGxLZXlzIiwic2NyaXB0YWJsZSIsImluZGV4YWJsZSIsIl9hbGxLZXlzIiwiaXNTY3JpcHRhYmxlIiwiaXNJbmRleGFibGUiLCJyZWFkS2V5IiwicHJlZml4IiwibmVlZHNTdWJSZXNvbHZlciIsIl9yZXNvbHZlU2NyaXB0YWJsZSIsIl9yZXNvbHZlQXJyYXkiLCJFcnJvciIsImpvaW4iLCJkZWxldGUiLCJjcmVhdGVTdWJSZXNvbHZlciIsImFyciIsImZpbHRlciIsInJlc29sdmVGYWxsYmFjayIsImdldFNjb3BlIiwicGFyZW50IiwiYWRkU2NvcGVzIiwicGFyZW50U2NvcGVzIiwicGFyZW50RmFsbGJhY2siLCJhbGxTY29wZXMiLCJhZGRTY29wZXNGcm9tS2V5Iiwic3ViR2V0VGFyZ2V0IiwicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwiX3BhcnNpbmciLCJwYXJzZWQiLCJwYXJzZSIsIkVQU0lMT04iLCJnZXRQb2ludCIsInNraXAiLCJnZXRWYWx1ZUF4aXMiLCJzcGxpbmVDdXJ2ZSIsImZpcnN0UG9pbnQiLCJtaWRkbGVQb2ludCIsImFmdGVyUG9pbnQiLCJuZXh0IiwiZDAxIiwiZDEyIiwiczAxIiwiczEyIiwiZmEiLCJmYiIsIm1vbm90b25lQWRqdXN0IiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwicG9pbnRDdXJyZW50IiwicG9pbnRBZnRlciIsIm1vbm90b25lQ29tcHV0ZSIsInZhbHVlQXhpcyIsImRlbHRhIiwicG9pbnRCZWZvcmUiLCJpUGl4ZWwiLCJ2UGl4ZWwiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic2xvcGVEZWx0YSIsImNhcENvbnRyb2xQb2ludCIsInB0IiwiY2FwQmV6aWVyUG9pbnRzIiwiaW5BcmVhIiwiaW5BcmVhUHJldiIsImluQXJlYU5leHQiLCJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImxvb3AiLCJjb250cm9sUG9pbnRzIiwic3BhbkdhcHMiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwicHJldiIsInRlbnNpb24iLCJfaXNEb21TdXBwb3J0ZWQiLCJkb2N1bWVudCIsIl9nZXRQYXJlbnROb2RlIiwiZG9tTm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwicGFyc2VNYXhTdHlsZSIsInN0eWxlVmFsdWUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZWxlbWVudCIsImdldFN0eWxlIiwiZWwiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb25lZFN0eWxlIiwic3R5bGVzIiwic3VmZml4IiwicG9zIiwidXNlT2Zmc2V0UG9zIiwic2hhZG93Um9vdCIsImdldENhbnZhc1Bvc2l0aW9uIiwidG91Y2hlcyIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiZXZ0IiwiYm9yZGVyQm94IiwiYm94U2l6aW5nIiwicGFkZGluZ3MiLCJib3JkZXJzIiwiZ2V0Q29udGFpbmVyU2l6ZSIsIm1heEhlaWdodCIsImNvbnRhaW5lciIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY29udGFpbmVyU3R5bGUiLCJjb250YWluZXJCb3JkZXIiLCJjb250YWluZXJQYWRkaW5nIiwicm91bmQxIiwiZ2V0TWF4aW11bVNpemUiLCJiYldpZHRoIiwiYmJIZWlnaHQiLCJhc3BlY3RSYXRpbyIsIm1hcmdpbnMiLCJjb250YWluZXJTaXplIiwicmV0aW5hU2NhbGUiLCJmb3JjZVJhdGlvIiwiZm9yY2VTdHlsZSIsInBpeGVsUmF0aW8iLCJkZXZpY2VIZWlnaHQiLCJkZXZpY2VXaWR0aCIsInNldFRyYW5zZm9ybSIsInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlU3VwcG9ydGVkIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhZFVzZWRTaXplIiwiX3BvaW50SW5MaW5lIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiX2JlemllckludGVycG9sYXRpb24iLCJjcDEiLCJjcDIiLCJpbnRsQ2FjaGUiLCJNYXAiLCJnZXROdW1iZXJGb3JtYXQiLCJsb2NhbGUiLCJjYWNoZUtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JtYXR0ZXIiLCJJbnRsIiwiTnVtYmVyRm9ybWF0IiwiZm9ybWF0TnVtYmVyIiwibnVtIiwiZm9ybWF0IiwiZ2V0UmlnaHRUb0xlZnRBZGFwdGVyIiwicmVjdFgiLCJzZXRXaWR0aCIsInhQbHVzIiwibGVmdEZvckx0ciIsIml0ZW1XaWR0aCIsImdldExlZnRUb1JpZ2h0QWRhcHRlciIsIl9pdGVtV2lkdGgiLCJnZXRSdGxBZGFwdGVyIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwib3JpZ2luYWwiLCJnZXRQcm9wZXJ0eVByaW9yaXR5Iiwic2V0UHJvcGVydHkiLCJwcmV2VGV4dERpcmVjdGlvbiIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwicHJvcGVydHlGbiIsImJldHdlZW4iLCJjb21wYXJlIiwibm9ybWFsaXplIiwibm9ybWFsaXplU2VnbWVudCIsImdldFNlZ21lbnQiLCJzZWdtZW50IiwiYm91bmRzIiwic3RhcnRCb3VuZCIsImVuZEJvdW5kIiwiX2JvdW5kU2VnbWVudCIsImluc2lkZSIsInN1YlN0YXJ0IiwicHJldlZhbHVlIiwic3RhcnRJc0JlZm9yZSIsImVuZElzQmVmb3JlIiwic2hvdWxkU3RhcnQiLCJzaG91bGRTdG9wIiwiX2JvdW5kU2VnbWVudHMiLCJzZWdtZW50cyIsInN1YiIsImZpbmRTdGFydEFuZEVuZCIsInNvbGlkU2VnbWVudHMiLCJjdXIiLCJzdG9wIiwiX2NvbXB1dGVTZWdtZW50cyIsInNlZ21lbnRPcHRpb25zIiwiX2xvb3AiLCJzcGxpdEJ5U3R5bGVzIiwiY29tcGxldGVMb29wIiwiX2Z1bGxMb29wIiwiZG9TcGxpdEJ5U3R5bGVzIiwiY2hhcnRDb250ZXh0IiwiX2NoYXJ0IiwiYmFzZVN0eWxlIiwicmVhZFN0eWxlIiwiX2RhdGFzZXRJbmRleCIsInByZXZTdHlsZSIsImFkZFN0eWxlIiwic3QiLCJkaXIiLCJwMCIsInAwRGF0YUluZGV4IiwicDFEYXRhSW5kZXgiLCJzdHlsZUNoYW5nZWQiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwiJCIsIl8iLCJhJCIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhQSIsImFCIiwiYUMiLCJhRCIsImFFIiwiYUYiLCJhRyIsImFIIiwiYUkiLCJhSiIsImFLIiwiYUwiLCJhTSIsImFOIiwiYU8iLCJhUCIsImFRIiwiYVIiLCJhUyIsImFUIiwiYVUiLCJhViIsImFXIiwiYVgiLCJhWSIsImFaIiwiYV8iLCJhYSIsImFiIiwiYWMiLCJhZCIsImFlIiwiYWYiLCJhZyIsImFoIiwiYWkiLCJhaiIsImFrIiwiYWwiLCJhbSIsImFuIiwiYW8iLCJhcCIsImFxIiwiYXIiLCJhcyIsImF0IiwiYXUiLCJhdiIsImF3IiwiYXgiLCJheSIsImF6IiwiYjAiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwicSIsInUiLCJ6Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/helpers.mjs":
/*!************************************************!*\
  !*** ./node_modules/chart.js/dist/helpers.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HALF_PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   INFINITY: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b1),\n/* harmony export */   PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PITAU: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b0),\n/* harmony export */   QUARTER_PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b3),\n/* harmony export */   RAD_PER_DEG: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b2),\n/* harmony export */   TAU: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TWO_THIRDS_PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b4),\n/* harmony export */   _addGrace: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   _alignPixel: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   _alignStartEnd: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   _angleBetween: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   _angleDiff: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b5),\n/* harmony export */   _arrayUnique: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   _attachContext: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9),\n/* harmony export */   _bezierCurveTo: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   _bezierInterpolation: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   _boundSegment: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ay),\n/* harmony export */   _boundSegments: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   _capitalize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   _computeSegments: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   _createResolver: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   _decimalPlaces: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL),\n/* harmony export */   _deprecated: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aU),\n/* harmony export */   _descriptors: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   _elementsEqual: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   _factorize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   _filterBetween: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aN),\n/* harmony export */   _getParentNode: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   _getStartAndCountOfVisiblePoints: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   _int16Range: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   _isBetween: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   _isClickEvent: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   _isDomSupported: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   _isPointInArea: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   _limitValue: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   _longestText: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aM),\n/* harmony export */   _lookup: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aO),\n/* harmony export */   _lookupByKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   _measureText: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   _merger: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aS),\n/* harmony export */   _mergerIf: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aT),\n/* harmony export */   _normalizeAngle: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az),\n/* harmony export */   _parseObjectDataRadialScale: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   _pointInLine: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   _readValueToProps: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   _rlookupByKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   _scaleRangesChanged: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   _setMinAndMaxByKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH),\n/* harmony export */   _splitKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aV),\n/* harmony export */   _steppedInterpolation: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   _steppedLineTo: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   _textX: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aC),\n/* harmony export */   _toLeftRightCenter: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   _updateBezierControlPoints: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   addRoundedRectPath: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av),\n/* harmony export */   almostEquals: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK),\n/* harmony export */   almostWhole: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aJ),\n/* harmony export */   callback: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   clearCanvas: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   clipArea: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   clone: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aR),\n/* harmony export */   color: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createContext: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   debounce: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   defined: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   distanceBetweenPoints: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aG),\n/* harmony export */   drawPoint: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au),\n/* harmony export */   drawPointLegend: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aE),\n/* harmony export */   each: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   easingEffects: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   finiteOrDefault: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   fontString: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a_),\n/* harmony export */   formatNumber: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getAngleFromPoint: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   getHoverColor: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aQ),\n/* harmony export */   getMaximumSize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   getRelativePosition: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   getRtlAdapter: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA),\n/* harmony export */   getStyle: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aZ),\n/* harmony export */   isArray: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   isFinite: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   isFunction: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   isNullOrUndef: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   isNumber: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   isObject: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   isPatternOrGradient: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aP),\n/* harmony export */   listenArrayEvents: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   log10: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   merge: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   mergeIf: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   niceNum: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI),\n/* harmony export */   noop: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF),\n/* harmony export */   overrideTextDirection: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB),\n/* harmony export */   readUsedSize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   renderText: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   requestAnimFrame: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   resolve: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   resolveObjectKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   restoreTextDirection: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD),\n/* harmony export */   retinaScale: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   setsEqual: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   sign: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   splineCurve: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aX),\n/* harmony export */   splineCurveMonotone: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aY),\n/* harmony export */   supportsEventListenerOptions: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   throttled: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   toDegrees: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   toDimension: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   toFont: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   toFontString: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aW),\n/* harmony export */   toLineHeight: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a$),\n/* harmony export */   toPadding: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   toPercentage: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   toRadians: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   toTRBL: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aw),\n/* harmony export */   toTRBLCorners: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax),\n/* harmony export */   uid: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   unclipArea: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   unlistenArrayEvents: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   valueOrDefault: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ28zRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhbG1pbGhhbmRvLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvaGVscGVycy5tanM/MWZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmV4cG9ydCB7IEggYXMgSEFMRl9QSSwgYjEgYXMgSU5GSU5JVFksIFAgYXMgUEksIGIwIGFzIFBJVEFVLCBiMyBhcyBRVUFSVEVSX1BJLCBiMiBhcyBSQURfUEVSX0RFRywgVCBhcyBUQVUsIGI0IGFzIFRXT19USElSRFNfUEksIEQgYXMgX2FkZEdyYWNlLCBKIGFzIF9hbGlnblBpeGVsLCBTIGFzIF9hbGlnblN0YXJ0RW5kLCBwIGFzIF9hbmdsZUJldHdlZW4sIGI1IGFzIF9hbmdsZURpZmYsIF8gYXMgX2FycmF5VW5pcXVlLCBhOSBhcyBfYXR0YWNoQ29udGV4dCwgYXQgYXMgX2JlemllckN1cnZlVG8sIGFxIGFzIF9iZXppZXJJbnRlcnBvbGF0aW9uLCBheSBhcyBfYm91bmRTZWdtZW50LCBhbyBhcyBfYm91bmRTZWdtZW50cywgVyBhcyBfY2FwaXRhbGl6ZSwgYW4gYXMgX2NvbXB1dGVTZWdtZW50cywgYWEgYXMgX2NyZWF0ZVJlc29sdmVyLCBhTCBhcyBfZGVjaW1hbFBsYWNlcywgYVUgYXMgX2RlcHJlY2F0ZWQsIGFiIGFzIF9kZXNjcmlwdG9ycywgYWkgYXMgX2VsZW1lbnRzRXF1YWwsIEEgYXMgX2ZhY3Rvcml6ZSwgYU4gYXMgX2ZpbHRlckJldHdlZW4sIGEyIGFzIF9nZXRQYXJlbnROb2RlLCBxIGFzIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBJIGFzIF9pbnQxNlJhbmdlLCBhayBhcyBfaXNCZXR3ZWVuLCBhaiBhcyBfaXNDbGlja0V2ZW50LCBhNiBhcyBfaXNEb21TdXBwb3J0ZWQsICQgYXMgX2lzUG9pbnRJbkFyZWEsIEUgYXMgX2xpbWl0VmFsdWUsIGFNIGFzIF9sb25nZXN0VGV4dCwgYU8gYXMgX2xvb2t1cCwgWiBhcyBfbG9va3VwQnlLZXksIEcgYXMgX21lYXN1cmVUZXh0LCBhUyBhcyBfbWVyZ2VyLCBhVCBhcyBfbWVyZ2VySWYsIGF6IGFzIF9ub3JtYWxpemVBbmdsZSwgeSBhcyBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUsIGFyIGFzIF9wb2ludEluTGluZSwgYWwgYXMgX3JlYWRWYWx1ZVRvUHJvcHMsIFkgYXMgX3Jsb29rdXBCeUtleSwgdyBhcyBfc2NhbGVSYW5nZXNDaGFuZ2VkLCBhSCBhcyBfc2V0TWluQW5kTWF4QnlLZXksIGFWIGFzIF9zcGxpdEtleSwgYXAgYXMgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uLCBhcyBhcyBfc3RlcHBlZExpbmVUbywgYUMgYXMgX3RleHRYLCBSIGFzIF90b0xlZnRSaWdodENlbnRlciwgYW0gYXMgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMsIGF2IGFzIGFkZFJvdW5kZWRSZWN0UGF0aCwgYUsgYXMgYWxtb3N0RXF1YWxzLCBhSiBhcyBhbG1vc3RXaG9sZSwgQyBhcyBjYWxsYmFjaywgYWcgYXMgY2xlYXJDYW52YXMsIEwgYXMgY2xpcEFyZWEsIGFSIGFzIGNsb25lLCBjIGFzIGNvbG9yLCBoIGFzIGNyZWF0ZUNvbnRleHQsIGFlIGFzIGRlYm91bmNlLCBqIGFzIGRlZmluZWQsIGFHIGFzIGRpc3RhbmNlQmV0d2VlblBvaW50cywgYXUgYXMgZHJhd1BvaW50LCBhRSBhcyBkcmF3UG9pbnRMZWdlbmQsIFEgYXMgZWFjaCwgZSBhcyBlYXNpbmdFZmZlY3RzLCBCIGFzIGZpbml0ZU9yRGVmYXVsdCwgYV8gYXMgZm9udFN0cmluZywgbyBhcyBmb3JtYXROdW1iZXIsIGEwIGFzIGdldEFuZ2xlRnJvbVBvaW50LCBhUSBhcyBnZXRIb3ZlckNvbG9yLCBhMSBhcyBnZXRNYXhpbXVtU2l6ZSwgWCBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBhQSBhcyBnZXRSdGxBZGFwdGVyLCBhWiBhcyBnZXRTdHlsZSwgYiBhcyBpc0FycmF5LCBnIGFzIGlzRmluaXRlLCBhOCBhcyBpc0Z1bmN0aW9uLCBrIGFzIGlzTnVsbE9yVW5kZWYsIHggYXMgaXNOdW1iZXIsIGkgYXMgaXNPYmplY3QsIGFQIGFzIGlzUGF0dGVybk9yR3JhZGllbnQsIGwgYXMgbGlzdGVuQXJyYXlFdmVudHMsIHogYXMgbG9nMTAsIFYgYXMgbWVyZ2UsIGFjIGFzIG1lcmdlSWYsIGFJIGFzIG5pY2VOdW0sIGFGIGFzIG5vb3AsIGFCIGFzIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgYTMgYXMgcmVhZFVzZWRTaXplLCBNIGFzIHJlbmRlclRleHQsIHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGFEIGFzIHJlc3RvcmVUZXh0RGlyZWN0aW9uLCBhZiBhcyByZXRpbmFTY2FsZSwgYWggYXMgc2V0c0VxdWFsLCBzIGFzIHNpZ24sIGFYIGFzIHNwbGluZUN1cnZlLCBhWSBhcyBzcGxpbmVDdXJ2ZU1vbm90b25lLCBhNSBhcyBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCBhNCBhcyB0aHJvdHRsZWQsIEYgYXMgdG9EZWdyZWVzLCBuIGFzIHRvRGltZW5zaW9uLCBPIGFzIHRvRm9udCwgYVcgYXMgdG9Gb250U3RyaW5nLCBhJCBhcyB0b0xpbmVIZWlnaHQsIEsgYXMgdG9QYWRkaW5nLCBtIGFzIHRvUGVyY2VudGFnZSwgdCBhcyB0b1JhZGlhbnMsIGF3IGFzIHRvVFJCTCwgYXggYXMgdG9UUkJMQ29ybmVycywgYWQgYXMgdWlkLCBOIGFzIHVuY2xpcEFyZWEsIHUgYXMgdW5saXN0ZW5BcnJheUV2ZW50cywgdiBhcyB2YWx1ZU9yRGVmYXVsdCB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMnO1xuIl0sIm5hbWVzIjpbIkgiLCJIQUxGX1BJIiwiYjEiLCJJTkZJTklUWSIsIlAiLCJQSSIsImIwIiwiUElUQVUiLCJiMyIsIlFVQVJURVJfUEkiLCJiMiIsIlJBRF9QRVJfREVHIiwiVCIsIlRBVSIsImI0IiwiVFdPX1RISVJEU19QSSIsIkQiLCJfYWRkR3JhY2UiLCJKIiwiX2FsaWduUGl4ZWwiLCJTIiwiX2FsaWduU3RhcnRFbmQiLCJwIiwiX2FuZ2xlQmV0d2VlbiIsImI1IiwiX2FuZ2xlRGlmZiIsIl8iLCJfYXJyYXlVbmlxdWUiLCJhOSIsIl9hdHRhY2hDb250ZXh0IiwiYXQiLCJfYmV6aWVyQ3VydmVUbyIsImFxIiwiX2JlemllckludGVycG9sYXRpb24iLCJheSIsIl9ib3VuZFNlZ21lbnQiLCJhbyIsIl9ib3VuZFNlZ21lbnRzIiwiVyIsIl9jYXBpdGFsaXplIiwiYW4iLCJfY29tcHV0ZVNlZ21lbnRzIiwiYWEiLCJfY3JlYXRlUmVzb2x2ZXIiLCJhTCIsIl9kZWNpbWFsUGxhY2VzIiwiYVUiLCJfZGVwcmVjYXRlZCIsImFiIiwiX2Rlc2NyaXB0b3JzIiwiYWkiLCJfZWxlbWVudHNFcXVhbCIsIkEiLCJfZmFjdG9yaXplIiwiYU4iLCJfZmlsdGVyQmV0d2VlbiIsImEyIiwiX2dldFBhcmVudE5vZGUiLCJxIiwiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJJIiwiX2ludDE2UmFuZ2UiLCJhayIsIl9pc0JldHdlZW4iLCJhaiIsIl9pc0NsaWNrRXZlbnQiLCJhNiIsIl9pc0RvbVN1cHBvcnRlZCIsIiQiLCJfaXNQb2ludEluQXJlYSIsIkUiLCJfbGltaXRWYWx1ZSIsImFNIiwiX2xvbmdlc3RUZXh0IiwiYU8iLCJfbG9va3VwIiwiWiIsIl9sb29rdXBCeUtleSIsIkciLCJfbWVhc3VyZVRleHQiLCJhUyIsIl9tZXJnZXIiLCJhVCIsIl9tZXJnZXJJZiIsImF6IiwiX25vcm1hbGl6ZUFuZ2xlIiwieSIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsImFyIiwiX3BvaW50SW5MaW5lIiwiYWwiLCJfcmVhZFZhbHVlVG9Qcm9wcyIsIlkiLCJfcmxvb2t1cEJ5S2V5IiwidyIsIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCJhSCIsIl9zZXRNaW5BbmRNYXhCeUtleSIsImFWIiwiX3NwbGl0S2V5IiwiYXAiLCJfc3RlcHBlZEludGVycG9sYXRpb24iLCJhcyIsIl9zdGVwcGVkTGluZVRvIiwiYUMiLCJfdGV4dFgiLCJSIiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiYW0iLCJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImF2IiwiYWRkUm91bmRlZFJlY3RQYXRoIiwiYUsiLCJhbG1vc3RFcXVhbHMiLCJhSiIsImFsbW9zdFdob2xlIiwiQyIsImNhbGxiYWNrIiwiYWciLCJjbGVhckNhbnZhcyIsIkwiLCJjbGlwQXJlYSIsImFSIiwiY2xvbmUiLCJjIiwiY29sb3IiLCJoIiwiY3JlYXRlQ29udGV4dCIsImFlIiwiZGVib3VuY2UiLCJqIiwiZGVmaW5lZCIsImFHIiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwiYXUiLCJkcmF3UG9pbnQiLCJhRSIsImRyYXdQb2ludExlZ2VuZCIsIlEiLCJlYWNoIiwiZSIsImVhc2luZ0VmZmVjdHMiLCJCIiwiZmluaXRlT3JEZWZhdWx0IiwiYV8iLCJmb250U3RyaW5nIiwibyIsImZvcm1hdE51bWJlciIsImEwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJhUSIsImdldEhvdmVyQ29sb3IiLCJhMSIsImdldE1heGltdW1TaXplIiwiWCIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJhQSIsImdldFJ0bEFkYXB0ZXIiLCJhWiIsImdldFN0eWxlIiwiYiIsImlzQXJyYXkiLCJnIiwiaXNGaW5pdGUiLCJhOCIsImlzRnVuY3Rpb24iLCJrIiwiaXNOdWxsT3JVbmRlZiIsIngiLCJpc051bWJlciIsImkiLCJpc09iamVjdCIsImFQIiwiaXNQYXR0ZXJuT3JHcmFkaWVudCIsImwiLCJsaXN0ZW5BcnJheUV2ZW50cyIsInoiLCJsb2cxMCIsIlYiLCJtZXJnZSIsImFjIiwibWVyZ2VJZiIsImFJIiwibmljZU51bSIsImFGIiwibm9vcCIsImFCIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwiYTMiLCJyZWFkVXNlZFNpemUiLCJNIiwicmVuZGVyVGV4dCIsInIiLCJyZXF1ZXN0QW5pbUZyYW1lIiwiYSIsInJlc29sdmUiLCJmIiwicmVzb2x2ZU9iamVjdEtleSIsImFEIiwicmVzdG9yZVRleHREaXJlY3Rpb24iLCJhZiIsInJldGluYVNjYWxlIiwiYWgiLCJzZXRzRXF1YWwiLCJzIiwic2lnbiIsImFYIiwic3BsaW5lQ3VydmUiLCJhWSIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJhNSIsInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJhNCIsInRocm90dGxlZCIsIkYiLCJ0b0RlZ3JlZXMiLCJuIiwidG9EaW1lbnNpb24iLCJPIiwidG9Gb250IiwiYVciLCJ0b0ZvbnRTdHJpbmciLCJhJCIsInRvTGluZUhlaWdodCIsIksiLCJ0b1BhZGRpbmciLCJtIiwidG9QZXJjZW50YWdlIiwidCIsInRvUmFkaWFucyIsImF3IiwidG9UUkJMIiwiYXgiLCJ0b1RSQkxDb3JuZXJzIiwiYWQiLCJ1aWQiLCJOIiwidW5jbGlwQXJlYSIsInUiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwidiIsInZhbHVlT3JEZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/helpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/helpers/helpers.mjs":
/*!***************************************************!*\
  !*** ./node_modules/chart.js/helpers/helpers.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HALF_PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.HALF_PI),\n/* harmony export */   INFINITY: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.INFINITY),\n/* harmony export */   PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PI),\n/* harmony export */   PITAU: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PITAU),\n/* harmony export */   QUARTER_PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI),\n/* harmony export */   RAD_PER_DEG: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.RAD_PER_DEG),\n/* harmony export */   TAU: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.TAU),\n/* harmony export */   TWO_THIRDS_PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.TWO_THIRDS_PI),\n/* harmony export */   _addGrace: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._addGrace),\n/* harmony export */   _alignPixel: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._alignPixel),\n/* harmony export */   _alignStartEnd: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._alignStartEnd),\n/* harmony export */   _angleBetween: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._angleBetween),\n/* harmony export */   _angleDiff: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._angleDiff),\n/* harmony export */   _arrayUnique: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._arrayUnique),\n/* harmony export */   _attachContext: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._attachContext),\n/* harmony export */   _bezierCurveTo: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._bezierCurveTo),\n/* harmony export */   _bezierInterpolation: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._bezierInterpolation),\n/* harmony export */   _boundSegment: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._boundSegment),\n/* harmony export */   _boundSegments: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._boundSegments),\n/* harmony export */   _capitalize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._capitalize),\n/* harmony export */   _computeSegments: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._computeSegments),\n/* harmony export */   _createResolver: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._createResolver),\n/* harmony export */   _decimalPlaces: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._decimalPlaces),\n/* harmony export */   _deprecated: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deprecated),\n/* harmony export */   _descriptors: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._descriptors),\n/* harmony export */   _elementsEqual: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._elementsEqual),\n/* harmony export */   _factorize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._factorize),\n/* harmony export */   _filterBetween: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._filterBetween),\n/* harmony export */   _getParentNode: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._getParentNode),\n/* harmony export */   _getStartAndCountOfVisiblePoints: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._getStartAndCountOfVisiblePoints),\n/* harmony export */   _int16Range: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._int16Range),\n/* harmony export */   _isBetween: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isBetween),\n/* harmony export */   _isClickEvent: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isClickEvent),\n/* harmony export */   _isDomSupported: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isDomSupported),\n/* harmony export */   _isPointInArea: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isPointInArea),\n/* harmony export */   _limitValue: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._limitValue),\n/* harmony export */   _longestText: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._longestText),\n/* harmony export */   _lookup: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._lookup),\n/* harmony export */   _lookupByKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._lookupByKey),\n/* harmony export */   _measureText: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._measureText),\n/* harmony export */   _merger: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._merger),\n/* harmony export */   _mergerIf: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._mergerIf),\n/* harmony export */   _normalizeAngle: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._normalizeAngle),\n/* harmony export */   _parseObjectDataRadialScale: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._parseObjectDataRadialScale),\n/* harmony export */   _pointInLine: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._pointInLine),\n/* harmony export */   _readValueToProps: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._readValueToProps),\n/* harmony export */   _rlookupByKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._rlookupByKey),\n/* harmony export */   _scaleRangesChanged: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._scaleRangesChanged),\n/* harmony export */   _setMinAndMaxByKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._setMinAndMaxByKey),\n/* harmony export */   _splitKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._splitKey),\n/* harmony export */   _steppedInterpolation: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._steppedInterpolation),\n/* harmony export */   _steppedLineTo: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._steppedLineTo),\n/* harmony export */   _textX: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._textX),\n/* harmony export */   _toLeftRightCenter: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._toLeftRightCenter),\n/* harmony export */   _updateBezierControlPoints: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._updateBezierControlPoints),\n/* harmony export */   addRoundedRectPath: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addRoundedRectPath),\n/* harmony export */   almostEquals: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.almostEquals),\n/* harmony export */   almostWhole: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.almostWhole),\n/* harmony export */   callback: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.callback),\n/* harmony export */   clearCanvas: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clearCanvas),\n/* harmony export */   clipArea: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clipArea),\n/* harmony export */   clone: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clone),\n/* harmony export */   color: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.color),\n/* harmony export */   createContext: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.createContext),\n/* harmony export */   debounce: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defined: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.defined),\n/* harmony export */   distanceBetweenPoints: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints),\n/* harmony export */   drawPoint: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.drawPoint),\n/* harmony export */   drawPointLegend: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.drawPointLegend),\n/* harmony export */   each: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.each),\n/* harmony export */   easingEffects: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.easingEffects),\n/* harmony export */   finiteOrDefault: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.finiteOrDefault),\n/* harmony export */   fontString: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.fontString),\n/* harmony export */   formatNumber: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.formatNumber),\n/* harmony export */   getAngleFromPoint: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getAngleFromPoint),\n/* harmony export */   getHoverColor: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getHoverColor),\n/* harmony export */   getMaximumSize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getMaximumSize),\n/* harmony export */   getRelativePosition: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getRelativePosition),\n/* harmony export */   getRtlAdapter: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getRtlAdapter),\n/* harmony export */   getStyle: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getStyle),\n/* harmony export */   isArray: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isArray),\n/* harmony export */   isFinite: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isFinite),\n/* harmony export */   isFunction: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction),\n/* harmony export */   isNullOrUndef: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef),\n/* harmony export */   isNumber: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber),\n/* harmony export */   isObject: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject),\n/* harmony export */   isPatternOrGradient: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isPatternOrGradient),\n/* harmony export */   listenArrayEvents: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.listenArrayEvents),\n/* harmony export */   log10: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.log10),\n/* harmony export */   merge: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.merge),\n/* harmony export */   mergeIf: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.mergeIf),\n/* harmony export */   niceNum: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.niceNum),\n/* harmony export */   noop: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.noop),\n/* harmony export */   overrideTextDirection: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.overrideTextDirection),\n/* harmony export */   readUsedSize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.readUsedSize),\n/* harmony export */   renderText: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.renderText),\n/* harmony export */   requestAnimFrame: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.requestAnimFrame),\n/* harmony export */   resolve: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.resolve),\n/* harmony export */   resolveObjectKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveObjectKey),\n/* harmony export */   restoreTextDirection: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.restoreTextDirection),\n/* harmony export */   retinaScale: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.retinaScale),\n/* harmony export */   setsEqual: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setsEqual),\n/* harmony export */   sign: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.sign),\n/* harmony export */   splineCurve: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.splineCurve),\n/* harmony export */   splineCurveMonotone: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.splineCurveMonotone),\n/* harmony export */   supportsEventListenerOptions: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.supportsEventListenerOptions),\n/* harmony export */   throttled: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.throttled),\n/* harmony export */   toDegrees: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDegrees),\n/* harmony export */   toDimension: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDimension),\n/* harmony export */   toFont: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toFont),\n/* harmony export */   toFontString: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toFontString),\n/* harmony export */   toLineHeight: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toLineHeight),\n/* harmony export */   toPadding: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toPadding),\n/* harmony export */   toPercentage: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toPercentage),\n/* harmony export */   toRadians: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRadians),\n/* harmony export */   toTRBL: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toTRBL),\n/* harmony export */   toTRBLCorners: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toTRBLCorners),\n/* harmony export */   uid: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.uid),\n/* harmony export */   unclipArea: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unclipArea),\n/* harmony export */   unlistenArrayEvents: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unlistenArrayEvents),\n/* harmony export */   valueOrDefault: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)\n/* harmony export */ });\n/* harmony import */ var _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/helpers.mjs */ \"(ssr)/./node_modules/chart.js/dist/helpers.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BhbG1pbGhhbmRvLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2hlbHBlcnMvaGVscGVycy5tanM/NmFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuLi9kaXN0L2hlbHBlcnMubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/helpers/helpers.mjs\n");

/***/ })

};
;