"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chartjs-plugin-datalabels";
exports.ids = ["vendor-chunks/chartjs-plugin-datalabels"];
exports.modules = {

/***/ "(ssr)/./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plugin)\n/* harmony export */ });\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js/helpers */ \"(ssr)/./node_modules/chart.js/helpers/helpers.mjs\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.mjs\");\n/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */ \n\nvar devicePixelRatio = function() {\n    if (false) { var screen; }\n    return 1;\n}();\nvar utils = {\n    // @todo move this in Chart.helpers.toTextLines\n    toTextLines: function(inputs) {\n        var lines = [];\n        var input;\n        inputs = [].concat(inputs);\n        while(inputs.length){\n            input = inputs.pop();\n            if (typeof input === \"string\") {\n                lines.unshift.apply(lines, input.split(\"\\n\"));\n            } else if (Array.isArray(input)) {\n                inputs.push.apply(inputs, input);\n            } else if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(inputs)) {\n                lines.unshift(\"\" + input);\n            }\n        }\n        return lines;\n    },\n    // @todo move this in Chart.helpers.canvas.textSize\n    // @todo cache calls of measureText if font doesn't change?!\n    textSize: function(ctx, lines, font) {\n        var items = [].concat(lines);\n        var ilen = items.length;\n        var prev = ctx.font;\n        var width = 0;\n        var i;\n        ctx.font = font.string;\n        for(i = 0; i < ilen; ++i){\n            width = Math.max(ctx.measureText(items[i]).width, width);\n        }\n        ctx.font = prev;\n        return {\n            height: ilen * font.lineHeight,\n            width: width\n        };\n    },\n    /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */ bound: function(min, value, max) {\n        return Math.max(min, Math.min(value, max));\n    },\n    /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */ arrayDiff: function(a0, a1) {\n        var prev = a0.slice();\n        var updates = [];\n        var i, j, ilen, v;\n        for(i = 0, ilen = a1.length; i < ilen; ++i){\n            v = a1[i];\n            j = prev.indexOf(v);\n            if (j === -1) {\n                updates.push([\n                    v,\n                    1\n                ]);\n            } else {\n                prev.splice(j, 1);\n            }\n        }\n        for(i = 0, ilen = prev.length; i < ilen; ++i){\n            updates.push([\n                prev[i],\n                -1\n            ]);\n        }\n        return updates;\n    },\n    /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */ rasterize: function(v) {\n        return Math.round(v * devicePixelRatio) / devicePixelRatio;\n    }\n};\nfunction orient(point, origin) {\n    var x0 = origin.x;\n    var y0 = origin.y;\n    if (x0 === null) {\n        return {\n            x: 0,\n            y: -1\n        };\n    }\n    if (y0 === null) {\n        return {\n            x: 1,\n            y: 0\n        };\n    }\n    var dx = point.x - x0;\n    var dy = point.y - y0;\n    var ln = Math.sqrt(dx * dx + dy * dy);\n    return {\n        x: ln ? dx / ln : 0,\n        y: ln ? dy / ln : -1\n    };\n}\nfunction aligned(x, y, vx, vy, align) {\n    switch(align){\n        case \"center\":\n            vx = vy = 0;\n            break;\n        case \"bottom\":\n            vx = 0;\n            vy = 1;\n            break;\n        case \"right\":\n            vx = 1;\n            vy = 0;\n            break;\n        case \"left\":\n            vx = -1;\n            vy = 0;\n            break;\n        case \"top\":\n            vx = 0;\n            vy = -1;\n            break;\n        case \"start\":\n            vx = -vx;\n            vy = -vy;\n            break;\n        case \"end\":\n            break;\n        default:\n            // clockwise rotation (in degree)\n            align *= Math.PI / 180;\n            vx = Math.cos(align);\n            vy = Math.sin(align);\n            break;\n    }\n    return {\n        x: x,\n        y: y,\n        vx: vx,\n        vy: vy\n    };\n}\n// Line clipping (Cohen–Sutherland algorithm)\n// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\nfunction region(x, y, rect) {\n    var res = R_INSIDE;\n    if (x < rect.left) {\n        res |= R_LEFT;\n    } else if (x > rect.right) {\n        res |= R_RIGHT;\n    }\n    if (y < rect.top) {\n        res |= R_TOP;\n    } else if (y > rect.bottom) {\n        res |= R_BOTTOM;\n    }\n    return res;\n}\nfunction clipped(segment, area) {\n    var x0 = segment.x0;\n    var y0 = segment.y0;\n    var x1 = segment.x1;\n    var y1 = segment.y1;\n    var r0 = region(x0, y0, area);\n    var r1 = region(x1, y1, area);\n    var r, x, y;\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        if (!(r0 | r1) || r0 & r1) {\n            break;\n        }\n        // at least one point is outside\n        r = r0 || r1;\n        if (r & R_TOP) {\n            x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n            y = area.top;\n        } else if (r & R_BOTTOM) {\n            x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n            y = area.bottom;\n        } else if (r & R_RIGHT) {\n            y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n            x = area.right;\n        } else if (r & R_LEFT) {\n            y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n            x = area.left;\n        }\n        if (r === r0) {\n            x0 = x;\n            y0 = y;\n            r0 = region(x0, y0, area);\n        } else {\n            x1 = x;\n            y1 = y;\n            r1 = region(x1, y1, area);\n        }\n    }\n    return {\n        x0: x0,\n        x1: x1,\n        y0: y0,\n        y1: y1\n    };\n}\nfunction compute$1(range, config) {\n    var anchor = config.anchor;\n    var segment = range;\n    var x, y;\n    if (config.clamp) {\n        segment = clipped(segment, config.area);\n    }\n    if (anchor === \"start\") {\n        x = segment.x0;\n        y = segment.y0;\n    } else if (anchor === \"end\") {\n        x = segment.x1;\n        y = segment.y1;\n    } else {\n        x = (segment.x0 + segment.x1) / 2;\n        y = (segment.y0 + segment.y1) / 2;\n    }\n    return aligned(x, y, range.vx, range.vy, config.align);\n}\nvar positioners = {\n    arc: function(el, config) {\n        var angle = (el.startAngle + el.endAngle) / 2;\n        var vx = Math.cos(angle);\n        var vy = Math.sin(angle);\n        var r0 = el.innerRadius;\n        var r1 = el.outerRadius;\n        return compute$1({\n            x0: el.x + vx * r0,\n            y0: el.y + vy * r0,\n            x1: el.x + vx * r1,\n            y1: el.y + vy * r1,\n            vx: vx,\n            vy: vy\n        }, config);\n    },\n    point: function(el, config) {\n        var v = orient(el, config.origin);\n        var rx = v.x * el.options.radius;\n        var ry = v.y * el.options.radius;\n        return compute$1({\n            x0: el.x - rx,\n            y0: el.y - ry,\n            x1: el.x + rx,\n            y1: el.y + ry,\n            vx: v.x,\n            vy: v.y\n        }, config);\n    },\n    bar: function(el, config) {\n        var v = orient(el, config.origin);\n        var x = el.x;\n        var y = el.y;\n        var sx = 0;\n        var sy = 0;\n        if (el.horizontal) {\n            x = Math.min(el.x, el.base);\n            sx = Math.abs(el.base - el.x);\n        } else {\n            y = Math.min(el.y, el.base);\n            sy = Math.abs(el.base - el.y);\n        }\n        return compute$1({\n            x0: x,\n            y0: y + sy,\n            x1: x + sx,\n            y1: y,\n            vx: v.x,\n            vy: v.y\n        }, config);\n    },\n    fallback: function(el, config) {\n        var v = orient(el, config.origin);\n        return compute$1({\n            x0: el.x,\n            y0: el.y,\n            x1: el.x + (el.width || 0),\n            y1: el.y + (el.height || 0),\n            vx: v.x,\n            vy: v.y\n        }, config);\n    }\n};\nvar rasterize = utils.rasterize;\nfunction boundingRects(model) {\n    var borderWidth = model.borderWidth || 0;\n    var padding = model.padding;\n    var th = model.size.height;\n    var tw = model.size.width;\n    var tx = -tw / 2;\n    var ty = -th / 2;\n    return {\n        frame: {\n            x: tx - padding.left - borderWidth,\n            y: ty - padding.top - borderWidth,\n            w: tw + padding.width + borderWidth * 2,\n            h: th + padding.height + borderWidth * 2\n        },\n        text: {\n            x: tx,\n            y: ty,\n            w: tw,\n            h: th\n        }\n    };\n}\nfunction getScaleOrigin(el, context) {\n    var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;\n    if (!scale) {\n        return null;\n    }\n    if (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n        return {\n            x: scale.xCenter,\n            y: scale.yCenter\n        };\n    }\n    var pixel = scale.getBasePixel();\n    return el.horizontal ? {\n        x: pixel,\n        y: null\n    } : {\n        x: null,\n        y: pixel\n    };\n}\nfunction getPositioner(el) {\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.ArcElement) {\n        return positioners.arc;\n    }\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.PointElement) {\n        return positioners.point;\n    }\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.BarElement) {\n        return positioners.bar;\n    }\n    return positioners.fallback;\n}\nfunction drawRoundedRect(ctx, x, y, w, h, radius) {\n    var HALF_PI = Math.PI / 2;\n    if (radius) {\n        var r = Math.min(radius, h / 2, w / 2);\n        var left = x + r;\n        var top = y + r;\n        var right = x + w - r;\n        var bottom = y + h - r;\n        ctx.moveTo(x, top);\n        if (left < right && top < bottom) {\n            ctx.arc(left, top, r, -Math.PI, -HALF_PI);\n            ctx.arc(right, top, r, -HALF_PI, 0);\n            ctx.arc(right, bottom, r, 0, HALF_PI);\n            ctx.arc(left, bottom, r, HALF_PI, Math.PI);\n        } else if (left < right) {\n            ctx.moveTo(left, y);\n            ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n            ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);\n        } else if (top < bottom) {\n            ctx.arc(left, top, r, -Math.PI, 0);\n            ctx.arc(left, bottom, r, 0, Math.PI);\n        } else {\n            ctx.arc(left, top, r, -Math.PI, Math.PI);\n        }\n        ctx.closePath();\n        ctx.moveTo(x, y);\n    } else {\n        ctx.rect(x, y, w, h);\n    }\n}\nfunction drawFrame(ctx, rect, model) {\n    var bgColor = model.backgroundColor;\n    var borderColor = model.borderColor;\n    var borderWidth = model.borderWidth;\n    if (!bgColor && (!borderColor || !borderWidth)) {\n        return;\n    }\n    ctx.beginPath();\n    drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);\n    ctx.closePath();\n    if (bgColor) {\n        ctx.fillStyle = bgColor;\n        ctx.fill();\n    }\n    if (borderColor && borderWidth) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = \"miter\";\n        ctx.stroke();\n    }\n}\nfunction textGeometry(rect, align, font) {\n    var h = font.lineHeight;\n    var w = rect.w;\n    var x = rect.x;\n    var y = rect.y + h / 2;\n    if (align === \"center\") {\n        x += w / 2;\n    } else if (align === \"end\" || align === \"right\") {\n        x += w;\n    }\n    return {\n        h: h,\n        w: w,\n        x: x,\n        y: y\n    };\n}\nfunction drawTextLine(ctx, text, cfg) {\n    var shadow = ctx.shadowBlur;\n    var stroked = cfg.stroked;\n    var x = rasterize(cfg.x);\n    var y = rasterize(cfg.y);\n    var w = rasterize(cfg.w);\n    if (stroked) {\n        ctx.strokeText(text, x, y, w);\n    }\n    if (cfg.filled) {\n        if (shadow && stroked) {\n            // Prevent drawing shadow on both the text stroke and fill, so\n            // if the text is stroked, remove the shadow for the text fill.\n            ctx.shadowBlur = 0;\n        }\n        ctx.fillText(text, x, y, w);\n        if (shadow && stroked) {\n            ctx.shadowBlur = shadow;\n        }\n    }\n}\nfunction drawText(ctx, lines, rect, model) {\n    var align = model.textAlign;\n    var color = model.color;\n    var filled = !!color;\n    var font = model.font;\n    var ilen = lines.length;\n    var strokeColor = model.textStrokeColor;\n    var strokeWidth = model.textStrokeWidth;\n    var stroked = strokeColor && strokeWidth;\n    var i;\n    if (!ilen || !filled && !stroked) {\n        return;\n    }\n    // Adjust coordinates based on text alignment and line height\n    rect = textGeometry(rect, align, font);\n    ctx.font = font.string;\n    ctx.textAlign = align;\n    ctx.textBaseline = \"middle\";\n    ctx.shadowBlur = model.textShadowBlur;\n    ctx.shadowColor = model.textShadowColor;\n    if (filled) {\n        ctx.fillStyle = color;\n    }\n    if (stroked) {\n        ctx.lineJoin = \"round\";\n        ctx.lineWidth = strokeWidth;\n        ctx.strokeStyle = strokeColor;\n    }\n    for(i = 0, ilen = lines.length; i < ilen; ++i){\n        drawTextLine(ctx, lines[i], {\n            stroked: stroked,\n            filled: filled,\n            w: rect.w,\n            x: rect.x,\n            y: rect.y + rect.h * i\n        });\n    }\n}\nvar Label = function(config, ctx, el, index) {\n    var me = this;\n    me._config = config;\n    me._index = index;\n    me._model = null;\n    me._rects = null;\n    me._ctx = ctx;\n    me._el = el;\n};\n(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(Label.prototype, {\n    /**\n   * @private\n   */ _modelize: function(display, lines, config, context) {\n        var me = this;\n        var index = me._index;\n        var font = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.font,\n            {}\n        ], context, index));\n        var color = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.color,\n            chart_js__WEBPACK_IMPORTED_MODULE_1__.defaults.color\n        ], context, index);\n        return {\n            align: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.align,\n                \"center\"\n            ], context, index),\n            anchor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.anchor,\n                \"center\"\n            ], context, index),\n            area: context.chart.chartArea,\n            backgroundColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.backgroundColor,\n                null\n            ], context, index),\n            borderColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderColor,\n                null\n            ], context, index),\n            borderRadius: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderRadius,\n                0\n            ], context, index),\n            borderWidth: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderWidth,\n                0\n            ], context, index),\n            clamp: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.clamp,\n                false\n            ], context, index),\n            clip: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.clip,\n                false\n            ], context, index),\n            color: color,\n            display: display,\n            font: font,\n            lines: lines,\n            offset: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.offset,\n                4\n            ], context, index),\n            opacity: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.opacity,\n                1\n            ], context, index),\n            origin: getScaleOrigin(me._el, context),\n            padding: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.padding,\n                4\n            ], context, index)),\n            positioner: getPositioner(me._el),\n            rotation: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.rotation,\n                0\n            ], context, index) * (Math.PI / 180),\n            size: utils.textSize(me._ctx, lines, font),\n            textAlign: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textAlign,\n                \"start\"\n            ], context, index),\n            textShadowBlur: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textShadowBlur,\n                0\n            ], context, index),\n            textShadowColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textShadowColor,\n                color\n            ], context, index),\n            textStrokeColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textStrokeColor,\n                color\n            ], context, index),\n            textStrokeWidth: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textStrokeWidth,\n                0\n            ], context, index)\n        };\n    },\n    update: function(context) {\n        var me = this;\n        var model = null;\n        var rects = null;\n        var index = me._index;\n        var config = me._config;\n        var value, label, lines;\n        // We first resolve the display option (separately) to avoid computing\n        // other options in case the label is hidden (i.e. display: false).\n        var display = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.display,\n            true\n        ], context, index);\n        if (display) {\n            value = context.dataset.data[index];\n            label = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(config.formatter, [\n                value,\n                context\n            ]), value);\n            lines = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(label) ? [] : utils.toTextLines(label);\n            if (lines.length) {\n                model = me._modelize(display, lines, config, context);\n                rects = boundingRects(model);\n            }\n        }\n        me._model = model;\n        me._rects = rects;\n    },\n    geometry: function() {\n        return this._rects ? this._rects.frame : {};\n    },\n    rotation: function() {\n        return this._model ? this._model.rotation : 0;\n    },\n    visible: function() {\n        return this._model && this._model.opacity;\n    },\n    model: function() {\n        return this._model;\n    },\n    draw: function(chart, center) {\n        var me = this;\n        var ctx = chart.ctx;\n        var model = me._model;\n        var rects = me._rects;\n        var area;\n        if (!this.visible()) {\n            return;\n        }\n        ctx.save();\n        if (model.clip) {\n            area = model.area;\n            ctx.beginPath();\n            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n            ctx.clip();\n        }\n        ctx.globalAlpha = utils.bound(0, model.opacity, 1);\n        ctx.translate(rasterize(center.x), rasterize(center.y));\n        ctx.rotate(model.rotation);\n        drawFrame(ctx, rects.frame, model);\n        drawText(ctx, model.lines, rects.text, model);\n        ctx.restore();\n    }\n});\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991; // eslint-disable-line es/no-number-maxsafeinteger\nfunction rotated(point, center, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var cx = center.x;\n    var cy = center.y;\n    return {\n        x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n        y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n    };\n}\nfunction projected(points, axis) {\n    var min = MAX_INTEGER;\n    var max = MIN_INTEGER;\n    var origin = axis.origin;\n    var i, pt, vx, vy, dp;\n    for(i = 0; i < points.length; ++i){\n        pt = points[i];\n        vx = pt.x - origin.x;\n        vy = pt.y - origin.y;\n        dp = axis.vx * vx + axis.vy * vy;\n        min = Math.min(min, dp);\n        max = Math.max(max, dp);\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\nfunction toAxis(p0, p1) {\n    var vx = p1.x - p0.x;\n    var vy = p1.y - p0.y;\n    var ln = Math.sqrt(vx * vx + vy * vy);\n    return {\n        vx: (p1.x - p0.x) / ln,\n        vy: (p1.y - p0.y) / ln,\n        origin: p0,\n        ln: ln\n    };\n}\nvar HitBox = function() {\n    this._rotation = 0;\n    this._rect = {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0\n    };\n};\n(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(HitBox.prototype, {\n    center: function() {\n        var r = this._rect;\n        return {\n            x: r.x + r.w / 2,\n            y: r.y + r.h / 2\n        };\n    },\n    update: function(center, rect, rotation) {\n        this._rotation = rotation;\n        this._rect = {\n            x: rect.x + center.x,\n            y: rect.y + center.y,\n            w: rect.w,\n            h: rect.h\n        };\n    },\n    contains: function(point) {\n        var me = this;\n        var margin = 1;\n        var rect = me._rect;\n        point = rotated(point, me.center(), -me._rotation);\n        return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);\n    },\n    // Separating Axis Theorem\n    // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n    intersects: function(other) {\n        var r0 = this._points();\n        var r1 = other._points();\n        var axes = [\n            toAxis(r0[0], r0[1]),\n            toAxis(r0[0], r0[3])\n        ];\n        var i, pr0, pr1;\n        if (this._rotation !== other._rotation) {\n            // Only separate with r1 axis if the rotation is different,\n            // else it's enough to separate r0 and r1 with r0 axis only!\n            axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));\n        }\n        for(i = 0; i < axes.length; ++i){\n            pr0 = projected(r0, axes[i]);\n            pr1 = projected(r1, axes[i]);\n            if (pr0.max < pr1.min || pr1.max < pr0.min) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\n   * @private\n   */ _points: function() {\n        var me = this;\n        var rect = me._rect;\n        var angle = me._rotation;\n        var center = me.center();\n        return [\n            rotated({\n                x: rect.x,\n                y: rect.y\n            }, center, angle),\n            rotated({\n                x: rect.x + rect.w,\n                y: rect.y\n            }, center, angle),\n            rotated({\n                x: rect.x + rect.w,\n                y: rect.y + rect.h\n            }, center, angle),\n            rotated({\n                x: rect.x,\n                y: rect.y + rect.h\n            }, center, angle)\n        ];\n    }\n});\nfunction coordinates(el, model, geometry) {\n    var point = model.positioner(el, model);\n    var vx = point.vx;\n    var vy = point.vy;\n    if (!vx && !vy) {\n        // if aligned center, we don't want to offset the center point\n        return {\n            x: point.x,\n            y: point.y\n        };\n    }\n    var w = geometry.w;\n    var h = geometry.h;\n    // take in account the label rotation\n    var rotation = model.rotation;\n    var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n    var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n    // scale the unit vector (vx, vy) to get at least dx or dy equal to\n    // w or h respectively (else we would calculate the distance to the\n    // ellipse inscribed in the bounding rect)\n    var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n    dx *= vx * vs;\n    dy *= vy * vs;\n    // finally, include the explicit offset\n    dx += model.offset * vx;\n    dy += model.offset * vy;\n    return {\n        x: point.x + dx,\n        y: point.y + dy\n    };\n}\nfunction collide(labels, collider) {\n    var i, j, s0, s1;\n    // IMPORTANT Iterate in the reverse order since items at the end of the\n    // list have an higher weight/priority and thus should be less impacted\n    // by the overlapping strategy.\n    for(i = labels.length - 1; i >= 0; --i){\n        s0 = labels[i].$layout;\n        for(j = i - 1; j >= 0 && s0._visible; --j){\n            s1 = labels[j].$layout;\n            if (s1._visible && s0._box.intersects(s1._box)) {\n                collider(s0, s1);\n            }\n        }\n    }\n    return labels;\n}\nfunction compute(labels) {\n    var i, ilen, label, state, geometry, center, proxy;\n    // Initialize labels for overlap detection\n    for(i = 0, ilen = labels.length; i < ilen; ++i){\n        label = labels[i];\n        state = label.$layout;\n        if (state._visible) {\n            // Chart.js 3 removed el._model in favor of getProps(), making harder to\n            // abstract reading values in positioners. Also, using string arrays to\n            // read values (i.e. var {a,b,c} = el.getProps([\"a\",\"b\",\"c\"])) would make\n            // positioners inefficient in the normal case (i.e. not the final values)\n            // and the code a bit ugly, so let's use a Proxy instead.\n            proxy = new Proxy(label._el, {\n                get: (el, p)=>el.getProps([\n                        p\n                    ], true)[p]\n            });\n            geometry = label.geometry();\n            center = coordinates(proxy, label.model(), geometry);\n            state._box.update(center, geometry, label.rotation());\n        }\n    }\n    // Auto hide overlapping labels\n    return collide(labels, function(s0, s1) {\n        var h0 = s0._hidable;\n        var h1 = s1._hidable;\n        if (h0 && h1 || h1) {\n            s1._visible = false;\n        } else if (h0) {\n            s0._visible = false;\n        }\n    });\n}\nvar layout = {\n    prepare: function(datasets) {\n        var labels = [];\n        var i, j, ilen, jlen, label;\n        for(i = 0, ilen = datasets.length; i < ilen; ++i){\n            for(j = 0, jlen = datasets[i].length; j < jlen; ++j){\n                label = datasets[i][j];\n                labels.push(label);\n                label.$layout = {\n                    _box: new HitBox(),\n                    _hidable: false,\n                    _visible: true,\n                    _set: i,\n                    _idx: label._index\n                };\n            }\n        }\n        // TODO New `z` option: labels with a higher z-index are drawn\n        // of top of the ones with a lower index. Lowest z-index labels\n        // are also discarded first when hiding overlapping labels.\n        labels.sort(function(a, b) {\n            var sa = a.$layout;\n            var sb = b.$layout;\n            return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;\n        });\n        this.update(labels);\n        return labels;\n    },\n    update: function(labels) {\n        var dirty = false;\n        var i, ilen, label, model, state;\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            label = labels[i];\n            model = label.model();\n            state = label.$layout;\n            state._hidable = model && model.display === \"auto\";\n            state._visible = label.visible();\n            dirty |= state._hidable;\n        }\n        if (dirty) {\n            compute(labels);\n        }\n    },\n    lookup: function(labels, point) {\n        var i, state;\n        // IMPORTANT Iterate in the reverse order since items at the end of\n        // the list have an higher z-index, thus should be picked first.\n        for(i = labels.length - 1; i >= 0; --i){\n            state = labels[i].$layout;\n            if (state && state._visible && state._box.contains(point)) {\n                return labels[i];\n            }\n        }\n        return null;\n    },\n    draw: function(chart, labels) {\n        var i, ilen, label, state, geometry, center;\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            label = labels[i];\n            state = label.$layout;\n            if (state._visible) {\n                geometry = label.geometry();\n                center = coordinates(label._el, label.model(), geometry);\n                state._box.update(center, geometry, label.rotation());\n                label.draw(chart, center);\n            }\n        }\n    }\n};\nvar formatter = function(value) {\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value)) {\n        return null;\n    }\n    var label = value;\n    var keys, klen, k;\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {\n        if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value.label)) {\n            label = value.label;\n        } else if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value.r)) {\n            label = value.r;\n        } else {\n            label = \"\";\n            keys = Object.keys(value);\n            for(k = 0, klen = keys.length; k < klen; ++k){\n                label += (k !== 0 ? \", \" : \"\") + keys[k] + \": \" + value[keys[k]];\n            }\n        }\n    }\n    return \"\" + label;\n};\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */ var defaults = {\n    align: \"center\",\n    anchor: \"center\",\n    backgroundColor: null,\n    borderColor: null,\n    borderRadius: 0,\n    borderWidth: 0,\n    clamp: false,\n    clip: false,\n    color: undefined,\n    display: true,\n    font: {\n        family: undefined,\n        lineHeight: 1.2,\n        size: undefined,\n        style: undefined,\n        weight: null\n    },\n    formatter: formatter,\n    labels: undefined,\n    listeners: {},\n    offset: 4,\n    opacity: 1,\n    padding: {\n        top: 4,\n        right: 4,\n        bottom: 4,\n        left: 4\n    },\n    rotation: 0,\n    textAlign: \"start\",\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    textShadowBlur: 0,\n    textShadowColor: undefined\n};\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */ var EXPANDO_KEY = \"$datalabels\";\nvar DEFAULT_KEY = \"$default\";\nfunction configure(dataset, options) {\n    var override = dataset.datalabels;\n    var listeners = {};\n    var configs = [];\n    var labels, keys;\n    if (override === false) {\n        return null;\n    }\n    if (override === true) {\n        override = {};\n    }\n    options = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [\n        options,\n        override\n    ]);\n    labels = options.labels || {};\n    keys = Object.keys(labels);\n    delete options.labels;\n    if (keys.length) {\n        keys.forEach(function(key) {\n            if (labels[key]) {\n                configs.push((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [\n                    options,\n                    labels[key],\n                    {\n                        _key: key\n                    }\n                ]));\n            }\n        });\n    } else {\n        // Default label if no \"named\" label defined.\n        configs.push(options);\n    }\n    // listeners: {<event-type>: {<label-key>: <fn>}}\n    listeners = configs.reduce(function(target, config) {\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.each)(config.listeners || {}, function(fn, event) {\n            target[event] = target[event] || {};\n            target[event][config._key || DEFAULT_KEY] = fn;\n        });\n        delete config.listeners;\n        return target;\n    }, {});\n    return {\n        labels: configs,\n        listeners: listeners\n    };\n}\nfunction dispatchEvent(chart, listeners, label, event) {\n    if (!listeners) {\n        return;\n    }\n    var context = label.$context;\n    var groups = label.$groups;\n    var callback$1;\n    if (!listeners[groups._set]) {\n        return;\n    }\n    callback$1 = listeners[groups._set][groups._key];\n    if (!callback$1) {\n        return;\n    }\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(callback$1, [\n        context,\n        event\n    ]) === true) {\n        // Users are allowed to tweak the given context by injecting values that can be\n        // used in scriptable options to display labels differently based on the current\n        // event (e.g. highlight an hovered label). That's why we update the label with\n        // the output context and schedule a new chart render by setting it dirty.\n        chart[EXPANDO_KEY]._dirty = true;\n        label.update(context);\n    }\n}\nfunction dispatchMoveEvents(chart, listeners, previous, label, event) {\n    var enter, leave;\n    if (!previous && !label) {\n        return;\n    }\n    if (!previous) {\n        enter = true;\n    } else if (!label) {\n        leave = true;\n    } else if (previous !== label) {\n        leave = enter = true;\n    }\n    if (leave) {\n        dispatchEvent(chart, listeners.leave, previous, event);\n    }\n    if (enter) {\n        dispatchEvent(chart, listeners.enter, label, event);\n    }\n}\nfunction handleMoveEvents(chart, event) {\n    var expando = chart[EXPANDO_KEY];\n    var listeners = expando._listeners;\n    var previous, label;\n    if (!listeners.enter && !listeners.leave) {\n        return;\n    }\n    if (event.type === \"mousemove\") {\n        label = layout.lookup(expando._labels, event);\n    } else if (event.type !== \"mouseout\") {\n        return;\n    }\n    previous = expando._hovered;\n    expando._hovered = label;\n    dispatchMoveEvents(chart, listeners, previous, label, event);\n}\nfunction handleClickEvents(chart, event) {\n    var expando = chart[EXPANDO_KEY];\n    var handlers = expando._listeners.click;\n    var label = handlers && layout.lookup(expando._labels, event);\n    if (label) {\n        dispatchEvent(chart, handlers, label, event);\n    }\n}\nvar plugin = {\n    id: \"datalabels\",\n    defaults: defaults,\n    beforeInit: function(chart) {\n        chart[EXPANDO_KEY] = {\n            _actives: []\n        };\n    },\n    beforeUpdate: function(chart) {\n        var expando = chart[EXPANDO_KEY];\n        expando._listened = false;\n        expando._listeners = {}; // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n        expando._datasets = []; // per dataset labels: [Label[]]\n        expando._labels = []; // layouted labels: Label[]\n    },\n    afterDatasetUpdate: function(chart, args, options) {\n        var datasetIndex = args.index;\n        var expando = chart[EXPANDO_KEY];\n        var labels = expando._datasets[datasetIndex] = [];\n        var visible = chart.isDatasetVisible(datasetIndex);\n        var dataset = chart.data.datasets[datasetIndex];\n        var config = configure(dataset, options);\n        var elements = args.meta.data || [];\n        var ctx = chart.ctx;\n        var i, j, ilen, jlen, cfg, key, el, label;\n        ctx.save();\n        for(i = 0, ilen = elements.length; i < ilen; ++i){\n            el = elements[i];\n            el[EXPANDO_KEY] = [];\n            if (visible && el && chart.getDataVisibility(i) && !el.skip) {\n                for(j = 0, jlen = config.labels.length; j < jlen; ++j){\n                    cfg = config.labels[j];\n                    key = cfg._key;\n                    label = new Label(cfg, ctx, el, i);\n                    label.$groups = {\n                        _set: datasetIndex,\n                        _key: key || DEFAULT_KEY\n                    };\n                    label.$context = {\n                        active: false,\n                        chart: chart,\n                        dataIndex: i,\n                        dataset: dataset,\n                        datasetIndex: datasetIndex\n                    };\n                    label.update(label.$context);\n                    el[EXPANDO_KEY].push(label);\n                    labels.push(label);\n                }\n            }\n        }\n        ctx.restore();\n        // Store listeners at the chart level and per event type to optimize\n        // cases where no listeners are registered for a specific event.\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(expando._listeners, config.listeners, {\n            merger: function(event, target, source) {\n                target[event] = target[event] || {};\n                target[event][args.index] = source[event];\n                expando._listened = true;\n            }\n        });\n    },\n    afterUpdate: function(chart) {\n        chart[EXPANDO_KEY]._labels = layout.prepare(chart[EXPANDO_KEY]._datasets);\n    },\n    // Draw labels on top of all dataset elements\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n    afterDatasetsDraw: function(chart) {\n        layout.draw(chart, chart[EXPANDO_KEY]._labels);\n    },\n    beforeEvent: function(chart, args) {\n        // If there is no listener registered for this chart, `listened` will be false,\n        // meaning we can immediately ignore the incoming event and avoid useless extra\n        // computation for users who don't implement label interactions.\n        if (chart[EXPANDO_KEY]._listened) {\n            var event = args.event;\n            switch(event.type){\n                case \"mousemove\":\n                case \"mouseout\":\n                    handleMoveEvents(chart, event);\n                    break;\n                case \"click\":\n                    handleClickEvents(chart, event);\n                    break;\n            }\n        }\n    },\n    afterEvent: function(chart) {\n        var expando = chart[EXPANDO_KEY];\n        var previous = expando._actives;\n        var actives = expando._actives = chart.getActiveElements();\n        var updates = utils.arrayDiff(previous, actives);\n        var i, ilen, j, jlen, update, label, labels;\n        for(i = 0, ilen = updates.length; i < ilen; ++i){\n            update = updates[i];\n            if (update[1]) {\n                labels = update[0].element[EXPANDO_KEY] || [];\n                for(j = 0, jlen = labels.length; j < jlen; ++j){\n                    label = labels[j];\n                    label.$context.active = update[1] === 1;\n                    label.update(label.$context);\n                }\n            }\n        }\n        if (expando._dirty || updates.length) {\n            layout.update(expando._labels);\n            chart.render();\n        }\n        delete expando._dirty;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7OztDQUtDLEdBQzZIO0FBQ3RDO0FBRXhGLElBQUljLG1CQUFvQjtJQUN0QixJQUFJLEtBQWtCLEVBQWEsZUFZbEM7SUFFRCxPQUFPO0FBQ1Q7QUFFQSxJQUFJSyxRQUFRO0lBQ1YsK0NBQStDO0lBQy9DQyxhQUFhLFNBQVNDLE1BQU07UUFDMUIsSUFBSUMsUUFBUSxFQUFFO1FBQ2QsSUFBSUM7UUFFSkYsU0FBUyxFQUFFLENBQUNHLE1BQU0sQ0FBQ0g7UUFDbkIsTUFBT0EsT0FBT0ksTUFBTSxDQUFFO1lBQ3BCRixRQUFRRixPQUFPSyxHQUFHO1lBQ2xCLElBQUksT0FBT0gsVUFBVSxVQUFVO2dCQUM3QkQsTUFBTUssT0FBTyxDQUFDQyxLQUFLLENBQUNOLE9BQU9DLE1BQU1NLEtBQUssQ0FBQztZQUN6QyxPQUFPLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUTtnQkFDL0JGLE9BQU9XLElBQUksQ0FBQ0osS0FBSyxDQUFDUCxRQUFRRTtZQUM1QixPQUFPLElBQUksQ0FBQ3ZCLCtEQUFhQSxDQUFDcUIsU0FBUztnQkFDakNDLE1BQU1LLE9BQU8sQ0FBQyxLQUFLSjtZQUNyQjtRQUNGO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLG1EQUFtRDtJQUNuRCw0REFBNEQ7SUFDNURXLFVBQVUsU0FBU0MsR0FBRyxFQUFFWixLQUFLLEVBQUVhLElBQUk7UUFDakMsSUFBSUMsUUFBUSxFQUFFLENBQUNaLE1BQU0sQ0FBQ0Y7UUFDdEIsSUFBSWUsT0FBT0QsTUFBTVgsTUFBTTtRQUN2QixJQUFJYSxPQUFPSixJQUFJQyxJQUFJO1FBQ25CLElBQUlJLFFBQVE7UUFDWixJQUFJQztRQUVKTixJQUFJQyxJQUFJLEdBQUdBLEtBQUtNLE1BQU07UUFFdEIsSUFBS0QsSUFBSSxHQUFHQSxJ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QUFNLENBQUNqTSxFQUFFO29CQUNqQnNKLE1BQU0rRixRQUFRLENBQUNnQyxNQUFNLEdBQUlqSSxNQUFNLENBQUMsRUFBRSxLQUFLO29CQUN2Q0UsTUFBTUYsTUFBTSxDQUFDRSxNQUFNK0YsUUFBUTtnQkFDN0I7WUFDRjtRQUNGO1FBRUEsSUFBSVUsUUFBUU4sTUFBTSxJQUFJMVAsUUFBUTdCLE1BQU0sRUFBRTtZQUNwQ2dQLE9BQU85RCxNQUFNLENBQUMyRyxRQUFRRyxPQUFPO1lBQzdCOUssTUFBTTRNLE1BQU07UUFDZDtRQUVBLE9BQU9qQyxRQUFRTixNQUFNO0lBQ3ZCO0FBQ0Y7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYWxtaWxoYW5kby8uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lc20uanM/MGQwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgdjIuMi4wXG4gKiBodHRwczovL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMubmV0bGlmeS5hcHBcbiAqIChjKSAyMDE3LTIwMjIgY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgeyBpc051bGxPclVuZGVmLCBtZXJnZSwgdG9Gb250LCByZXNvbHZlLCB0b1BhZGRpbmcsIHZhbHVlT3JEZWZhdWx0LCBjYWxsYmFjaywgaXNPYmplY3QsIGVhY2ggfSBmcm9tICdjaGFydC5qcy9oZWxwZXJzJztcbmltcG9ydCB7IGRlZmF1bHRzIGFzIGRlZmF1bHRzJDEsIEFyY0VsZW1lbnQsIFBvaW50RWxlbWVudCwgQmFyRWxlbWVudCB9IGZyb20gJ2NoYXJ0LmpzJztcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIC8vIGRldmljZVBpeGVsUmF0aW8gaXMgdW5kZWZpbmVkIG9uIElFMTBcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAyMDQxODAvODgzNzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzg1XG4gICAgdmFyIHNjcmVlbiA9IHdpbmRvdy5zY3JlZW47XG4gICAgaWYgKHNjcmVlbikge1xuICAgICAgcmV0dXJuIChzY3JlZW4uZGV2aWNlWERQSSB8fCAxKSAvIChzY3JlZW4ubG9naWNhbFhEUEkgfHwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59KCkpO1xuXG52YXIgdXRpbHMgPSB7XG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLnRvVGV4dExpbmVzXG4gIHRvVGV4dExpbmVzOiBmdW5jdGlvbihpbnB1dHMpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgaW5wdXQ7XG5cbiAgICBpbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzKTtcbiAgICB3aGlsZSAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgaW5wdXQgPSBpbnB1dHMucG9wKCk7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBsaW5lcy51bnNoaWZ0LmFwcGx5KGxpbmVzLCBpbnB1dC5zcGxpdCgnXFxuJykpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBpbnB1dHMucHVzaC5hcHBseShpbnB1dHMsIGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWYoaW5wdXRzKSkge1xuICAgICAgICBsaW5lcy51bnNoaWZ0KCcnICsgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaW5lcztcbiAgfSxcblxuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudGV4dFNpemVcbiAgLy8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXG4gIHRleHRTaXplOiBmdW5jdGlvbihjdHgsIGxpbmVzLCBmb250KSB7XG4gICAgdmFyIGl0ZW1zID0gW10uY29uY2F0KGxpbmVzKTtcbiAgICB2YXIgaWxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgcHJldiA9IGN0eC5mb250O1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGk7XG5cbiAgICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heChjdHgubWVhc3VyZVRleHQoaXRlbXNbaV0pLndpZHRoLCB3aWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZvbnQgPSBwcmV2O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogaWxlbiAqIGZvbnQubGluZUhlaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWUgYm91bmRlZCBieSBtaW4gYW5kIG1heC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIG1heChtaW4sIG1pbih2YWx1ZSwgbWF4KSkuXG4gICAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxuICAgKiBodHRwczovL2RvYy5xdC5pby9xdC01L3F0Z2xvYmFsLmh0bWwjcUJvdW5kXG4gICAqL1xuICBib3VuZDogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXIgW3ZhbHVlLCBzdGF0ZV0gd2hlcmUgc3RhdGUgaXM6XG4gICAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXG4gICAqICogIDE6IHZhbHVlIGlzIG9ubHkgaW4gYTEgKGFkZGVkKVxuICAgKi9cbiAgYXJyYXlEaWZmOiBmdW5jdGlvbihhMCwgYTEpIHtcbiAgICB2YXIgcHJldiA9IGEwLnNsaWNlKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSBbXTtcbiAgICB2YXIgaSwgaiwgaWxlbiwgdjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhMS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHYgPSBhMVtpXTtcbiAgICAgIGogPSBwcmV2LmluZGV4T2Yodik7XG5cbiAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICB1cGRhdGVzLnB1c2goW3YsIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYuc3BsaWNlKGosIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwcmV2Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdXBkYXRlcy5wdXNoKFtwcmV2W2ldLCAtMV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxuICAgKi9cbiAgcmFzdGVyaXplOiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodiAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxufTtcblxuZnVuY3Rpb24gb3JpZW50KHBvaW50LCBvcmlnaW4pIHtcbiAgdmFyIHgwID0gb3JpZ2luLng7XG4gIHZhciB5MCA9IG9yaWdpbi55O1xuXG4gIGlmICh4MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMCwgeTogLTF9O1xuICB9XG4gIGlmICh5MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMSwgeTogMH07XG4gIH1cblxuICB2YXIgZHggPSBwb2ludC54IC0geDA7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5MDtcbiAgdmFyIGxuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICByZXR1cm4ge1xuICAgIHg6IGxuID8gZHggLyBsbiA6IDAsXG4gICAgeTogbG4gPyBkeSAvIGxuIDogLTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25lZCh4LCB5LCB2eCwgdnksIGFsaWduKSB7XG4gIHN3aXRjaCAoYWxpZ24pIHtcbiAgY2FzZSAnY2VudGVyJzpcbiAgICB2eCA9IHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnYm90dG9tJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAxO1xuICAgIGJyZWFrO1xuICBjYXNlICdyaWdodCc6XG4gICAgdnggPSAxO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnbGVmdCc6XG4gICAgdnggPSAtMTtcbiAgICB2eSA9IDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RvcCc6XG4gICAgdnggPSAwO1xuICAgIHZ5ID0gLTE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXJ0JzpcbiAgICB2eCA9IC12eDtcbiAgICB2eSA9IC12eTtcbiAgICBicmVhaztcbiAgY2FzZSAnZW5kJzpcbiAgICAvLyBrZWVwIG5hdHVyYWwgb3JpZW50YXRpb25cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICAvLyBjbG9ja3dpc2Ugcm90YXRpb24gKGluIGRlZ3JlZSlcbiAgICBhbGlnbiAqPSAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdnggPSBNYXRoLmNvcyhhbGlnbik7XG4gICAgdnkgPSBNYXRoLnNpbihhbGlnbik7XG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB2eDogdngsXG4gICAgdnk6IHZ5XG4gIH07XG59XG5cbi8vIExpbmUgY2xpcHBpbmcgKENvaGVu4oCTU3V0aGVybGFuZCBhbGdvcml0aG0pXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbuKAk1N1dGhlcmxhbmRfYWxnb3JpdGhtXG5cbnZhciBSX0lOU0lERSA9IDA7XG52YXIgUl9MRUZUID0gMTtcbnZhciBSX1JJR0hUID0gMjtcbnZhciBSX0JPVFRPTSA9IDQ7XG52YXIgUl9UT1AgPSA4O1xuXG5mdW5jdGlvbiByZWdpb24oeCwgeSwgcmVjdCkge1xuICB2YXIgcmVzID0gUl9JTlNJREU7XG5cbiAgaWYgKHggPCByZWN0LmxlZnQpIHtcbiAgICByZXMgfD0gUl9MRUZUO1xuICB9IGVsc2UgaWYgKHggPiByZWN0LnJpZ2h0KSB7XG4gICAgcmVzIHw9IFJfUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCByZWN0LnRvcCkge1xuICAgIHJlcyB8PSBSX1RPUDtcbiAgfSBlbHNlIGlmICh5ID4gcmVjdC5ib3R0b20pIHtcbiAgICByZXMgfD0gUl9CT1RUT007XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjbGlwcGVkKHNlZ21lbnQsIGFyZWEpIHtcbiAgdmFyIHgwID0gc2VnbWVudC54MDtcbiAgdmFyIHkwID0gc2VnbWVudC55MDtcbiAgdmFyIHgxID0gc2VnbWVudC54MTtcbiAgdmFyIHkxID0gc2VnbWVudC55MTtcbiAgdmFyIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XG4gIHZhciByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICB2YXIgciwgeCwgeTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCEocjAgfCByMSkgfHwgKHIwICYgcjEpKSB7XG4gICAgICAvLyBib3RoIHBvaW50cyBpbnNpZGUgb3Igb24gdGhlIHNhbWUgc2lkZTogbm8gY2xpcHBpbmdcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGF0IGxlYXN0IG9uZSBwb2ludCBpcyBvdXRzaWRlXG4gICAgciA9IHIwIHx8IHIxO1xuXG4gICAgaWYgKHIgJiBSX1RPUCkge1xuICAgICAgeCA9IHgwICsgKHgxIC0geDApICogKGFyZWEudG9wIC0geTApIC8gKHkxIC0geTApO1xuICAgICAgeSA9IGFyZWEudG9wO1xuICAgIH0gZWxzZSBpZiAociAmIFJfQk9UVE9NKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS5ib3R0b20gLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChyICYgUl9SSUdIVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEucmlnaHQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX0xFRlQpIHtcbiAgICAgIHkgPSB5MCArICh5MSAtIHkwKSAqIChhcmVhLmxlZnQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5sZWZ0O1xuICAgIH1cblxuICAgIGlmIChyID09PSByMCkge1xuICAgICAgeDAgPSB4O1xuICAgICAgeTAgPSB5O1xuICAgICAgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDEgPSB4O1xuICAgICAgeTEgPSB5O1xuICAgICAgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHgwOiB4MCxcbiAgICB4MTogeDEsXG4gICAgeTA6IHkwLFxuICAgIHkxOiB5MVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlJDEocmFuZ2UsIGNvbmZpZykge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmFuY2hvcjtcbiAgdmFyIHNlZ21lbnQgPSByYW5nZTtcbiAgdmFyIHgsIHk7XG5cbiAgaWYgKGNvbmZpZy5jbGFtcCkge1xuICAgIHNlZ21lbnQgPSBjbGlwcGVkKHNlZ21lbnQsIGNvbmZpZy5hcmVhKTtcbiAgfVxuXG4gIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcbiAgICB4ID0gc2VnbWVudC54MDtcbiAgICB5ID0gc2VnbWVudC55MDtcbiAgfSBlbHNlIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XG4gICAgeCA9IHNlZ21lbnQueDE7XG4gICAgeSA9IHNlZ21lbnQueTE7XG4gIH0gZWxzZSB7XG4gICAgeCA9IChzZWdtZW50LngwICsgc2VnbWVudC54MSkgLyAyO1xuICAgIHkgPSAoc2VnbWVudC55MCArIHNlZ21lbnQueTEpIC8gMjtcbiAgfVxuXG4gIHJldHVybiBhbGlnbmVkKHgsIHksIHJhbmdlLnZ4LCByYW5nZS52eSwgY29uZmlnLmFsaWduKTtcbn1cblxudmFyIHBvc2l0aW9uZXJzID0ge1xuICBhcmM6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgYW5nbGUgPSAoZWwuc3RhcnRBbmdsZSArIGVsLmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIHZ4ID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB2eSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgcjAgPSBlbC5pbm5lclJhZGl1cztcbiAgICB2YXIgcjEgPSBlbC5vdXRlclJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLnggKyB2eCAqIHIwLFxuICAgICAgeTA6IGVsLnkgKyB2eSAqIHIwLFxuICAgICAgeDE6IGVsLnggKyB2eCAqIHIxLFxuICAgICAgeTE6IGVsLnkgKyB2eSAqIHIxLFxuICAgICAgdng6IHZ4LFxuICAgICAgdnk6IHZ5XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBwb2ludDogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgcnggPSB2LnggKiBlbC5vcHRpb25zLnJhZGl1cztcbiAgICB2YXIgcnkgPSB2LnkgKiBlbC5vcHRpb25zLnJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLnggLSByeCxcbiAgICAgIHkwOiBlbC55IC0gcnksXG4gICAgICB4MTogZWwueCArIHJ4LFxuICAgICAgeTE6IGVsLnkgKyByeSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBiYXI6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG4gICAgdmFyIHggPSBlbC54O1xuICAgIHZhciB5ID0gZWwueTtcbiAgICB2YXIgc3ggPSAwO1xuICAgIHZhciBzeSA9IDA7XG5cbiAgICBpZiAoZWwuaG9yaXpvbnRhbCkge1xuICAgICAgeCA9IE1hdGgubWluKGVsLngsIGVsLmJhc2UpO1xuICAgICAgc3ggPSBNYXRoLmFicyhlbC5iYXNlIC0gZWwueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBNYXRoLm1pbihlbC55LCBlbC5iYXNlKTtcbiAgICAgIHN5ID0gTWF0aC5hYnMoZWwuYmFzZSAtIGVsLnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IHgsXG4gICAgICB5MDogeSArIHN5LFxuICAgICAgeDE6IHggKyBzeCxcbiAgICAgIHkxOiB5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCxcbiAgICAgIHkwOiBlbC55LFxuICAgICAgeDE6IGVsLnggKyAoZWwud2lkdGggfHwgMCksXG4gICAgICB5MTogZWwueSArIChlbC5oZWlnaHQgfHwgMCksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH1cbn07XG5cbnZhciByYXN0ZXJpemUgPSB1dGlscy5yYXN0ZXJpemU7XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMobW9kZWwpIHtcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGggfHwgMDtcbiAgdmFyIHBhZGRpbmcgPSBtb2RlbC5wYWRkaW5nO1xuICB2YXIgdGggPSBtb2RlbC5zaXplLmhlaWdodDtcbiAgdmFyIHR3ID0gbW9kZWwuc2l6ZS53aWR0aDtcbiAgdmFyIHR4ID0gLXR3IC8gMjtcbiAgdmFyIHR5ID0gLXRoIC8gMjtcblxuICByZXR1cm4ge1xuICAgIGZyYW1lOiB7XG4gICAgICB4OiB0eCAtIHBhZGRpbmcubGVmdCAtIGJvcmRlcldpZHRoLFxuICAgICAgeTogdHkgLSBwYWRkaW5nLnRvcCAtIGJvcmRlcldpZHRoLFxuICAgICAgdzogdHcgKyBwYWRkaW5nLndpZHRoICsgYm9yZGVyV2lkdGggKiAyLFxuICAgICAgaDogdGggKyBwYWRkaW5nLmhlaWdodCArIGJvcmRlcldpZHRoICogMlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgeDogdHgsXG4gICAgICB5OiB0eSxcbiAgICAgIHc6IHR3LFxuICAgICAgaDogdGhcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlT3JpZ2luKGVsLCBjb250ZXh0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRleHQuY2hhcnQuZ2V0RGF0YXNldE1ldGEoY29udGV4dC5kYXRhc2V0SW5kZXgpLnZTY2FsZTtcblxuICBpZiAoIXNjYWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc2NhbGUueENlbnRlciAhPT0gdW5kZWZpbmVkICYmIHNjYWxlLnlDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7eDogc2NhbGUueENlbnRlciwgeTogc2NhbGUueUNlbnRlcn07XG4gIH1cblxuICB2YXIgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgcmV0dXJuIGVsLmhvcml6b250YWwgP1xuICAgIHt4OiBwaXhlbCwgeTogbnVsbH0gOlxuICAgIHt4OiBudWxsLCB5OiBwaXhlbH07XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uZXIoZWwpIHtcbiAgaWYgKGVsIGluc3RhbmNlb2YgQXJjRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5hcmM7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgUG9pbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLnBvaW50O1xuICB9XG4gIGlmIChlbCBpbnN0YW5jZW9mIEJhckVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMuYmFyO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbmVycy5mYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZHJhd1JvdW5kZWRSZWN0KGN0eCwgeCwgeSwgdywgaCwgcmFkaXVzKSB7XG4gIHZhciBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XG5cbiAgaWYgKHJhZGl1cykge1xuICAgIHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoIC8gMiwgdyAvIDIpO1xuICAgIHZhciBsZWZ0ID0geCArIHI7XG4gICAgdmFyIHRvcCA9IHkgKyByO1xuICAgIHZhciByaWdodCA9IHggKyB3IC0gcjtcbiAgICB2YXIgYm90dG9tID0geSArIGggLSByO1xuXG4gICAgY3R4Lm1vdmVUbyh4LCB0b3ApO1xuICAgIGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIC1IQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuICAgICAgY3R4LmFyYyhyaWdodCwgYm90dG9tLCByLCAwLCBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCBIQUxGX1BJLCBNYXRoLlBJKTtcbiAgICB9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xuICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB5KTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIE1hdGguUEkgKyBIQUxGX1BJKTtcbiAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCAwKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ZyYW1lKGN0eCwgcmVjdCwgbW9kZWwpIHtcbiAgdmFyIGJnQ29sb3IgPSBtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciBib3JkZXJDb2xvciA9IG1vZGVsLmJvcmRlckNvbG9yO1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aDtcblxuICBpZiAoIWJnQ29sb3IgJiYgKCFib3JkZXJDb2xvciB8fCAhYm9yZGVyV2lkdGgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGRyYXdSb3VuZGVkUmVjdChcbiAgICBjdHgsXG4gICAgcmFzdGVyaXplKHJlY3QueCkgKyBib3JkZXJXaWR0aCAvIDIsXG4gICAgcmFzdGVyaXplKHJlY3QueSkgKyBib3JkZXJXaWR0aCAvIDIsXG4gICAgcmFzdGVyaXplKHJlY3QudykgLSBib3JkZXJXaWR0aCxcbiAgICByYXN0ZXJpemUocmVjdC5oKSAtIGJvcmRlcldpZHRoLFxuICAgIG1vZGVsLmJvcmRlclJhZGl1cyk7XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGlmIChiZ0NvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIGlmIChib3JkZXJDb2xvciAmJiBib3JkZXJXaWR0aCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpIHtcbiAgdmFyIGggPSBmb250LmxpbmVIZWlnaHQ7XG4gIHZhciB3ID0gcmVjdC53O1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0LnkgKyBoIC8gMjtcblxuICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCArPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcgfHwgYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IHc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGg6IGgsXG4gICAgdzogdyxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHJhd1RleHRMaW5lKGN0eCwgdGV4dCwgY2ZnKSB7XG4gIHZhciBzaGFkb3cgPSBjdHguc2hhZG93Qmx1cjtcbiAgdmFyIHN0cm9rZWQgPSBjZmcuc3Ryb2tlZDtcbiAgdmFyIHggPSByYXN0ZXJpemUoY2ZnLngpO1xuICB2YXIgeSA9IHJhc3Rlcml6ZShjZmcueSk7XG4gIHZhciB3ID0gcmFzdGVyaXplKGNmZy53KTtcblxuICBpZiAoc3Ryb2tlZCkge1xuICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIHgsIHksIHcpO1xuICB9XG5cbiAgaWYgKGNmZy5maWxsZWQpIHtcbiAgICBpZiAoc2hhZG93ICYmIHN0cm9rZWQpIHtcbiAgICAgIC8vIFByZXZlbnQgZHJhd2luZyBzaGFkb3cgb24gYm90aCB0aGUgdGV4dCBzdHJva2UgYW5kIGZpbGwsIHNvXG4gICAgICAvLyBpZiB0aGUgdGV4dCBpcyBzdHJva2VkLCByZW1vdmUgdGhlIHNoYWRvdyBmb3IgdGhlIHRleHQgZmlsbC5cbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCwgeSwgdyk7XG5cbiAgICBpZiAoc2hhZG93ICYmIHN0cm9rZWQpIHtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChjdHgsIGxpbmVzLCByZWN0LCBtb2RlbCkge1xuICB2YXIgYWxpZ24gPSBtb2RlbC50ZXh0QWxpZ247XG4gIHZhciBjb2xvciA9IG1vZGVsLmNvbG9yO1xuICB2YXIgZmlsbGVkID0gISFjb2xvcjtcbiAgdmFyIGZvbnQgPSBtb2RlbC5mb250O1xuICB2YXIgaWxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgdmFyIHN0cm9rZUNvbG9yID0gbW9kZWwudGV4dFN0cm9rZUNvbG9yO1xuICB2YXIgc3Ryb2tlV2lkdGggPSBtb2RlbC50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciBzdHJva2VkID0gc3Ryb2tlQ29sb3IgJiYgc3Ryb2tlV2lkdGg7XG4gIHZhciBpO1xuXG4gIGlmICghaWxlbiB8fCAoIWZpbGxlZCAmJiAhc3Ryb2tlZCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBZGp1c3QgY29vcmRpbmF0ZXMgYmFzZWQgb24gdGV4dCBhbGlnbm1lbnQgYW5kIGxpbmUgaGVpZ2h0XG4gIHJlY3QgPSB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpO1xuXG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICBjdHguc2hhZG93Qmx1ciA9IG1vZGVsLnRleHRTaGFkb3dCbHVyO1xuICBjdHguc2hhZG93Q29sb3IgPSBtb2RlbC50ZXh0U2hhZG93Q29sb3I7XG5cbiAgaWYgKGZpbGxlZCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgfVxuICBpZiAoc3Ryb2tlZCkge1xuICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRyYXdUZXh0TGluZShjdHgsIGxpbmVzW2ldLCB7XG4gICAgICBzdHJva2VkOiBzdHJva2VkLFxuICAgICAgZmlsbGVkOiBmaWxsZWQsXG4gICAgICB3OiByZWN0LncsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnkgKyByZWN0LmggKiBpXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIExhYmVsID0gZnVuY3Rpb24oY29uZmlnLCBjdHgsIGVsLCBpbmRleCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIG1lLl9jb25maWcgPSBjb25maWc7XG4gIG1lLl9pbmRleCA9IGluZGV4O1xuICBtZS5fbW9kZWwgPSBudWxsO1xuICBtZS5fcmVjdHMgPSBudWxsO1xuICBtZS5fY3R4ID0gY3R4O1xuICBtZS5fZWwgPSBlbDtcbn07XG5cbm1lcmdlKExhYmVsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb2RlbGl6ZTogZnVuY3Rpb24oZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciBmb250ID0gdG9Gb250KHJlc29sdmUoW2NvbmZpZy5mb250LCB7fV0sIGNvbnRleHQsIGluZGV4KSk7XG4gICAgdmFyIGNvbG9yID0gcmVzb2x2ZShbY29uZmlnLmNvbG9yLCBkZWZhdWx0cyQxLmNvbG9yXSwgY29udGV4dCwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFsaWduOiByZXNvbHZlKFtjb25maWcuYWxpZ24sICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYW5jaG9yOiByZXNvbHZlKFtjb25maWcuYW5jaG9yLCAnY2VudGVyJ10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGFyZWE6IGNvbnRleHQuY2hhcnQuY2hhcnRBcmVhLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiByZXNvbHZlKFtjb25maWcuYmFja2dyb3VuZENvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHJlc29sdmUoW2NvbmZpZy5ib3JkZXJDb2xvciwgbnVsbF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlclJhZGl1czogcmVzb2x2ZShbY29uZmlnLmJvcmRlclJhZGl1cywgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlcldpZHRoOiByZXNvbHZlKFtjb25maWcuYm9yZGVyV2lkdGgsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjbGFtcDogcmVzb2x2ZShbY29uZmlnLmNsYW1wLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNsaXA6IHJlc29sdmUoW2NvbmZpZy5jbGlwLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGRpc3BsYXk6IGRpc3BsYXksXG4gICAgICBmb250OiBmb250LFxuICAgICAgbGluZXM6IGxpbmVzLFxuICAgICAgb2Zmc2V0OiByZXNvbHZlKFtjb25maWcub2Zmc2V0LCA0XSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgb3BhY2l0eTogcmVzb2x2ZShbY29uZmlnLm9wYWNpdHksIDFdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBvcmlnaW46IGdldFNjYWxlT3JpZ2luKG1lLl9lbCwgY29udGV4dCksXG4gICAgICBwYWRkaW5nOiB0b1BhZGRpbmcocmVzb2x2ZShbY29uZmlnLnBhZGRpbmcsIDRdLCBjb250ZXh0LCBpbmRleCkpLFxuICAgICAgcG9zaXRpb25lcjogZ2V0UG9zaXRpb25lcihtZS5fZWwpLFxuICAgICAgcm90YXRpb246IHJlc29sdmUoW2NvbmZpZy5yb3RhdGlvbiwgMF0sIGNvbnRleHQsIGluZGV4KSAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgIHNpemU6IHV0aWxzLnRleHRTaXplKG1lLl9jdHgsIGxpbmVzLCBmb250KSxcbiAgICAgIHRleHRBbGlnbjogcmVzb2x2ZShbY29uZmlnLnRleHRBbGlnbiwgJ3N0YXJ0J10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTaGFkb3dCbHVyOiByZXNvbHZlKFtjb25maWcudGV4dFNoYWRvd0JsdXIsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U2hhZG93Q29sb3I6IHJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Q29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiByZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZUNvbG9yLCBjb2xvcl0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogcmVzb2x2ZShbY29uZmlnLnRleHRTdHJva2VXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbW9kZWwgPSBudWxsO1xuICAgIHZhciByZWN0cyA9IG51bGw7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciBjb25maWcgPSBtZS5fY29uZmlnO1xuICAgIHZhciB2YWx1ZSwgbGFiZWwsIGxpbmVzO1xuXG4gICAgLy8gV2UgZmlyc3QgcmVzb2x2ZSB0aGUgZGlzcGxheSBvcHRpb24gKHNlcGFyYXRlbHkpIHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgIC8vIG90aGVyIG9wdGlvbnMgaW4gY2FzZSB0aGUgbGFiZWwgaXMgaGlkZGVuIChpLmUuIGRpc3BsYXk6IGZhbHNlKS5cbiAgICB2YXIgZGlzcGxheSA9IHJlc29sdmUoW2NvbmZpZy5kaXNwbGF5LCB0cnVlXSwgY29udGV4dCwgaW5kZXgpO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIHZhbHVlID0gY29udGV4dC5kYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgbGFiZWwgPSB2YWx1ZU9yRGVmYXVsdChjYWxsYmFjayhjb25maWcuZm9ybWF0dGVyLCBbdmFsdWUsIGNvbnRleHRdKSwgdmFsdWUpO1xuICAgICAgbGluZXMgPSBpc051bGxPclVuZGVmKGxhYmVsKSA/IFtdIDogdXRpbHMudG9UZXh0TGluZXMobGFiZWwpO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsID0gbWUuX21vZGVsaXplKGRpc3BsYXksIGxpbmVzLCBjb25maWcsIGNvbnRleHQpO1xuICAgICAgICByZWN0cyA9IGJvdW5kaW5nUmVjdHMobW9kZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lLl9tb2RlbCA9IG1vZGVsO1xuICAgIG1lLl9yZWN0cyA9IHJlY3RzO1xuICB9LFxuXG4gIGdlb21ldHJ5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdHMgPyB0aGlzLl9yZWN0cy5mcmFtZSA6IHt9O1xuICB9LFxuXG4gIHJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgPyB0aGlzLl9tb2RlbC5yb3RhdGlvbiA6IDA7XG4gIH0sXG5cbiAgdmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLm9wYWNpdHk7XG4gIH0sXG5cbiAgbW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbihjaGFydCwgY2VudGVyKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgY3R4ID0gY2hhcnQuY3R4O1xuICAgIHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcbiAgICB2YXIgcmVjdHMgPSBtZS5fcmVjdHM7XG4gICAgdmFyIGFyZWE7XG5cbiAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChtb2RlbC5jbGlwKSB7XG4gICAgICBhcmVhID0gbW9kZWwuYXJlYTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5yZWN0KFxuICAgICAgICBhcmVhLmxlZnQsXG4gICAgICAgIGFyZWEudG9wLFxuICAgICAgICBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LFxuICAgICAgICBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdXRpbHMuYm91bmQoMCwgbW9kZWwub3BhY2l0eSwgMSk7XG4gICAgY3R4LnRyYW5zbGF0ZShyYXN0ZXJpemUoY2VudGVyLngpLCByYXN0ZXJpemUoY2VudGVyLnkpKTtcbiAgICBjdHgucm90YXRlKG1vZGVsLnJvdGF0aW9uKTtcblxuICAgIGRyYXdGcmFtZShjdHgsIHJlY3RzLmZyYW1lLCBtb2RlbCk7XG4gICAgZHJhd1RleHQoY3R4LCBtb2RlbC5saW5lcywgcmVjdHMudGV4dCwgbW9kZWwpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufSk7XG5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1taW5zYWZlaW50ZWdlclxudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1heHNhZmVpbnRlZ2VyXG5cbmZ1bmN0aW9uIHJvdGF0ZWQocG9pbnQsIGNlbnRlciwgYW5nbGUpIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIGN4ID0gY2VudGVyLng7XG4gIHZhciBjeSA9IGNlbnRlci55O1xuXG4gIHJldHVybiB7XG4gICAgeDogY3ggKyBjb3MgKiAocG9pbnQueCAtIGN4KSAtIHNpbiAqIChwb2ludC55IC0gY3kpLFxuICAgIHk6IGN5ICsgc2luICogKHBvaW50LnggLSBjeCkgKyBjb3MgKiAocG9pbnQueSAtIGN5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0ZWQocG9pbnRzLCBheGlzKSB7XG4gIHZhciBtaW4gPSBNQVhfSU5URUdFUjtcbiAgdmFyIG1heCA9IE1JTl9JTlRFR0VSO1xuICB2YXIgb3JpZ2luID0gYXhpcy5vcmlnaW47XG4gIHZhciBpLCBwdCwgdngsIHZ5LCBkcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgcHQgPSBwb2ludHNbaV07XG4gICAgdnggPSBwdC54IC0gb3JpZ2luLng7XG4gICAgdnkgPSBwdC55IC0gb3JpZ2luLnk7XG4gICAgZHAgPSBheGlzLnZ4ICogdnggKyBheGlzLnZ5ICogdnk7XG4gICAgbWluID0gTWF0aC5taW4obWluLCBkcCk7XG4gICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkcCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQXhpcyhwMCwgcDEpIHtcbiAgdmFyIHZ4ID0gcDEueCAtIHAwLng7XG4gIHZhciB2eSA9IHAxLnkgLSBwMC55O1xuICB2YXIgbG4gPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG4gIHJldHVybiB7XG4gICAgdng6IChwMS54IC0gcDAueCkgLyBsbixcbiAgICB2eTogKHAxLnkgLSBwMC55KSAvIGxuLFxuICAgIG9yaWdpbjogcDAsXG4gICAgbG46IGxuXG4gIH07XG59XG5cbnZhciBIaXRCb3ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcm90YXRpb24gPSAwO1xuICB0aGlzLl9yZWN0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3OiAwLFxuICAgIGg6IDBcbiAgfTtcbn07XG5cbm1lcmdlKEhpdEJveC5wcm90b3R5cGUsIHtcbiAgY2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHRoaXMuX3JlY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHIueCArIHIudyAvIDIsXG4gICAgICB5OiByLnkgKyByLmggLyAyXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNlbnRlciwgcmVjdCwgcm90YXRpb24pIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuX3JlY3QgPSB7XG4gICAgICB4OiByZWN0LnggKyBjZW50ZXIueCxcbiAgICAgIHk6IHJlY3QueSArIGNlbnRlci55LFxuICAgICAgdzogcmVjdC53LFxuICAgICAgaDogcmVjdC5oXG4gICAgfTtcbiAgfSxcblxuICBjb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtYXJnaW4gPSAxO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG5cbiAgICBwb2ludCA9IHJvdGF0ZWQocG9pbnQsIG1lLmNlbnRlcigpLCAtbWUuX3JvdGF0aW9uKTtcblxuICAgIHJldHVybiAhKHBvaW50LnggPCByZWN0LnggLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnkgPCByZWN0LnkgLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnggPiByZWN0LnggKyByZWN0LncgKyBtYXJnaW4gKiAyXG4gICAgICB8fCBwb2ludC55ID4gcmVjdC55ICsgcmVjdC5oICsgbWFyZ2luICogMik7XG4gIH0sXG5cbiAgLy8gU2VwYXJhdGluZyBBeGlzIFRoZW9yZW1cbiAgLy8gaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICB2YXIgcjAgPSB0aGlzLl9wb2ludHMoKTtcbiAgICB2YXIgcjEgPSBvdGhlci5fcG9pbnRzKCk7XG4gICAgdmFyIGF4ZXMgPSBbXG4gICAgICB0b0F4aXMocjBbMF0sIHIwWzFdKSxcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbM10pXG4gICAgXTtcbiAgICB2YXIgaSwgcHIwLCBwcjE7XG5cbiAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IG90aGVyLl9yb3RhdGlvbikge1xuICAgICAgLy8gT25seSBzZXBhcmF0ZSB3aXRoIHIxIGF4aXMgaWYgdGhlIHJvdGF0aW9uIGlzIGRpZmZlcmVudCxcbiAgICAgIC8vIGVsc2UgaXQncyBlbm91Z2ggdG8gc2VwYXJhdGUgcjAgYW5kIHIxIHdpdGggcjAgYXhpcyBvbmx5IVxuICAgICAgYXhlcy5wdXNoKFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzFdKSxcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVszXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHByMCA9IHByb2plY3RlZChyMCwgYXhlc1tpXSk7XG4gICAgICBwcjEgPSBwcm9qZWN0ZWQocjEsIGF4ZXNbaV0pO1xuXG4gICAgICBpZiAocHIwLm1heCA8IHByMS5taW4gfHwgcHIxLm1heCA8IHByMC5taW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BvaW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVjdCA9IG1lLl9yZWN0O1xuICAgIHZhciBhbmdsZSA9IG1lLl9yb3RhdGlvbjtcbiAgICB2YXIgY2VudGVyID0gbWUuY2VudGVyKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LnggKyByZWN0LncsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0Lmh9LCBjZW50ZXIsIGFuZ2xlKVxuICAgIF07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb29yZGluYXRlcyhlbCwgbW9kZWwsIGdlb21ldHJ5KSB7XG4gIHZhciBwb2ludCA9IG1vZGVsLnBvc2l0aW9uZXIoZWwsIG1vZGVsKTtcbiAgdmFyIHZ4ID0gcG9pbnQudng7XG4gIHZhciB2eSA9IHBvaW50LnZ5O1xuXG4gIGlmICghdnggJiYgIXZ5KSB7XG4gICAgLy8gaWYgYWxpZ25lZCBjZW50ZXIsIHdlIGRvbid0IHdhbnQgdG8gb2Zmc2V0IHRoZSBjZW50ZXIgcG9pbnRcbiAgICByZXR1cm4ge3g6IHBvaW50LngsIHk6IHBvaW50Lnl9O1xuICB9XG5cbiAgdmFyIHcgPSBnZW9tZXRyeS53O1xuICB2YXIgaCA9IGdlb21ldHJ5Lmg7XG5cbiAgLy8gdGFrZSBpbiBhY2NvdW50IHRoZSBsYWJlbCByb3RhdGlvblxuICB2YXIgcm90YXRpb24gPSBtb2RlbC5yb3RhdGlvbjtcbiAgdmFyIGR4ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpO1xuICB2YXIgZHkgPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSk7XG5cbiAgLy8gc2NhbGUgdGhlIHVuaXQgdmVjdG9yICh2eCwgdnkpIHRvIGdldCBhdCBsZWFzdCBkeCBvciBkeSBlcXVhbCB0b1xuICAvLyB3IG9yIGggcmVzcGVjdGl2ZWx5IChlbHNlIHdlIHdvdWxkIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlXG4gIC8vIGVsbGlwc2UgaW5zY3JpYmVkIGluIHRoZSBib3VuZGluZyByZWN0KVxuICB2YXIgdnMgPSAxIC8gTWF0aC5tYXgoTWF0aC5hYnModngpLCBNYXRoLmFicyh2eSkpO1xuICBkeCAqPSB2eCAqIHZzO1xuICBkeSAqPSB2eSAqIHZzO1xuXG4gIC8vIGZpbmFsbHksIGluY2x1ZGUgdGhlIGV4cGxpY2l0IG9mZnNldFxuICBkeCArPSBtb2RlbC5vZmZzZXQgKiB2eDtcbiAgZHkgKz0gbW9kZWwub2Zmc2V0ICogdnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludC54ICsgZHgsXG4gICAgeTogcG9pbnQueSArIGR5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGUobGFiZWxzLCBjb2xsaWRlcikge1xuICB2YXIgaSwgaiwgczAsIHMxO1xuXG4gIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2YgdGhlXG4gIC8vIGxpc3QgaGF2ZSBhbiBoaWdoZXIgd2VpZ2h0L3ByaW9yaXR5IGFuZCB0aHVzIHNob3VsZCBiZSBsZXNzIGltcGFjdGVkXG4gIC8vIGJ5IHRoZSBvdmVybGFwcGluZyBzdHJhdGVneS5cblxuICBmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBzMCA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG4gICAgZm9yIChqID0gaSAtIDE7IGogPj0gMCAmJiBzMC5fdmlzaWJsZTsgLS1qKSB7XG4gICAgICBzMSA9IGxhYmVsc1tqXS4kbGF5b3V0O1xuXG4gICAgICBpZiAoczEuX3Zpc2libGUgJiYgczAuX2JveC5pbnRlcnNlY3RzKHMxLl9ib3gpKSB7XG4gICAgICAgIGNvbGxpZGVyKHMwLCBzMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZShsYWJlbHMpIHtcbiAgdmFyIGksIGlsZW4sIGxhYmVsLCBzdGF0ZSwgZ2VvbWV0cnksIGNlbnRlciwgcHJveHk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYWJlbHMgZm9yIG92ZXJsYXAgZGV0ZWN0aW9uXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICAvLyBDaGFydC5qcyAzIHJlbW92ZWQgZWwuX21vZGVsIGluIGZhdm9yIG9mIGdldFByb3BzKCksIG1ha2luZyBoYXJkZXIgdG9cbiAgICAgIC8vIGFic3RyYWN0IHJlYWRpbmcgdmFsdWVzIGluIHBvc2l0aW9uZXJzLiBBbHNvLCB1c2luZyBzdHJpbmcgYXJyYXlzIHRvXG4gICAgICAvLyByZWFkIHZhbHVlcyAoaS5lLiB2YXIge2EsYixjfSA9IGVsLmdldFByb3BzKFtcImFcIixcImJcIixcImNcIl0pKSB3b3VsZCBtYWtlXG4gICAgICAvLyBwb3NpdGlvbmVycyBpbmVmZmljaWVudCBpbiB0aGUgbm9ybWFsIGNhc2UgKGkuZS4gbm90IHRoZSBmaW5hbCB2YWx1ZXMpXG4gICAgICAvLyBhbmQgdGhlIGNvZGUgYSBiaXQgdWdseSwgc28gbGV0J3MgdXNlIGEgUHJveHkgaW5zdGVhZC5cbiAgICAgIHByb3h5ID0gbmV3IFByb3h5KGxhYmVsLl9lbCwge2dldDogKGVsLCBwKSA9PiBlbC5nZXRQcm9wcyhbcF0sIHRydWUpW3BdfSk7XG5cbiAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcbiAgICAgIGNlbnRlciA9IGNvb3JkaW5hdGVzKHByb3h5LCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvIGhpZGUgb3ZlcmxhcHBpbmcgbGFiZWxzXG4gIHJldHVybiBjb2xsaWRlKGxhYmVscywgZnVuY3Rpb24oczAsIHMxKSB7XG4gICAgdmFyIGgwID0gczAuX2hpZGFibGU7XG4gICAgdmFyIGgxID0gczEuX2hpZGFibGU7XG5cbiAgICBpZiAoKGgwICYmIGgxKSB8fCBoMSkge1xuICAgICAgczEuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGgwKSB7XG4gICAgICBzMC5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXlvdXQgPSB7XG4gIHByZXBhcmU6IGZ1bmN0aW9uKGRhdGFzZXRzKSB7XG4gICAgdmFyIGxhYmVscyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBsYWJlbDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhc2V0c1tpXS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgbGFiZWwgPSBkYXRhc2V0c1tpXVtqXTtcbiAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICBsYWJlbC4kbGF5b3V0ID0ge1xuICAgICAgICAgIF9ib3g6IG5ldyBIaXRCb3goKSxcbiAgICAgICAgICBfaGlkYWJsZTogZmFsc2UsXG4gICAgICAgICAgX3Zpc2libGU6IHRydWUsXG4gICAgICAgICAgX3NldDogaSxcbiAgICAgICAgICBfaWR4OiBsYWJlbC5faW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIE5ldyBgemAgb3B0aW9uOiBsYWJlbHMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3blxuICAgIC8vIG9mIHRvcCBvZiB0aGUgb25lcyB3aXRoIGEgbG93ZXIgaW5kZXguIExvd2VzdCB6LWluZGV4IGxhYmVsc1xuICAgIC8vIGFyZSBhbHNvIGRpc2NhcmRlZCBmaXJzdCB3aGVuIGhpZGluZyBvdmVybGFwcGluZyBsYWJlbHMuXG4gICAgbGFiZWxzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIHNhID0gYS4kbGF5b3V0O1xuICAgICAgdmFyIHNiID0gYi4kbGF5b3V0O1xuXG4gICAgICByZXR1cm4gc2EuX2lkeCA9PT0gc2IuX2lkeFxuICAgICAgICA/IHNiLl9zZXQgLSBzYS5fc2V0XG4gICAgICAgIDogc2IuX2lkeCAtIHNhLl9pZHg7XG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZShsYWJlbHMpO1xuXG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGxhYmVscykge1xuICAgIHZhciBkaXJ0eSA9IGZhbHNlO1xuICAgIHZhciBpLCBpbGVuLCBsYWJlbCwgbW9kZWwsIHN0YXRlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgbW9kZWwgPSBsYWJlbC5tb2RlbCgpO1xuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuICAgICAgc3RhdGUuX2hpZGFibGUgPSBtb2RlbCAmJiBtb2RlbC5kaXNwbGF5ID09PSAnYXV0byc7XG4gICAgICBzdGF0ZS5fdmlzaWJsZSA9IGxhYmVsLnZpc2libGUoKTtcbiAgICAgIGRpcnR5IHw9IHN0YXRlLl9oaWRhYmxlO1xuICAgIH1cblxuICAgIGlmIChkaXJ0eSkge1xuICAgICAgY29tcHV0ZShsYWJlbHMpO1xuICAgIH1cbiAgfSxcblxuICBsb29rdXA6IGZ1bmN0aW9uKGxhYmVscywgcG9pbnQpIHtcbiAgICB2YXIgaSwgc3RhdGU7XG5cbiAgICAvLyBJTVBPUlRBTlQgSXRlcmF0ZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBzaW5jZSBpdGVtcyBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIGxpc3QgaGF2ZSBhbiBoaWdoZXIgei1pbmRleCwgdGh1cyBzaG91bGQgYmUgcGlja2VkIGZpcnN0LlxuXG4gICAgZm9yIChpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdGF0ZSA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG4gICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuX3Zpc2libGUgJiYgc3RhdGUuX2JveC5jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbihjaGFydCwgbGFiZWxzKSB7XG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBzdGF0ZSwgZ2VvbWV0cnksIGNlbnRlcjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcblxuICAgICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcbiAgICAgICAgY2VudGVyID0gY29vcmRpbmF0ZXMobGFiZWwuX2VsLCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xuICAgICAgICBsYWJlbC5kcmF3KGNoYXJ0LCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGZvcm1hdHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxhYmVsID0gdmFsdWU7XG4gIHZhciBrZXlzLCBrbGVuLCBrO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlLmxhYmVsKSkge1xuICAgICAgbGFiZWwgPSB2YWx1ZS5sYWJlbDtcbiAgICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlLnIpKSB7XG4gICAgICBsYWJlbCA9IHZhbHVlLnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsID0gJyc7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgZm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICAgIGxhYmVsICs9IChrICE9PSAwID8gJywgJyA6ICcnKSArIGtleXNba10gKyAnOiAnICsgdmFsdWVba2V5c1trXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnICsgbGFiZWw7XG59O1xuXG4vKipcbiAqIElNUE9SVEFOVDogbWFrZSBzdXJlIHRvIGFsc28gdXBkYXRlIHRlc3RzIGFuZCBUeXBlU2NyaXB0IGRlZmluaXRpb25cbiAqIGZpbGVzIChgL3Rlc3Qvc3BlY3MvZGVmYXVsdHMuc3BlYy5qc2AgYW5kIGAvdHlwZXMvb3B0aW9ucy5kLnRzYClcbiAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFsaWduOiAnY2VudGVyJyxcbiAgYW5jaG9yOiAnY2VudGVyJyxcbiAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICBib3JkZXJDb2xvcjogbnVsbCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMCxcbiAgY2xhbXA6IGZhbHNlLFxuICBjbGlwOiBmYWxzZSxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgZGlzcGxheTogdHJ1ZSxcbiAgZm9udDoge1xuICAgIGZhbWlseTogdW5kZWZpbmVkLFxuICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgICB3ZWlnaHQ6IG51bGxcbiAgfSxcbiAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gIGxhYmVsczogdW5kZWZpbmVkLFxuICBsaXN0ZW5lcnM6IHt9LFxuICBvZmZzZXQ6IDQsXG4gIG9wYWNpdHk6IDEsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDQsXG4gICAgcmlnaHQ6IDQsXG4gICAgYm90dG9tOiA0LFxuICAgIGxlZnQ6IDRcbiAgfSxcbiAgcm90YXRpb246IDAsXG4gIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgdGV4dFN0cm9rZUNvbG9yOiB1bmRlZmluZWQsXG4gIHRleHRTdHJva2VXaWR0aDogMCxcbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG4gIHRleHRTaGFkb3dDb2xvcjogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNzZcbiAqL1xuXG52YXIgRVhQQU5ET19LRVkgPSAnJGRhdGFsYWJlbHMnO1xudmFyIERFRkFVTFRfS0VZID0gJyRkZWZhdWx0JztcblxuZnVuY3Rpb24gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpIHtcbiAgdmFyIG92ZXJyaWRlID0gZGF0YXNldC5kYXRhbGFiZWxzO1xuICB2YXIgbGlzdGVuZXJzID0ge307XG4gIHZhciBjb25maWdzID0gW107XG4gIHZhciBsYWJlbHMsIGtleXM7XG5cbiAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgIG92ZXJyaWRlID0ge307XG4gIH1cblxuICBvcHRpb25zID0gbWVyZ2Uoe30sIFtvcHRpb25zLCBvdmVycmlkZV0pO1xuICBsYWJlbHMgPSBvcHRpb25zLmxhYmVscyB8fCB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscyk7XG4gIGRlbGV0ZSBvcHRpb25zLmxhYmVscztcblxuICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAobGFiZWxzW2tleV0pIHtcbiAgICAgICAgY29uZmlncy5wdXNoKG1lcmdlKHt9LCBbXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBsYWJlbHNba2V5XSxcbiAgICAgICAgICB7X2tleToga2V5fVxuICAgICAgICBdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBsYWJlbCBpZiBubyBcIm5hbWVkXCIgbGFiZWwgZGVmaW5lZC5cbiAgICBjb25maWdzLnB1c2gob3B0aW9ucyk7XG4gIH1cblxuICAvLyBsaXN0ZW5lcnM6IHs8ZXZlbnQtdHlwZT46IHs8bGFiZWwta2V5PjogPGZuPn19XG4gIGxpc3RlbmVycyA9IGNvbmZpZ3MucmVkdWNlKGZ1bmN0aW9uKHRhcmdldCwgY29uZmlnKSB7XG4gICAgZWFjaChjb25maWcubGlzdGVuZXJzIHx8IHt9LCBmdW5jdGlvbihmbiwgZXZlbnQpIHtcbiAgICAgIHRhcmdldFtldmVudF0gPSB0YXJnZXRbZXZlbnRdIHx8IHt9O1xuICAgICAgdGFyZ2V0W2V2ZW50XVtjb25maWcuX2tleSB8fCBERUZBVUxUX0tFWV0gPSBmbjtcbiAgICB9KTtcblxuICAgIGRlbGV0ZSBjb25maWcubGlzdGVuZXJzO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sIHt9KTtcblxuICByZXR1cm4ge1xuICAgIGxhYmVsczogY29uZmlncyxcbiAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMsIGxhYmVsLCBldmVudCkge1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gbGFiZWwuJGNvbnRleHQ7XG4gIHZhciBncm91cHMgPSBsYWJlbC4kZ3JvdXBzO1xuICB2YXIgY2FsbGJhY2skMTtcblxuICBpZiAoIWxpc3RlbmVyc1tncm91cHMuX3NldF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWxsYmFjayQxID0gbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XVtncm91cHMuX2tleV07XG4gIGlmICghY2FsbGJhY2skMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjYWxsYmFjayhjYWxsYmFjayQxLCBbY29udGV4dCwgZXZlbnRdKSA9PT0gdHJ1ZSkge1xuICAgIC8vIFVzZXJzIGFyZSBhbGxvd2VkIHRvIHR3ZWFrIHRoZSBnaXZlbiBjb250ZXh0IGJ5IGluamVjdGluZyB2YWx1ZXMgdGhhdCBjYW4gYmVcbiAgICAvLyB1c2VkIGluIHNjcmlwdGFibGUgb3B0aW9ucyB0byBkaXNwbGF5IGxhYmVscyBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgIC8vIGV2ZW50IChlLmcuIGhpZ2hsaWdodCBhbiBob3ZlcmVkIGxhYmVsKS4gVGhhdCdzIHdoeSB3ZSB1cGRhdGUgdGhlIGxhYmVsIHdpdGhcbiAgICAvLyB0aGUgb3V0cHV0IGNvbnRleHQgYW5kIHNjaGVkdWxlIGEgbmV3IGNoYXJ0IHJlbmRlciBieSBzZXR0aW5nIGl0IGRpcnR5LlxuICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fZGlydHkgPSB0cnVlO1xuICAgIGxhYmVsLnVwZGF0ZShjb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaE1vdmVFdmVudHMoY2hhcnQsIGxpc3RlbmVycywgcHJldmlvdXMsIGxhYmVsLCBldmVudCkge1xuICB2YXIgZW50ZXIsIGxlYXZlO1xuXG4gIGlmICghcHJldmlvdXMgJiYgIWxhYmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFwcmV2aW91cykge1xuICAgIGVudGVyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICghbGFiZWwpIHtcbiAgICBsZWF2ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAocHJldmlvdXMgIT09IGxhYmVsKSB7XG4gICAgbGVhdmUgPSBlbnRlciA9IHRydWU7XG4gIH1cblxuICBpZiAobGVhdmUpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMubGVhdmUsIHByZXZpb3VzLCBldmVudCk7XG4gIH1cbiAgaWYgKGVudGVyKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmVudGVyLCBsYWJlbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KSB7XG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICB2YXIgbGlzdGVuZXJzID0gZXhwYW5kby5fbGlzdGVuZXJzO1xuICB2YXIgcHJldmlvdXMsIGxhYmVsO1xuXG4gIGlmICghbGlzdGVuZXJzLmVudGVyICYmICFsaXN0ZW5lcnMubGVhdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICBsYWJlbCA9IGxheW91dC5sb29rdXAoZXhwYW5kby5fbGFiZWxzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQudHlwZSAhPT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByZXZpb3VzID0gZXhwYW5kby5faG92ZXJlZDtcbiAgZXhwYW5kby5faG92ZXJlZCA9IGxhYmVsO1xuICBkaXNwYXRjaE1vdmVFdmVudHMoY2hhcnQsIGxpc3RlbmVycywgcHJldmlvdXMsIGxhYmVsLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCkge1xuICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgdmFyIGhhbmRsZXJzID0gZXhwYW5kby5fbGlzdGVuZXJzLmNsaWNrO1xuICB2YXIgbGFiZWwgPSBoYW5kbGVycyAmJiBsYXlvdXQubG9va3VwKGV4cGFuZG8uX2xhYmVscywgZXZlbnQpO1xuICBpZiAobGFiZWwpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBoYW5kbGVycywgbGFiZWwsIGV2ZW50KTtcbiAgfVxufVxuXG52YXIgcGx1Z2luID0ge1xuICBpZDogJ2RhdGFsYWJlbHMnLFxuXG4gIGRlZmF1bHRzOiBkZWZhdWx0cyxcblxuICBiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuICAgIGNoYXJ0W0VYUEFORE9fS0VZXSA9IHtcbiAgICAgIF9hY3RpdmVzOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuICAgIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICAgIGV4cGFuZG8uX2xpc3RlbmVkID0gZmFsc2U7XG4gICAgZXhwYW5kby5fbGlzdGVuZXJzID0ge307ICAgICAvLyB7PGV2ZW50LXR5cGU+OiB7PGRhdGFzZXQtaW5kZXg+OiB7PGxhYmVsLWtleT46IDxmbj59fX1cbiAgICBleHBhbmRvLl9kYXRhc2V0cyA9IFtdOyAgICAgIC8vIHBlciBkYXRhc2V0IGxhYmVsczogW0xhYmVsW11dXG4gICAgZXhwYW5kby5fbGFiZWxzID0gW107ICAgICAgICAvLyBsYXlvdXRlZCBsYWJlbHM6IExhYmVsW11cbiAgfSxcblxuICBhZnRlckRhdGFzZXRVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgdmFyIGRhdGFzZXRJbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIGxhYmVscyA9IGV4cGFuZG8uX2RhdGFzZXRzW2RhdGFzZXRJbmRleF0gPSBbXTtcbiAgICB2YXIgdmlzaWJsZSA9IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KTtcbiAgICB2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICB2YXIgY29uZmlnID0gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpO1xuICAgIHZhciBlbGVtZW50cyA9IGFyZ3MubWV0YS5kYXRhIHx8IFtdO1xuICAgIHZhciBjdHggPSBjaGFydC5jdHg7XG4gICAgdmFyIGksIGosIGlsZW4sIGpsZW4sIGNmZywga2V5LCBlbCwgbGFiZWw7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgZWwgPSBlbGVtZW50c1tpXTtcbiAgICAgIGVsW0VYUEFORE9fS0VZXSA9IFtdO1xuXG4gICAgICBpZiAodmlzaWJsZSAmJiBlbCAmJiBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhZWwuc2tpcCkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gY29uZmlnLmxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBjZmcgPSBjb25maWcubGFiZWxzW2pdO1xuICAgICAgICAgIGtleSA9IGNmZy5fa2V5O1xuXG4gICAgICAgICAgbGFiZWwgPSBuZXcgTGFiZWwoY2ZnLCBjdHgsIGVsLCBpKTtcbiAgICAgICAgICBsYWJlbC4kZ3JvdXBzID0ge1xuICAgICAgICAgICAgX3NldDogZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgX2tleToga2V5IHx8IERFRkFVTFRfS0VZXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsYWJlbC4kY29udGV4dCA9IHtcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBjaGFydDogY2hhcnQsXG4gICAgICAgICAgICBkYXRhSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgICBlbFtFWFBBTkRPX0tFWV0ucHVzaChsYWJlbCk7XG4gICAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIC8vIFN0b3JlIGxpc3RlbmVycyBhdCB0aGUgY2hhcnQgbGV2ZWwgYW5kIHBlciBldmVudCB0eXBlIHRvIG9wdGltaXplXG4gICAgLy8gY2FzZXMgd2hlcmUgbm8gbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuICAgIG1lcmdlKGV4cGFuZG8uX2xpc3RlbmVycywgY29uZmlnLmxpc3RlbmVycywge1xuICAgICAgbWVyZ2VyOiBmdW5jdGlvbihldmVudCwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICAgIHRhcmdldFtldmVudF1bYXJncy5pbmRleF0gPSBzb3VyY2VbZXZlbnRdO1xuICAgICAgICBleHBhbmRvLl9saXN0ZW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMgPSBsYXlvdXQucHJlcGFyZShjaGFydFtFWFBBTkRPX0tFWV0uX2RhdGFzZXRzKTtcbiAgfSxcblxuICAvLyBEcmF3IGxhYmVscyBvbiB0b3Agb2YgYWxsIGRhdGFzZXQgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMjlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMzJcbiAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgbGF5b3V0LmRyYXcoY2hhcnQsIGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzKTtcbiAgfSxcblxuICBiZWZvcmVFdmVudDogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBsaXN0ZW5lciByZWdpc3RlcmVkIGZvciB0aGlzIGNoYXJ0LCBgbGlzdGVuZWRgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gbWVhbmluZyB3ZSBjYW4gaW1tZWRpYXRlbHkgaWdub3JlIHRoZSBpbmNvbWluZyBldmVudCBhbmQgYXZvaWQgdXNlbGVzcyBleHRyYVxuICAgIC8vIGNvbXB1dGF0aW9uIGZvciB1c2VycyB3aG8gZG9uJ3QgaW1wbGVtZW50IGxhYmVsIGludGVyYWN0aW9ucy5cbiAgICBpZiAoY2hhcnRbRVhQQU5ET19LRVldLl9saXN0ZW5lZCkge1xuICAgICAgdmFyIGV2ZW50ID0gYXJncy5ldmVudDtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIHByZXZpb3VzID0gZXhwYW5kby5fYWN0aXZlcztcbiAgICB2YXIgYWN0aXZlcyA9IGV4cGFuZG8uX2FjdGl2ZXMgPSBjaGFydC5nZXRBY3RpdmVFbGVtZW50cygpO1xuICAgIHZhciB1cGRhdGVzID0gdXRpbHMuYXJyYXlEaWZmKHByZXZpb3VzLCBhY3RpdmVzKTtcbiAgICB2YXIgaSwgaWxlbiwgaiwgamxlbiwgdXBkYXRlLCBsYWJlbCwgbGFiZWxzO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHVwZGF0ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZVsxXSkge1xuICAgICAgICBsYWJlbHMgPSB1cGRhdGVbMF0uZWxlbWVudFtFWFBBTkRPX0tFWV0gfHwgW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbGFiZWwgPSBsYWJlbHNbal07XG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQuYWN0aXZlID0gKHVwZGF0ZVsxXSA9PT0gMSk7XG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBhbmRvLl9kaXJ0eSB8fCB1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgbGF5b3V0LnVwZGF0ZShleHBhbmRvLl9sYWJlbHMpO1xuICAgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGV4cGFuZG8uX2RpcnR5O1xuICB9XG59O1xuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImlzTnVsbE9yVW5kZWYiLCJtZXJnZSIsInRvRm9udCIsInJlc29sdmUiLCJ0b1BhZGRpbmciLCJ2YWx1ZU9yRGVmYXVsdCIsImNhbGxiYWNrIiwiaXNPYmplY3QiLCJlYWNoIiwiZGVmYXVsdHMiLCJkZWZhdWx0cyQxIiwiQXJjRWxlbWVudCIsIlBvaW50RWxlbWVudCIsIkJhckVsZW1lbnQiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93Iiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwidXRpbHMiLCJ0b1RleHRMaW5lcyIsImlucHV0cyIsImxpbmVzIiwiaW5wdXQiLCJjb25jYXQiLCJsZW5ndGgiLCJwb3AiLCJ1bnNoaWZ0IiwiYXBwbHkiLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJ0ZXh0U2l6ZSIsImN0eCIsImZvbnQiLCJpdGVtcyIsImlsZW4iLCJwcmV2Iiwid2lkdGgiLCJpIiwic3RyaW5nIiwiTWF0aCIsIm1heCIsIm1lYXN1cmVUZXh0IiwiaGVpZ2h0IiwibGluZUhlaWdodCIsImJvdW5kIiwibWluIiwidmFsdWUiLCJhcnJheURpZmYiLCJhMCIsImExIiwic2xpY2UiLCJ1cGRhdGVzIiwiaiIsInYiLCJpbmRleE9mIiwic3BsaWNlIiwicmFzdGVyaXplIiwicm91bmQiLCJvcmllbnQiLCJwb2ludCIsIm9yaWdpbiIsIngwIiwieCIsInkwIiwieSIsImR4IiwiZHkiLCJsbiIsInNxcnQiLCJhbGlnbmVkIiwidngiLCJ2eSIsImFsaWduIiwiUEkiLCJjb3MiLCJzaW4iLCJSX0lOU0lERSIsIlJfTEVGVCIsIlJfUklHSFQiLCJSX0JPVFRPTSIsIlJfVE9QIiwicmVnaW9uIiwicmVjdCIsInJlcyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImNsaXBwZWQiLCJzZWdtZW50IiwiYXJlYSIsIngxIiwieTEiLCJyMCIsInIxIiwiciIsImNvbXB1dGUkMSIsInJhbmdlIiwiY29uZmlnIiwiYW5jaG9yIiwiY2xhbXAiLCJwb3NpdGlvbmVycyIsImFyYyIsImVsIiwiYW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwicngiLCJvcHRpb25zIiwicmFkaXVzIiwicnkiLCJiYXIiLCJzeCIsInN5IiwiaG9yaXpvbnRhbCIsImJhc2UiLCJhYnMiLCJmYWxsYmFjayIsImJvdW5kaW5nUmVjdHMiLCJtb2RlbCIsImJvcmRlcldpZHRoIiwicGFkZGluZyIsInRoIiwic2l6ZSIsInR3IiwidHgiLCJ0eSIsImZyYW1lIiwidyIsImgiLCJ0ZXh0IiwiZ2V0U2NhbGVPcmlnaW4iLCJjb250ZXh0Iiwic2NhbGUiLCJjaGFydCIsImdldERhdGFzZXRNZXRhIiwiZGF0YXNldEluZGV4IiwidlNjYWxlIiwieENlbnRlciIsInVuZGVmaW5lZCIsInlDZW50ZXIiLCJwaXhlbCIsImdldEJhc2VQaXhlbCIsImdldFBvc2l0aW9uZXIiLCJkcmF3Um91bmRlZFJlY3QiLCJIQUxGX1BJIiwibW92ZVRvIiwiY2xvc2VQYXRoIiwiZHJhd0ZyYW1lIiwiYmdDb2xvciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiYmVnaW5QYXRoIiwiYm9yZGVyUmFkaXVzIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJzdHJva2UiLCJ0ZXh0R2VvbWV0cnkiLCJkcmF3VGV4dExpbmUiLCJjZmciLCJzaGFkb3ciLCJzaGFkb3dCbHVyIiwic3Ryb2tlZCIsInN0cm9rZVRleHQiLCJmaWxsZWQiLCJmaWxsVGV4dCIsImRyYXdUZXh0IiwidGV4dEFsaWduIiwiY29sb3IiLCJzdHJva2VDb2xvciIsInRleHRTdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwidGV4dFN0cm9rZVdpZHRoIiwidGV4dEJhc2VsaW5lIiwidGV4dFNoYWRvd0JsdXIiLCJzaGFkb3dDb2xvciIsInRleHRTaGFkb3dDb2xvciIsIkxhYmVsIiwiaW5kZXgiLCJtZSIsIl9jb25maWciLCJfaW5kZXgiLCJfbW9kZWwiLCJfcmVjdHMiLCJfY3R4IiwiX2VsIiwicHJvdG90eXBlIiwiX21vZGVsaXplIiwiZGlzcGxheSIsImNoYXJ0QXJlYSIsImNsaXAiLCJvZmZzZXQiLCJvcGFjaXR5IiwicG9zaXRpb25lciIsInJvdGF0aW9uIiwidXBkYXRlIiwicmVjdHMiLCJsYWJlbCIsImRhdGFzZXQiLCJkYXRhIiwiZm9ybWF0dGVyIiwiZ2VvbWV0cnkiLCJ2aXNpYmxlIiwiZHJhdyIsImNlbnRlciIsInNhdmUiLCJnbG9iYWxBbHBoYSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlc3RvcmUiLCJNSU5fSU5URUdFUiIsIk51bWJlciIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyb3RhdGVkIiwiY3giLCJjeSIsInByb2plY3RlZCIsInBvaW50cyIsImF4aXMiLCJwdCIsImRwIiwidG9BeGlzIiwicDAiLCJwMSIsIkhpdEJveCIsIl9yb3RhdGlvbiIsIl9yZWN0IiwiY29udGFpbnMiLCJtYXJnaW4iLCJpbnRlcnNlY3RzIiwib3RoZXIiLCJfcG9pbnRzIiwiYXhlcyIsInByMCIsInByMSIsImNvb3JkaW5hdGVzIiwidnMiLCJjb2xsaWRlIiwibGFiZWxzIiwiY29sbGlkZXIiLCJzMCIsInMxIiwiJGxheW91dCIsIl92aXNpYmxlIiwiX2JveCIsImNvbXB1dGUiLCJzdGF0ZSIsInByb3h5IiwiUHJveHkiLCJnZXQiLCJwIiwiZ2V0UHJvcHMiLCJoMCIsIl9oaWRhYmxlIiwiaDEiLCJsYXlvdXQiLCJwcmVwYXJlIiwiZGF0YXNldHMiLCJqbGVuIiwiX3NldCIsIl9pZHgiLCJzb3J0IiwiYSIsImIiLCJzYSIsInNiIiwiZGlydHkiLCJsb29rdXAiLCJrZXlzIiwia2xlbiIsImsiLCJPYmplY3QiLCJmYW1pbHkiLCJzdHlsZSIsIndlaWdodCIsImxpc3RlbmVycyIsIkVYUEFORE9fS0VZIiwiREVGQVVMVF9LRVkiLCJjb25maWd1cmUiLCJvdmVycmlkZSIsImRhdGFsYWJlbHMiLCJjb25maWdzIiwiZm9yRWFjaCIsImtleSIsIl9rZXkiLCJyZWR1Y2UiLCJ0YXJnZXQiLCJmbiIsImV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIiRjb250ZXh0IiwiZ3JvdXBzIiwiJGdyb3VwcyIsImNhbGxiYWNrJDEiLCJfZGlydHkiLCJkaXNwYXRjaE1vdmVFdmVudHMiLCJwcmV2aW91cyIsImVudGVyIiwibGVhdmUiLCJoYW5kbGVNb3ZlRXZlbnRzIiwiZXhwYW5kbyIsIl9saXN0ZW5lcnMiLCJ0eXBlIiwiX2xhYmVscyIsIl9ob3ZlcmVkIiwiaGFuZGxlQ2xpY2tFdmVudHMiLCJoYW5kbGVycyIsImNsaWNrIiwicGx1Z2luIiwiaWQiLCJiZWZvcmVJbml0IiwiX2FjdGl2ZXMiLCJiZWZvcmVVcGRhdGUiLCJfbGlzdGVuZWQiLCJfZGF0YXNldHMiLCJhZnRlckRhdGFzZXRVcGRhdGUiLCJhcmdzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImVsZW1lbnRzIiwibWV0YSIsImdldERhdGFWaXNpYmlsaXR5Iiwic2tpcCIsImFjdGl2ZSIsImRhdGFJbmRleCIsIm1lcmdlciIsInNvdXJjZSIsImFmdGVyVXBkYXRlIiwiYWZ0ZXJEYXRhc2V0c0RyYXciLCJiZWZvcmVFdmVudCIsImFmdGVyRXZlbnQiLCJhY3RpdmVzIiwiZ2V0QWN0aXZlRWxlbWVudHMiLCJlbGVtZW50IiwicmVuZGVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js\n");

/***/ })

};
;